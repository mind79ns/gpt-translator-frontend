<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GPT 양방향 음성 번역기 Pro v6.0 - AI 문맥 번역 고도화</title>

    <!-- 📱 PWA 설정 - 모바일 최적화 -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#6366f1">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="GPT 번역기">

    <link rel="stylesheet" href="css/styles.css">
    <!-- 성능 최적화: CSS 외부 파일로 분리하여 캐싱 가능 -->

    <!-- 🔒 중복 탭 방지 스크립트 -->
    <script>
        (function () {
            const TAB_ID = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            const CHANNEL_NAME = 'gpt-translator-tab-channel';

            // BroadcastChannel로 탭 간 통신
            if (typeof BroadcastChannel !== 'undefined') {
                const channel = new BroadcastChannel(CHANNEL_NAME);

                // 새 탭 알림
                channel.postMessage({ type: 'NEW_TAB', tabId: TAB_ID });

                // 기존 탭에서 응답 수신
                channel.onmessage = function (event) {
                    if (event.data.type === 'TAB_EXISTS' && event.data.tabId !== TAB_ID) {
                        // 기존 탭이 있으면 현재 탭 닫기 유도
                        if (confirm('⚠️ 이미 다른 탭에서 번역기가 실행 중입니다.\n\n기존 탭으로 이동하시겠습니까?\n(확인: 이 탭 닫기, 취소: 계속 사용)')) {
                            window.close();
                            // 닫기 실패 시 안내
                            setTimeout(function () {
                                document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;background:#1a1a2e;color:white;text-align:center;padding:20px;"><div><h2>⚠️ 중복 탭 감지</h2><p>다른 탭에서 이미 번역기가 실행 중입니다.<br>해당 탭으로 이동해주세요.</p><button onclick="location.reload()" style="margin-top:20px;padding:10px 20px;background:#6366f1;color:white;border:none;border-radius:8px;cursor:pointer;">여기서 계속 사용</button></div></div>';
                            }, 100);
                        }
                    }
                    if (event.data.type === 'NEW_TAB' && event.data.tabId !== TAB_ID) {
                        // 새 탭에게 이미 탭이 있음을 알림
                        channel.postMessage({ type: 'TAB_EXISTS', tabId: TAB_ID });
                    }
                };

                // 탭 닫힐 때 알림
                window.addEventListener('beforeunload', function () {
                    channel.postMessage({ type: 'TAB_CLOSED', tabId: TAB_ID });
                });
            }

            // 오디오 컨텍스트 중복 방지를 위한 전역 플래그
            window.GPT_TRANSLATOR_TAB_ID = TAB_ID;
        })();
    </script>
</head>

<body>
    <div class="container">
        <div class="header">
            <!-- 제목을 별도 줄로 -->
            <div class="header-title">
                <h1>GPT 번역기 Pro v6.0</h1>
            </div>
            <!-- 아이콘들을 별도 줄로 -->
            <div class="header-controls">
                <button class="ai-toggle" id="aiToggle" onclick="toggleAIModeWithAuth()" title="AI 문맥 번역">🧠</button>
                <button class="dashboard-toggle" onclick="toggleDashboard()">📊</button>
                <button class="settings-toggle" onclick="toggleSettings()">⚙️</button>
                <button class="theme-toggle" onclick="toggleTheme()">🌙</button>
                <button class="login-toggle" id="loginToggle" onclick="handleLoginClick()" title="로그인/회원가입">👤</button>
            </div>
            <div class="language-selector">
                <select id="sourceLangSelect">
                    <option value="Korean">한국어</option>
                    <option value="Vietnamese">베트남어</option>
                    <option value="English">영어</option>
                </select>
                <button onclick="swapLanguages()">⇄</button>
                <select id="targetLangSelect">
                    <option value="Vietnamese">베트남어</option>
                    <option value="Korean">한국어</option>
                    <option value="English">영어</option>
                </select>
            </div>
            <span class="auto-detect-badge" id="autoDetectBadge"></span>
            <span class="ai-context-badge" id="aiContextBadge">🧠 AI 문맥 번역</span>
        </div>

        <div class="content">
            <div class="settings-panel" id="settingsPanel">
                <div class="settings-title"><span>⚙️ 설정</span><button class="settings-close"
                        onclick="toggleSettings()">×</button></div>

                <!-- AI 문맥 번역 설정 섹션 -->
                <div class="ai-settings-section" id="aiSettingsSection">
                    <div class="ai-settings-title">🧠 AI 문맥 번역 고도화</div>

                    <!-- 🤖 AI 모델 선택 (하이브리드 모드) -->
                    <div class="setting-item">
                        <label class="setting-label">🤖 AI 모델 선택<small>자동: 텍스트 길이에 따라 최적 모델 선택</small></label>
                        <div class="setting-control">
                            <select id="aiModelSelect" onchange="updateAIModelSelection()">
                                <option value="auto">🔄 자동 최적화 (추천)</option>
                                <option value="gpt-4o">🟢 GPT-4o (최고 품질)</option>
                                <option value="gpt-4o-mini">🟢 GPT-4o Mini (빠름)</option>
                                <option value="gemini-1.5-flash">🔵 Gemini 1.5 Flash (초고속/안정)</option>
                            </select>
                        </div>
                    </div>
                    <div class="model-indicator" id="modelIndicator"
                        style="font-size: 11px; color: var(--text-secondary); padding: 5px 0; text-align: center;">
                        현재 모드: <strong>자동 최적화</strong> - 텍스트 길이에 따라 최적 모델 선택
                    </div>

                    <!-- 🚀 스트리밍 모드 토글 - 비활성화 (Netlify 표준 함수는 실시간 SSE 미지원)
                    <div class="setting-item">
                        <label class="setting-label">🚀 스트리밍 모드<small>번역 결과를 실시간으로 표시 (실험적)</small></label>
                        <div class="setting-control">
                            <label class="toggle-switch">
                                <input type="checkbox" id="streamingModeToggle" onchange="toggleStreamingMode()">
                                <span class="toggle-slider"></span>
                            </label>
                            <span id="streamingModeStatus"
                                style="font-size: 11px; margin-left: 8px; color: var(--text-secondary);">비활성화</span>
                        </div>
                    </div>
                    -->

                    <!-- 🏭 전문 분야 선택 -->
                    <div class="setting-item">
                        <label class="setting-label">🏭 전문 분야<small>제조 자동화: 전문 용어 자동 적용</small></label>
                        <div class="setting-control">
                            <select id="domainSelect" onchange="updateDomainSelection()">
                                <option value="general">📝 일반</option>
                                <option value="manufacturing">🏭 제조 자동화</option>
                            </select>
                        </div>
                    </div>

                    <div class="setting-item quality-setting-wrapper">
                        <div class="quality-setting-grid">
                            <label class="setting-label">번역 품질 vs 속도<small>높을수록 정확하지만 느림</small></label>
                            <div class="setting-control">
                                <input type="range" class="quality-slider" id="qualitySlider" min="1" max="5" value="3"
                                    step="1">
                            </div>
                        </div>
                        <div class="quality-labels">
                            <span>빠름</span><span>균형</span><span>정확</span>
                        </div>
                        <!-- 옵션 1: 실시간 모델 정보 표시 -->
                        <div class="model-info-display" id="modelInfoDisplay">
                            <span class="model-name">모델: gpt-4o</span>
                            <span class="model-cost">비용: 중간</span>
                            <span class="model-tokens">토큰: 1500</span>
                        </div>
                    </div>

                    <div class="setting-item">
                        <label class="setting-label">번역 스타일</label>
                        <div class="style-buttons">
                            <div class="style-btn active" data-style="balanced">균형잡힌</div>
                            <div class="style-btn" data-style="formal">격식체</div>
                            <div class="style-btn" data-style="casual">친근체</div>
                            <div class="style-btn" data-style="literal">직역체</div>
                        </div>
                    </div>

                    <div class="setting-item">
                        <label class="setting-label">🔧 전문용어 사전<small>일관된 번역을 위한 용어집 관리</small></label>
                        <div class="terminology-section">
                            <div class="terminology-input-group">
                                <input type="text" class="terminology-input-single" id="terminologyInput"
                                    placeholder="용어 등록: AI | 인공지능">
                                <button onclick="addTerminology()" class="terminology-add-btn">➕</button>
                            </div>
                            <div class="terminology-list" id="terminologyList"></div>
                        </div>
                    </div>
                </div>

                <div class="settings-grid">
                    <div class="setting-item">
                        <label class="setting-label" for="ttsEngineMode">🔊 TTS 엔진 선택<small>Google: 무료/일반 | OpenAI:
                                유료/고품질</small></label>
                        <div class="setting-control"><select id="ttsEngineMode">
                                <option value="auto">🤖 자동 선택 (추천)</option>
                                <option value="google">🔵 Google TTS</option>
                                <option value="openai">🟢 OpenAI TTS</option>
                                <option value="smart">💡 스마트 모드</option>
                            </select></div>
                    </div>
                    <div class="setting-item" id="autoModeSettings">
                        <label class="setting-label" for="autoThreshold">자동 모드 임계값<small>이 글자 수 이하는 Google TTS
                                사용</small></label>
                        <div class="setting-control"><input type="range" id="autoThreshold" min="10" max="200"
                                value="50" step="10"><span class="setting-value" id="thresholdValue">50자</span></div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label" for="voiceSelect">음성 선택 (OpenAI)</label>
                        <div class="setting-control"><select id="voiceSelect">
                                <option value="nova">Nova (여성/선명)</option>
                                <option value="shimmer">Shimmer (여성/부드러움)</option>
                                <option value="alloy">Alloy (남성/차분)</option>
                                <option value="echo">Echo (남성/깊음)</option>
                                <option value="fable">Fable (남성/표현력)</option>
                                <option value="onyx">Onyx (남성/저음)</option>
                            </select></div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label" for="googleVoiceSelect">음성 선택 (Google)</label>
                        <div class="setting-control"><select id="googleVoiceSelect">
                                <option value="vi-VN-Standard-A">🇻🇳 Standard-A (여)</option>
                                <option value="vi-VN-Standard-B">🇻🇳 Standard-B (남)</option>
                                <option value="vi-VN-Standard-C">🇻🇳 Standard-C (여)</option>
                                <option value="vi-VN-Standard-D">🇻🇳 Standard-D (남)</option>
                                <option value="ko-KR-Standard-A">🇰🇷 Standard-A (여)</option>
                                <option value="ko-KR-Standard-B">🇰🇷 Standard-B (여)</option>
                                <option value="ko-KR-Standard-C">🇰🇷 Standard-C (남)</option>
                                <option value="ko-KR-Standard-D">🇰🇷 Standard-D (남)</option>
                            </select></div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label" for="volumeControl">볼륨</label>
                        <div class="setting-control"><input type="range" id="volumeControl" min="0.1" max="1"
                                value="0.8" step="0.1"><span class="setting-value" id="volumeValue">80%</span></div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">발음 도우미<small>OFF 시 API 요청 비용이 절감됩니다.</small></label>
                        <div class="setting-control">
                            <div class="toggle-switch" id="pronunciationToggle"></div>
                        </div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">💾 캐시 설정<small>반복 요청 시 비용 절감 및 속도 향상</small></label>
                        <div class="setting-control"><button onclick="clearAllCache()"
                                style="padding: 6px 12px; font-size: 11px; background-color: var(--error); border: none; border-radius: 5px; color: white;">🗑️
                                캐시 초기화</button></div>
                    </div>
                </div>
            </div>

            <div class="recent-plays collapsed" id="recentPlays">
                <div class="recent-plays-title"><span>🔄 최근 재생</span><button class="recent-plays-toggle"
                        onclick="toggleRecentPlays()" id="recentPlaysToggleBtn">펼치기</button></div>
                <div class="recent-play-list" id="recentPlayList" style="display: none;"></div>
            </div>

            <div class="mode-selector">
                <div class="mode-btn active" id="normalModeBtn" onclick="switchToNormalMode()">📝 일반 번역</div>
                <div class="mode-btn" id="conversationModeBtn" onclick="switchToConversationMode()">💬 대화 모드</div>
            </div>

            <div class="conversation-mode" id="conversationMode">
                <div class="speaker-info">
                    <div class="speaker-card speaker-a" id="speakerCardA">
                        <div class="speaker-title">🙋‍♂️ 화자 A</div>
                        <div class="speaker-lang" id="speakerLangA"></div>
                    </div>
                    <div class="speaker-card speaker-b" id="speakerCardB">
                        <div class="speaker-title">🙋‍♀️ 화자 B</div>
                        <div class="speaker-lang" id="speakerLangB"></div>
                    </div>
                </div>
                <div class="conversation-controls">
                    <button class="conv-btn conv-btn-start" id="startConversationBtn" onclick="startConversation()">🎤
                        시작</button>
                    <button class="conv-btn conv-btn-stop" id="stopConversationBtn" onclick="stopConversation()"
                        disabled>⏹️ 종료</button>
                    <button class="conv-btn conv-btn-clear" onclick="clearConversation()">🗑️ 지우기</button>
                </div>
                <div class="conversation-history" id="conversationHistory"></div>
            </div>

            <div class="normal-mode" id="normalMode">
                <div class="input-wrapper">
                    <textarea id="inputText" placeholder="번역할 텍스트를 입력하세요..."></textarea>
                    <div class="input-actions">
                        <button class="input-action-btn" onclick="copyInputText()">복사</button>
                        <button class="input-action-btn" onclick="pasteFromClipboard()">붙여넣기</button>
                    </div>
                </div>
                <div class="controls">
                    <button class="btn-translate" id="translateBtn" onclick="handleTranslate()"><span>📝</span> <span
                            id="translateBtnText">번역하기</span></button>
                    <button class="btn-voice" id="voiceBtn" onclick="handleVoiceTranslate()"><span>🎤</span> 음성
                        번역</button>
                    <button class="btn-clear" onclick="clearAll()"><span>🗑️</span> 모두 지우기</button>
                    <button class="btn-history" onclick="showHistory()"><span>📜</span> 기록 보기</button>
                </div>
                <div class="result-section">
                    <div class="result-header">
                        <span class="result-label">번역 결과<span id="cacheIndicator" class="cache-indicator"
                                style="display: none;">캐시됨</span><span id="aiIndicator" class="engine-indicator ai"
                                style="display: none;">AI</span></span>
                        <div class="result-actions">
                            <button class="btn-action" onclick="copyTranslation()" id="copyBtn" disabled>📋 복사</button>
                            <button class="btn-action" id="speakBtn" onclick="handleSpeak()" disabled>🔊 듣기<span
                                    id="engineIndicator" class="engine-indicator"
                                    style="display: none;"></span></button>
                        </div>
                    </div>
                    <div id="translation"></div>
                </div>
                <div class="pronunciation-section" id="pronunciationSection">
                    <div class="pronunciation-label" onclick="togglePronunciationView()">발음 도우미 <span
                            id="pronToggleIcon">▼</span></div>
                    <div id="pronunciation-content"></div>
                </div>
                <div class="translation-stats">
                    <div class="stat-item"><strong id="todayTranslations">0</strong><span>오늘 번역</span></div>
                    <div class="stat-item"><strong id="totalTranslations">0</strong><span>총 번역</span></div>
                    <div class="stat-item"><strong id="cacheHitRate">0%</strong><span>캐시 적중률</span></div>
                </div>
            </div>

            <div class="status" id="status"></div>
        </div>
    </div>


    <!-- 🔧 수정: 대시보드 모달에 월 비용 카드 추가 -->
    <div class="modal" id="dashboardModal">
        <div class="modal-content-wrapper">
            <div class="modal-header">
                <span class="modal-title">📊 대시보드</span>
                <button class="modal-close" onclick="toggleDashboard()">×</button>
            </div>
            <div class="usage-cards">
                <div class="usage-card">
                    <div class="usage-card-value" id="todayUsage">0</div>
                    <div class="usage-card-label">오늘 번역</div>
                </div>
                <div class="usage-card">
                    <div class="usage-card-value" id="monthUsage">0</div>
                    <div class="usage-card-label">이번 달</div>
                </div>
                <div class="usage-card">
                    <div class="usage-card-value" id="todayCost">$0.00</div>
                    <div class="usage-card-label">오늘 비용</div>
                </div>
                <!-- ➕ 새로 추가: 해당 월 비용 카드 -->
                <div class="usage-card">
                    <div class="usage-card-value" id="monthCost">$0.00</div>
                    <div class="usage-card-label">이번 달 비용</div>
                </div>
                <div class="usage-card">
                    <div class="usage-card-value" id="savedCost">$0.00</div>
                    <div class="usage-card-label">절감 비용</div>
                </div>
            </div>
            <div class="chart-container">
                <div class="chart-title">📈 7일 사용량</div>
                <div class="simple-bar-chart" id="weeklyChart"></div>
            </div>
            <!-- ➕ 새로 추가: 월별 비용 차트 -->
            <div class="chart-container">
                <div class="chart-title">💰 월별 비용 추이 (최근 6개월)</div>
                <div class="simple-bar-chart" id="monthlyChart"></div>
            </div>
            <div class="limit-settings">
                <div class="limit-title">⚠️ API 한도 관리</div>
                <div class="limit-item">
                    <span class="limit-label">일일 예산 ($)</span>
                    <input type="number" class="limit-input" id="dailyBudget" value="1.00" step="0.10">
                </div>
                <div class="limit-item">
                    <span class="limit-label">월간 예산 ($)</span>
                    <input type="number" class="limit-input" id="monthlyBudget" value="30.00" step="1.00">
                </div>
                <div class="limit-progress">
                    <div class="limit-progress-bar" id="budgetProgress"></div>
                </div>
                <div class="limit-percentage" id="budgetPercentage">0% 사용</div>
                <div class="limit-item" style="margin-top: 15px;">
                    <span class="limit-label">한도 도달 시</span>
                    <select id="limitAction" style="width: 150px; padding: 5px; border-radius: 5px; font-size: 12px;">
                        <option value="switch">Google로 전환</option>
                        <option value="warn">경고만</option>
                        <option value="block">차단</option>
                    </select>
                </div>
            </div>
        </div>
    </div>

    <div class="modal" id="historyModal">
        <div class="modal-content-wrapper">
            <div class="modal-header"><span class="modal-title">📜 번역 기록</span><button class="modal-close"
                    onclick="hideHistory()">×</button></div>
            <div id="historyList" style="max-height: 400px; overflow-y: auto;"></div><button onclick="clearHistory()"
                style="width: 100%; margin-top: 15px; background: var(--error); color: white; border: none; border-radius: 5px; padding: 8px;">기록
                모두 삭제</button>
        </div>
    </div>

    <!-- 🔐 로그인/회원가입 모달 -->
    <div class="auth-modal" id="authModal">
        <div class="auth-content">
            <div class="auth-header">
                <div class="auth-tabs">
                    <button class="auth-tab active" data-tab="login">🔑 로그인</button>
                    <button class="auth-tab" data-tab="register">📝 회원가입</button>
                </div>
                <button class="auth-close" onclick="toggleAuth()">×</button>
            </div>

            <div class="auth-form active" id="loginForm">
                <div class="auth-form-title">GPT 번역기 Pro 로그인</div>
                <div class="auth-input-group">
                    <input type="email" id="loginEmail" placeholder="이메일 주소" required>
                    <input type="password" id="loginPassword" placeholder="비밀번호" required>
                </div>
                <button class="auth-btn primary" onclick="handleLogin()">🔑 로그인</button>
                <div class="auth-divider">또는</div>
                <button class="auth-btn guest" onclick="continueAsGuest()">🎯 게스트로 계속하기</button>
                <div class="auth-links">
                    <a href="#" onclick="event.preventDefault(); switchAuthTab('forgot');">비밀번호를 잊으셨나요?</a>
                </div>
            </div>

            <div class="auth-form" id="registerForm">
                <div class="auth-form-title">새 계정 만들기</div>
                <div class="auth-input-group">
                    <input type="text" id="registerName" placeholder="이름 (선택사항)">
                    <input type="email" id="registerEmail" placeholder="이메일 주소" required>
                    <input type="password" id="registerPassword" placeholder="비밀번호 (8자 이상)" required>
                    <input type="password" id="registerPasswordConfirm" placeholder="비밀번호 확인" required>
                </div>
                <div class="auth-agreement">
                    <label class="auth-checkbox">
                        <input type="checkbox" id="agreeTerms" required>
                        <span>서비스 이용약관 및 개인정보처리방침에 동의합니다</span>
                    </label>
                </div>
                <button class="auth-btn primary" onclick="handleRegister()">📝 회원가입</button>
                <div class="auth-links">
                    <a href="#" onclick="event.preventDefault(); switchAuthTab('login');">← 로그인으로 돌아가기</a>
                </div>
            </div>

            <div class="auth-form" id="forgotForm">
                <div class="auth-form-title">비밀번호 재설정</div>
                <div class="auth-input-group">
                    <input type="email" id="forgotEmail" placeholder="가입한 이메일 주소" required>
                </div>
                <button class="auth-btn primary" onclick="handleForgotPassword()">📧 재설정 링크 보내기</button>
                <div class="auth-links">
                    <a href="#" onclick="event.preventDefault(); switchAuthTab('login');">← 로그인으로 돌아가기</a>
                </div>
            </div>
        </div>
    </div>

    <div class="auth-info">
    </div>
    </div>
    <div class="auth-info">
        <small>• 개인 API 키 등록으로 무제한 번역</small>
        <small>• 사용량 추적 및 분석</small>
        <small>• 고급 단어장 및 학습 기록 저장</small>
    </div>
    </div>

    <!-- 비밀번호 찾기 폼 -->
    <div class="auth-form" id="forgotForm" style="display: none;">
        <div class="auth-form-title">비밀번호 재설정</div>
        <div class="auth-input-group">
            <input type="email" id="forgotEmail" placeholder="가입한 이메일 주소" required>
        </div>
        <button class="auth-btn primary" onclick="handleForgotPassword()">📧 재설정 링크 보내기</button>
        <div class="auth-links">
            <a href="#" onclick="showLoginForm()">← 로그인으로 돌아가기</a>
        </div>
    </div>
    </div>
    </div>

    <!-- 🔧 API 키 관리 모달 -->
    <div class="api-keys-modal" id="apiKeysModal">
        <div class="api-keys-content">
            <div class="api-keys-header">
                <span class="api-keys-title">🔑 API 키 관리</span>
                <button class="api-keys-close" onclick="toggleApiKeys()">×</button>
            </div>
            <div class="api-keys-body">
                <div class="api-key-section">
                    <div class="api-key-title">🤖 OpenAI API 키</div>
                    <div class="api-key-description">번역 및 TTS 기능을 위한 OpenAI API 키를 등록하세요</div>
                    <div class="api-key-input-group">
                        <input type="password" id="openaiApiKey" placeholder="sk-..." maxlength="200">
                        <button class="api-key-btn test" onclick="testOpenAIKey()">테스트</button>
                        <button class="api-key-btn save" onclick="saveOpenAIKey()">저장</button>
                    </div>
                    <div class="api-key-status" id="openaiKeyStatus"></div>
                </div>

                <div class="api-key-section">
                    <div class="api-key-title">🎤 Google TTS API 키</div>
                    <div class="api-key-description">고품질 음성 합성을 위한 Google Cloud API 키 (선택사항)</div>
                    <div class="api-key-input-group">
                        <input type="password" id="googleApiKey" placeholder="AIza..." maxlength="200">
                        <button class="api-key-btn test" onclick="testGoogleKey()">테스트</button>
                        <button class="api-key-btn save" onclick="saveGoogleKey()">저장</button>
                    </div>
                    <div class="api-key-status" id="googleKeyStatus"></div>
                </div>

                <div class="api-key-info">
                    <div class="api-key-info-title">💡 API 키 사용 혜택</div>
                    <ul>
                        <li>✅ 무제한 번역 및 TTS 사용</li>
                        <li>✅ 개인 사용량 및 비용 추적</li>
                        <li>✅ 더 빠른 응답 속도</li>
                        <li>✅ 프리미엄 기능 이용</li>
                    </ul>
                    <div class="api-key-help">
                        <a href="https://platform.openai.com/api-keys" target="_blank">OpenAI API 키 발급받기 →</a>
                        <br>
                        <a href="https://console.cloud.google.com/" target="_blank">Google Cloud API 키 발급받기 →</a>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========== localStorage 비동기 래퍼 (성능 최적화) ==========
        // UI 블로킹 방지를 위한 비동기 스토리지 유틸리티

        const AsyncStorage = {
            // 읽기 (Promise 기반)
            async getItem(key) {
                return new Promise((resolve) => {
                    // requestIdleCallback으로 유휴 시간에 실행
                    if ('requestIdleCallback' in window) {
                        requestIdleCallback(() => {
                            resolve(localStorage.getItem(key));
                        });
                    } else {
                        // Fallback: setTimeout으로 마이크로태스크 큐에 추가
                        setTimeout(() => {
                            resolve(localStorage.getItem(key));
                        }, 0);
                    }
                });
            },

            // 쓰기 (Promise 기반)
            async setItem(key, value) {
                return new Promise((resolve) => {
                    if ('requestIdleCallback' in window) {
                        requestIdleCallback(() => {
                            localStorage.setItem(key, value);
                            resolve();
                        });
                    } else {
                        setTimeout(() => {
                            localStorage.setItem(key, value);
                            resolve();
                        }, 0);
                    }
                });
            },

            // 삭제 (Promise 기반)
            async removeItem(key) {
                return new Promise((resolve) => {
                    if ('requestIdleCallback' in window) {
                        requestIdleCallback(() => {
                            localStorage.removeItem(key);
                            resolve();
                        });
                    } else {
                        setTimeout(() => {
                            localStorage.removeItem(key);
                            resolve();
                        }, 0);
                    }
                });
            },

            // 동기식 읽기 (즉시 필요한 경우만 사용)
            getItemSync(key) {
                return localStorage.getItem(key);
            },

            // 동기식 쓰기 (즉시 필요한 경우만 사용)
            setItemSync(key, value) {
                localStorage.setItem(key, value);
            }
        };

        // 디바운스 유틸리티 (빈번한 저장 방지)
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // ===================================================
        // GPT 양방향 음성 번역기 Pro v6.0 - AI 문맥 번역 고도화
        // ===================================================
        const API_URL = 'https://knstranslator.netlify.app/.netlify/functions/translate';
        const AUTH_API_URL = 'https://knstranslator.netlify.app/.netlify/functions/auth'; // 🔧 추가: 인증 API URL

        // 🔐 사용자 인증 시스템
        let currentUser = null;
        let authToken = null;

        // 🔐 인증 상태 관리 (개선)
        async function initAuthSystem() {
            console.log('[Auth] 시스템 초기화 시작');

            // 저장된 토큰 확인
            const savedToken = localStorage.getItem('authToken');
            const savedUser = localStorage.getItem('currentUser');

            if (savedToken && savedUser) {
                try {
                    // 🔧 개선: 실제 토큰 검증
                    const isValidToken = await verifyStoredToken(savedToken);

                    if (isValidToken) {
                        authToken = savedToken;
                        currentUser = JSON.parse(savedUser);
                        updateAuthUI(true);

                        console.log('[Auth] 사용자 세션 복원 성공:', currentUser.email);

                        // 🔧 추가: 사용자 데이터 새로고침
                        await refreshUserData();

                        showStatus(`👋 ${currentUser.displayName || currentUser.email}님 환영합니다!`, "success");
                    } else {
                        console.log('[Auth] 저장된 토큰이 만료되었습니다');
                        clearAuthData();
                        updateAuthUI(false);
                        showStatus("세션이 만료되었습니다. 다시 로그인해주세요", "warning");
                    }
                } catch (error) {
                    console.error('[Auth] 세션 복원 실패:', error);
                    clearAuthData();
                    updateAuthUI(false);
                }
            } else {
                console.log('[Auth] 저장된 인증 정보 없음 - 게스트 모드');
                updateAuthUI(false);
            }

            // 🔧 추가: 인증 관련 이벤트 리스너 설정
            setupAuthEventListeners();
        }

        // 🔐 저장된 토큰 검증
        async function verifyStoredToken(token) {
            try {
                const response = await fetch(AUTH_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        action: 'verify-token'
                    })
                });

                const result = await response.json();
                return result.success || false;

            } catch (error) {
                console.error('[Auth] 토큰 검증 오류:', error);
                return false;
            }
        }

        // 🔐 사용자 데이터 새로고침
        async function refreshUserData() {
            if (!currentUser || !authToken) return;

            try {
                console.log('[Auth] 사용자 데이터 새로고침 중...');

                // 🔧 API 키 상태 확인
                const apiKeysResponse = await fetch(AUTH_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({
                        action: 'get-api-keys'
                    })
                });

                if (apiKeysResponse.ok) {
                    const apiKeysData = await apiKeysResponse.json();
                    if (apiKeysData.success) {
                        // 🔧 사용자 객체에 API 키 정보 추가
                        currentUser.hasOpenAIKey = apiKeysData.openaiKey;
                        currentUser.hasGoogleKey = apiKeysData.googleKey;

                        console.log('[Auth] API 키 상태 업데이트:', {
                            openai: currentUser.hasOpenAIKey,
                            google: currentUser.hasGoogleKey
                        });
                    }
                }

                // 🔧 사용량 데이터 새로고침
                await refreshUsageData();

                // 🔧 업데이트된 사용자 정보 저장
                localStorage.setItem('currentUser', JSON.stringify(currentUser));

            } catch (error) {
                console.error('[Auth] 사용자 데이터 새로고침 실패:', error);
            }
        }

        // 🔐 사용량 데이터 새로고침
        async function refreshUsageData() {
            if (!authToken) return;

            try {
                const response = await fetch(AUTH_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({
                        action: 'get-usage'
                    })
                });

                if (response.ok) {
                    const usageData = await response.json();
                    if (usageData.success) {
                        // 🔧 실제 사용량 데이터로 UI 업데이트
                        updateUsageUI(usageData.usage);

                        console.log('[Auth] 사용량 데이터 업데이트 완료');
                    }
                }

            } catch (error) {
                console.error('[Auth] 사용량 데이터 새로고침 실패:', error);
            }
        }

        // 🔐 사용량 UI 업데이트
        function updateUsageUI(usageData) {
            if (!usageData) return;

            // 대시보드 카드 업데이트
            const todayUsageEl = document.getElementById('todayUsage');
            const monthUsageEl = document.getElementById('monthUsage');
            const todayCostEl = document.getElementById('todayCost');
            const monthCostEl = document.getElementById('monthCost');

            if (todayUsageEl) todayUsageEl.textContent = usageData.today?.translations || 0;
            if (monthUsageEl) monthUsageEl.textContent = usageData.thisMonth?.translations || 0;
            if (todayCostEl) todayCostEl.textContent = `$${(usageData.today?.cost || 0).toFixed(4)}`;
            if (monthCostEl) monthCostEl.textContent = `$${(usageData.thisMonth?.cost || 0).toFixed(4)}`;

            // 통계 정보 업데이트
            const todayTranslationsEl = document.getElementById('todayTranslations');
            if (todayTranslationsEl) todayTranslationsEl.textContent = usageData.today?.translations || 0;

            // 주간 차트 업데이트
            if (usageData.weekly && usageData.weekly.length > 0) {
                updateWeeklyChart(usageData.weekly);
            }
        }

        // 🔐 주간 차트 업데이트
        function updateWeeklyChart(weeklyData) {
            const chartEl = document.getElementById('weeklyChart');
            if (!chartEl) return;

            const maxTranslations = Math.max(...weeklyData.map(d => d.translation_count || 0), 1);

            chartEl.innerHTML = weeklyData.map(dayData => {
                const count = dayData.translation_count || 0;
                const height = (count / maxTranslations) * 100;
                const date = new Date(dayData.date);
                const dayLabel = date.toLocaleDateString('ko-KR', { weekday: 'short' });

                return `
            <div class="bar" style="height: ${height}%">
                <span class="bar-value">${count}</span>
                <span class="bar-label">${dayLabel}</span>
            </div>
        `;
            }).join('');
        }

        // 🔐 인증 이벤트 리스너 설정
        function setupAuthEventListeners() {
            // 🔧 인증 탭 전환 이벤트
            document.querySelectorAll('.auth-tab').forEach(tab => {
                tab.addEventListener('click', function () {
                    switchAuthTab(this.dataset.tab);
                });
            });

            // 🔧 API 키 관리 이벤트는 이미 setupApiKeyEvents()에서 처리
            setupApiKeyEvents();

            // 🔧 로그인 폼 엔터키 처리
            const loginEmail = document.getElementById('loginEmail');
            const loginPassword = document.getElementById('loginPassword');

            if (loginEmail) {
                loginEmail.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') {
                        loginPassword?.focus();
                    }
                });
            }

            if (loginPassword) {
                loginPassword.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') {
                        handleLogin();
                    }
                });
            }

            // 🔧 회원가입 폼 엔터키 처리
            const registerPassword = document.getElementById('registerPassword');
            const registerPasswordConfirm = document.getElementById('registerPasswordConfirm');

            if (registerPassword) {
                registerPassword.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') {
                        registerPasswordConfirm?.focus();
                    }
                });
            }

            if (registerPasswordConfirm) {
                registerPasswordConfirm.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') {
                        handleRegister();
                    }
                });
            }
        }

        // 🔧 로그인 클릭 핸들러 (디버그용)
        function handleLoginClick() {
            if (currentUser) {
                // 로그인된 상태: 사용자에게 로그아웃할지 API 키를 관리할지 선택권을 줍니다.
                if (confirm('로그아웃하시겠습니까?\n\n취소를 누르면 API 키 관리 화면으로 이동합니다.')) {
                    handleLogout(); // "확인" 클릭 시 로그아웃 함수 호출
                } else {
                    toggleApiKeys(); // "취소" 클릭 시 API 키 관리 창 열기
                }
            } else {
                // 로그인 안된 상태: 로그인 모달 열기
                toggleAuth();
            }
        }

        // 참고: handleLogout 함수는 이미 아래와 같이 구현되어 있습니다.
        function handleLogout() {
            if (confirm('로그아웃 하시겠습니까?')) {
                clearAuthData();
                updateAuthUI(false);
                showStatus("로그아웃되었습니다", "info");
            }
        }

        // 🔐 인증 모달 토글 (강화된 디버그)
        function toggleAuth() {
            console.log('[Debug] toggleAuth 시작');

            const authModal = document.getElementById('authModal');

            if (!authModal) {
                console.error('[Debug] authModal 요소를 찾을 수 없습니다');
                return;
            }

            // 이미 로그인된 경우
            if (currentUser) {
                console.log('[Debug] 로그인된 사용자 - API 키 관리로 전환');
                toggleApiKeys();
                return;
            }

            // 모달 토글
            const isActive = authModal.classList.contains('active');
            console.log('[Debug] 현재 모달 상태:', isActive ? '열림' : '닫힘');

            if (isActive) {
                authModal.classList.remove('active');
                console.log('[Debug] 모달 닫기 완료');
            } else {
                authModal.classList.add('active');
                console.log('[Debug] 모달 열기 완료');

                // 다른 모달들 닫기
                document.getElementById('dashboardModal')?.classList.remove('active');
                document.getElementById('settingsPanel')?.classList.remove('active');
                document.getElementById('vocabularyDropdown')?.classList.remove('active');
                document.getElementById('practiceModal')?.classList.remove('active');
                document.getElementById('wordDetailModal')?.classList.remove('active');
                document.getElementById('quizModal')?.classList.remove('active');
                console.log('[Debug] 다른 모달들 닫기 완료');
            }
        }

        // 🔐 API 키 관리 모달 토글
        function toggleApiKeys() {
            const apiKeysModal = document.getElementById('apiKeysModal');

            if (!currentUser) {
                showStatus("API 키 관리는 로그인 후 이용 가능합니다", "warning");
                toggleAuth();
                return;
            }

            apiKeysModal.classList.toggle('active');

            if (apiKeysModal.classList.contains('active')) {
                loadUserApiKeys();
                // 다른 모달들 닫기
                document.getElementById('authModal')?.classList.remove('active');
                document.getElementById('dashboardModal')?.classList.remove('active');
            }
        }

        // 🔐 인증 탭 전환
        function switchAuthTab(tabName) {
            // 탭 활성화
            document.querySelectorAll('.auth-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            const activeTab = document.querySelector(`[data-tab="${tabName}"]`);
            if (activeTab) {
                activeTab.classList.add('active');
            }

            // 모든 폼 숨기기
            document.querySelectorAll('.auth-form').forEach(form => {
                form.classList.remove('active');
            });

            // 목표 폼 표시
            const targetFormId = tabName === 'login' ? 'loginForm' : 'registerForm';
            const targetForm = document.getElementById(targetFormId);
            if (targetForm) {
                targetForm.classList.add('active');
            }
        }

        // 🔐 로그인 처리
        async function handleLogin() {
            const email = document.getElementById('loginEmail').value.trim();
            const password = document.getElementById('loginPassword').value;

            if (!email || !password) {
                showStatus("이메일과 비밀번호를 입력해주세요", "warning");
                return;
            }

            showStatus("로그인 중...", "info");

            try {
                const response = await fetch(AUTH_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'login',
                        email: email,
                        password: password
                    })
                });

                const result = await response.json();

                if (result.success) {
                    currentUser = result.user;
                    authToken = result.token;

                    // 로컬 스토리지에 저장
                    localStorage.setItem('authToken', authToken);
                    localStorage.setItem('currentUser', JSON.stringify(currentUser));

                    updateAuthUI(true);
                    toggleAuth(); // 모달 닫기

                    showStatus(`✅ ${currentUser.displayName || currentUser.email}님 환영합니다!`, "success");

                    // 폼 초기화
                    document.getElementById('loginEmail').value = '';
                    document.getElementById('loginPassword').value = '';

                } else {
                    showStatus(`로그인 실패: ${result.error}`, "error");
                }

            } catch (error) {
                console.error('[Auth] 로그인 오류:', error);
                showStatus("로그인 중 오류가 발생했습니다", "error");
            }
        }

        // 🔐 회원가입 처리
        async function handleRegister() {
            const name = document.getElementById('registerName').value.trim();
            const email = document.getElementById('registerEmail').value.trim();
            const password = document.getElementById('registerPassword').value;
            const passwordConfirm = document.getElementById('registerPasswordConfirm').value;
            const agreeTerms = document.getElementById('agreeTerms').checked;

            // 유효성 검사
            if (!email || !password) {
                showStatus("이메일과 비밀번호를 입력해주세요", "warning");
                return;
            }

            if (password.length < 8) {
                showStatus("비밀번호는 8자 이상이어야 합니다", "warning");
                return;
            }

            if (password !== passwordConfirm) {
                showStatus("비밀번호가 일치하지 않습니다", "warning");
                return;
            }

            if (!agreeTerms) {
                showStatus("서비스 이용약관에 동의해주세요", "warning");
                return;
            }

            showStatus("회원가입 중...", "info");

            try {
                const response = await fetch(AUTH_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'register',
                        email: email,
                        password: password,
                        displayName: name || null
                    })
                });

                const result = await response.json();

                if (result.success) {
                    showStatus("✅ 회원가입이 완료되었습니다. 로그인해주세요", "success");

                    // 폼 초기화
                    document.getElementById('registerName').value = '';
                    document.getElementById('registerEmail').value = '';
                    document.getElementById('registerPassword').value = '';
                    document.getElementById('registerPasswordConfirm').value = '';
                    document.getElementById('agreeTerms').checked = false;

                    // 로그인 탭으로 전환
                    switchAuthTab('login');

                    // 이메일 자동 입력
                    document.getElementById('loginEmail').value = email;

                } else {
                    showStatus(`회원가입 실패: ${result.error}`, "error");
                }

            } catch (error) {
                console.error('[Auth] 회원가입 오류:', error);
                showStatus("회원가입 중 오류가 발생했습니다", "error");
            }
        }

        // 🔐 로그아웃 처리
        function handleLogout() {
            if (confirm('로그아웃 하시겠습니까?')) {
                clearAuthData();
                updateAuthUI(false);
                showStatus("로그아웃되었습니다", "info");
            }
        }

        // 🔐 게스트 모드 계속
        function continueAsGuest() {
            toggleAuth(); // 모달 닫기
            showStatus("🎯 게스트 모드로 이용 중입니다", "info");
        }

        // 🔐 비밀번호 찾기 표시
        function showForgotPassword() {
            document.querySelectorAll('.auth-form').forEach(form => {
                form.style.display = 'none';
            });
            document.getElementById('forgotForm').style.display = 'block';
        }

        // 🔐 로그인 폼으로 돌아가기
        function showLoginForm() {
            document.querySelectorAll('.auth-form').forEach(form => {
                form.style.display = 'none';
            });
            document.getElementById('loginForm').style.display = 'block';
        }

        // 🔐 비밀번호 재설정 처리
        async function handleForgotPassword() {
            const email = document.getElementById('forgotEmail').value.trim();

            if (!email) {
                showStatus("이메일을 입력해주세요", "warning");
                return;
            }

            showStatus("재설정 링크 발송 중...", "info");

            try {
                const response = await fetch(AUTH_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'forgot-password',
                        email: email
                    })
                });

                const result = await response.json();

                if (result.success) {
                    showStatus("📧 재설정 링크가 이메일로 발송되었습니다", "success");
                    showLoginForm();
                } else {
                    showStatus(`발송 실패: ${result.error}`, "error");
                }

            } catch (error) {
                console.error('[Auth] 비밀번호 재설정 오류:', error);
                showStatus("재설정 링크 발송 중 오류가 발생했습니다", "error");
            }
        }

        // 🔐 인증 데이터 삭제
        function clearAuthData() {
            currentUser = null;
            authToken = null;
            localStorage.removeItem('authToken');
            localStorage.removeItem('currentUser');
        }

        // 🔐 인증 UI 업데이트 (완전 개선)
        function updateAuthUI(isLoggedIn) {
            const loginToggle = document.getElementById('loginToggle');

            if (isLoggedIn && currentUser) {
                // 🔧 로그인 상태 UI
                loginToggle.classList.add('logged-in');
                loginToggle.title = `${currentUser.displayName || currentUser.email} - API 키 관리`;
                loginToggle.innerHTML = '👤✓';

                // 🔧 프리미엄 기능 표시
                updatePremiumFeatures(true);

                // 🔧 대시보드 데이터 표시
                updateDashboardAccess(true);

                // 🔧 설정 패널 고급 기능 표시
                updateAdvancedSettings(true);

                console.log('[UI] 로그인 상태 UI 적용:', currentUser.email);

            } else {
                // 🔧 게스트 상태 UI
                loginToggle.classList.remove('logged-in');
                loginToggle.title = '로그인/회원가입';
                loginToggle.innerHTML = '👤';

                // 🔧 기능 제한 적용
                updatePremiumFeatures(false);
                updateDashboardAccess(false);
                updateAdvancedSettings(false);

                console.log('[UI] 게스트 상태 UI 적용');
            }

            // 🔧 번역/TTS 버튼 상태 업데이트
            updateTranslationButtonStates();
        }

        // 🔧 프리미엄 기능 UI 업데이트
        function updatePremiumFeatures(hasAccess) {
            // AI 번역 토글 버튼
            const aiToggle = document.getElementById('aiToggle');
            if (aiToggle) {
                if (hasAccess) {
                    aiToggle.style.opacity = '1';
                    aiToggle.style.pointerEvents = 'auto';
                    aiToggle.title = 'AI 문맥 번역 (프리미엄)';
                } else {
                    if (aiContextMode) {
                        toggleAIMode(); // AI 모드 비활성화
                    }
                    aiToggle.style.opacity = '0.5';
                    aiToggle.style.pointerEvents = 'auto'; // 클릭은 가능하게 (경고 표시용)
                    aiToggle.title = 'AI 문맥 번역 (로그인 필요)';
                }
            }

            // 고급 단어장 토글 버튼
            const vocabToggle = document.getElementById('vocabToggle');
            if (vocabToggle) {
                if (hasAccess) {
                    vocabToggle.style.opacity = '1';
                    vocabToggle.style.pointerEvents = 'auto';
                    vocabToggle.title = '고급 단어장 (프리미엄)';
                } else {
                    vocabToggle.style.opacity = '0.5';
                    vocabToggle.style.pointerEvents = 'auto';
                    vocabToggle.title = '고급 단어장 (로그인 필요)';
                }
            }

            // 설정 패널의 AI 섹션
            const aiSettingsSection = document.getElementById('aiSettingsSection');
            if (aiSettingsSection) {
                if (!hasAccess) {
                    aiSettingsSection.style.opacity = '0.5';
                    // 비활성화 오버레이 추가
                    if (!aiSettingsSection.querySelector('.premium-overlay')) {
                        const overlay = document.createElement('div');
                        overlay.className = 'premium-overlay';
                        overlay.style.cssText = `
                    position: absolute; top: 0; left: 0; right: 0; bottom: 0;
                    background: rgba(0,0,0,0.1); z-index: 10; cursor: pointer;
                    display: flex; align-items: center; justify-content: center;
                    font-size: 12px; color: var(--primary); font-weight: bold;
                `;
                        overlay.innerHTML = '🔒 로그인 필요';
                        overlay.onclick = () => showPremiumAlert('AI 문맥 번역 설정');
                        aiSettingsSection.style.position = 'relative';
                        aiSettingsSection.appendChild(overlay);
                    }
                } else {
                    aiSettingsSection.style.opacity = '1';
                    const overlay = aiSettingsSection.querySelector('.premium-overlay');
                    if (overlay) overlay.remove();
                }
            }
        }

        // 🔧 대시보드 접근 제어
        function updateDashboardAccess(hasAccess) {
            // 대시보드 버튼 상태는 항상 활성화 (게스트도 로컬 데이터 볼 수 있음)
            // 하지만 내용이 다르게 표시됨
        }

        // 🔧 고급 설정 표시/숨김
        function updateAdvancedSettings(hasAccess) {
            // 현재는 모든 설정이 게스트도 사용 가능하므로 특별한 제한 없음
            // 추후 프리미엄 전용 설정 추가 시 여기서 제어
        }

        // 🔧 번역/TTS 버튼 상태 업데이트
        function updateTranslationButtonStates() {
            const translateBtn = document.getElementById('translateBtn');
            const speakBtn = document.getElementById('speakBtn');

            if (!currentUser) {
                // 게스트 모드 표시
                if (translateBtn) {
                    const originalText = translateBtn.textContent;
                    if (!originalText.includes('(게스트)')) {
                        translateBtn.innerHTML = translateBtn.innerHTML.replace('번역하기', '번역하기 (게스트)');
                    }
                }
            } else {
                // 로그인 모드 표시
                if (translateBtn) {
                    translateBtn.innerHTML = translateBtn.innerHTML.replace(' (게스트)', '');
                }
            }
        }

        // 🔧 프리미엄 기능 접근 시 알림
        function showPremiumAlert(featureName) {
            if (currentUser) {
                showStatus(`${featureName} 기능은 이미 사용 가능합니다`, "info");
                return;
            }

            // 중복 팝업 방지를 위한 플래그 체크
            if (window.alertShowing) {
                console.log('[Debug] 이미 팝업이 표시 중입니다');
                return;
            }

            window.alertShowing = true;

            const shouldLogin = confirm(
                `🔒 ${featureName} 기능은 로그인 후 이용 가능합니다.\n\n` +
                `• 무제한 번역 및 TTS\n` +
                `• 개인 API 키 등록\n` +
                `• 사용량 추적 및 분석\n` +
                `• 고급 단어장 및 학습 기록\n\n` +
                `지금 로그인하시겠습니까?`
            );

            window.alertShowing = false;

            if (shouldLogin) {
                // 직접 모달 열기 (toggleAuth 대신)
                const authModal = document.getElementById('authModal');
                if (authModal) {
                    authModal.classList.add('active');
                    console.log('[Debug] 로그인 모달 열기');
                } else {
                    console.error('[Debug] authModal을 찾을 수 없습니다');
                }
            }
        }

        // 🔧 AI 모드 토글 시 권한 체크
        function toggleAIModeWithAuth() {
            if (!currentUser) {
                showPremiumAlert('AI 문맥 번역');
                return;
            }

            toggleAIMode();
        }

        // 🔧 단어장 토글 시 권한 체크  
        function toggleVocabularyWithAuth() {
            if (!currentUser) {
                showPremiumAlert('고급 단어장');
                return;
            }

            toggleVocabulary();
        }

        // 🔑 API 키 관리 시스템 (개선)
        async function loadUserApiKeys() {
            if (!currentUser || !authToken) {
                console.log('[API Keys] 사용자 미인증');
                // 비인증 상태 UI 표시
                updateApiKeyStatus('openai', 'error', '❌ 로그인이 필요합니다');
                updateApiKeyStatus('google', 'error', '❌ 로그인이 필요합니다');
                return;
            }

            console.log('[API Keys] 사용자 API 키 로드 시작');

            // 로딩 상태 표시
            updateApiKeyStatus('openai', 'info', '🔄 API 키 정보 로드 중...');
            updateApiKeyStatus('google', 'info', '🔄 API 키 정보 로드 중...');

            try {
                const response = await fetch(AUTH_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({
                        action: 'get-api-keys'
                    })
                });

                if (!response.ok) {
                    throw new Error(`API 요청 실패: ${response.status}`);
                }

                const result = await response.json();

                if (result.success) {
                    console.log('[API Keys] 키 정보 로드 성공:', result);

                    // 🔧 OpenAI 키 상태 업데이트
                    if (result.openaiKey) {
                        document.getElementById('openaiApiKey').value = '••••••••••••••••••••';
                        document.getElementById('openaiApiKey').placeholder = 'API 키가 등록되어 있습니다';
                        updateApiKeyStatus('openai', 'success', '✅ OpenAI API 키가 등록되어 있습니다');

                        // 글로벌 상태 업데이트
                        if (currentUser) currentUser.hasOpenAIKey = true;
                    } else {
                        document.getElementById('openaiApiKey').value = '';
                        document.getElementById('openaiApiKey').placeholder = 'sk-...';
                        updateApiKeyStatus('openai', 'error', '❌ OpenAI API 키가 등록되지 않았습니다');

                        if (currentUser) currentUser.hasOpenAIKey = false;
                    }

                    // 🔧 Google 키 상태 업데이트
                    if (result.googleKey) {
                        document.getElementById('googleApiKey').value = '••••••••••••••••••••';
                        document.getElementById('googleApiKey').placeholder = 'API 키가 등록되어 있습니다';
                        updateApiKeyStatus('google', 'success', '✅ Google API 키가 등록되어 있습니다');

                        if (currentUser) currentUser.hasGoogleKey = true;
                    } else {
                        document.getElementById('googleApiKey').value = '';
                        document.getElementById('googleApiKey').placeholder = 'AIza...';
                        updateApiKeyStatus('google', 'error', '❌ Google API 키가 등록되지 않았습니다');

                        if (currentUser) currentUser.hasGoogleKey = false;
                    }

                    // 🔧 사용자 정보 업데이트 및 저장
                    if (currentUser) {
                        localStorage.setItem('currentUser', JSON.stringify(currentUser));
                    }

                } else {
                    console.error('[API Keys] 로드 실패:', result.error);
                    updateApiKeyStatus('openai', 'error', `❌ 로드 실패: ${result.error}`);
                    updateApiKeyStatus('google', 'error', `❌ 로드 실패: ${result.error}`);
                }

            } catch (error) {
                console.error('[API Keys] 로드 오류:', error);
                updateApiKeyStatus('openai', 'error', '❌ 로드 중 오류 발생');
                updateApiKeyStatus('google', 'error', '❌ 로드 중 오류 발생');
            }
        }

        // 🔑 OpenAI API 키 저장 (개선)
        async function saveOpenAIKey() {
            const apiKey = document.getElementById('openaiApiKey').value.trim();

            if (!currentUser || !authToken) {
                showStatus("로그인이 필요합니다", "warning");
                updateApiKeyStatus('openai', 'error', '❌ 로그인이 필요합니다');
                return;
            }

            if (!apiKey || apiKey === '••••••••••••••••••••') {
                showStatus("유효한 OpenAI API 키를 입력해주세요", "warning");
                updateApiKeyStatus('openai', 'error', '❌ API 키를 입력해주세요');
                return;
            }

            if (!apiKey.startsWith('sk-')) {
                showStatus("OpenAI API 키는 'sk-'로 시작해야 합니다", "warning");
                updateApiKeyStatus('openai', 'error', '❌ 올바른 형식이 아닙니다');
                return;
            }

            if (apiKey.length < 20) {
                showStatus("API 키가 너무 짧습니다", "warning");
                updateApiKeyStatus('openai', 'error', '❌ API 키가 너무 짧습니다');
                return;
            }

            updateApiKeyStatus('openai', 'info', '🔄 API 키 저장 중...');

            try {
                const response = await fetch(AUTH_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({
                        action: 'save-api-key',
                        provider: 'openai',
                        apiKey: apiKey,
                        keyName: 'OpenAI API Key'
                    })
                });

                if (!response.ok) {
                    throw new Error(`API 요청 실패: ${response.status}`);
                }

                const result = await response.json();

                if (result.success) {
                    console.log('[API Keys] OpenAI 키 저장 성공');

                    // UI 업데이트
                    document.getElementById('openaiApiKey').value = '••••••••••••••••••••';
                    document.getElementById('openaiApiKey').placeholder = 'API 키가 등록되어 있습니다';
                    updateApiKeyStatus('openai', 'success', '✅ OpenAI API 키가 저장되었습니다');
                    showStatus("🔑 OpenAI API 키 저장 완료", "success");

                    // 🔧 사용자 상태 업데이트
                    if (currentUser) {
                        currentUser.hasOpenAIKey = true;
                        localStorage.setItem('currentUser', JSON.stringify(currentUser));
                    }

                } else {
                    console.error('[API Keys] OpenAI 키 저장 실패:', result.error);
                    updateApiKeyStatus('openai', 'error', `❌ 저장 실패: ${result.error}`);
                    showStatus(`API 키 저장 실패: ${result.error}`, "error");
                }

            } catch (error) {
                console.error('[API Keys] OpenAI 키 저장 오류:', error);
                updateApiKeyStatus('openai', 'error', '❌ 저장 중 오류 발생');
                showStatus("API 키 저장 중 오류가 발생했습니다", "error");
            }
        }

        // 🔑 Google API 키 저장 (개선)
        async function saveGoogleKey() {
            const apiKey = document.getElementById('googleApiKey').value.trim();

            if (!currentUser || !authToken) {
                showStatus("로그인이 필요합니다", "warning");
                updateApiKeyStatus('google', 'error', '❌ 로그인이 필요합니다');
                return;
            }

            if (!apiKey || apiKey === '••••••••••••••••••••') {
                showStatus("유효한 Google API 키를 입력해주세요", "warning");
                updateApiKeyStatus('google', 'error', '❌ API 키를 입력해주세요');
                return;
            }

            if (!apiKey.startsWith('AIza')) {
                showStatus("Google API 키는 'AIza'로 시작해야 합니다", "warning");
                updateApiKeyStatus('google', 'error', '❌ 올바른 형식이 아닙니다');
                return;
            }

            if (apiKey.length < 20) {
                showStatus("API 키가 너무 짧습니다", "warning");
                updateApiKeyStatus('google', 'error', '❌ API 키가 너무 짧습니다');
                return;
            }

            updateApiKeyStatus('google', 'info', '🔄 API 키 저장 중...');

            try {
                const response = await fetch(AUTH_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({
                        action: 'save-api-key',
                        provider: 'google',
                        apiKey: apiKey,
                        keyName: 'Google API Key'
                    })
                });

                if (!response.ok) {
                    throw new Error(`API 요청 실패: ${response.status}`);
                }

                const result = await response.json();

                if (result.success) {
                    console.log('[API Keys] Google 키 저장 성공');

                    // UI 업데이트
                    document.getElementById('googleApiKey').value = '••••••••••••••••••••';
                    document.getElementById('googleApiKey').placeholder = 'API 키가 등록되어 있습니다';
                    updateApiKeyStatus('google', 'success', '✅ Google API 키가 저장되었습니다');
                    showStatus("🔑 Google API 키 저장 완료", "success");

                    // 🔧 사용자 상태 업데이트
                    if (currentUser) {
                        currentUser.hasGoogleKey = true;
                        localStorage.setItem('currentUser', JSON.stringify(currentUser));
                    }

                } else {
                    console.error('[API Keys] Google 키 저장 실패:', result.error);
                    updateApiKeyStatus('google', 'error', `❌ 저장 실패: ${result.error}`);
                    showStatus(`API 키 저장 실패: ${result.error}`, "error");
                }

            } catch (error) {
                console.error('[API Keys] Google 키 저장 오류:', error);
                updateApiKeyStatus('google', 'error', '❌ 저장 중 오류 발생');
                showStatus("API 키 저장 중 오류가 발생했습니다", "error");
            }
        }

        // 🔑 OpenAI API 키 테스트
        async function testOpenAIKey() {
            const apiKey = document.getElementById('openaiApiKey').value.trim();

            if (!apiKey || apiKey === '••••••••••••••••••••') {
                showStatus("테스트할 API 키를 입력해주세요", "warning");
                return;
            }

            updateApiKeyStatus('openai', 'info', '🔄 API 키 테스트 중...');

            try {
                // OpenAI API 간단한 테스트 요청
                const response = await fetch('https://api.openai.com/v1/models', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    updateApiKeyStatus('openai', 'success', '✅ OpenAI API 키가 유효합니다');
                    showStatus("🔑 OpenAI API 키 테스트 성공", "success");
                } else {
                    const errorText = await response.text();
                    updateApiKeyStatus('openai', 'error', `❌ 유효하지 않은 API 키: ${response.status}`);
                    showStatus(`API 키 테스트 실패: ${response.status}`, "error");
                }

            } catch (error) {
                console.error('[API Keys] OpenAI 키 테스트 오류:', error);
                updateApiKeyStatus('openai', 'error', '❌ 테스트 중 오류 발생');
                showStatus("API 키 테스트 중 오류가 발생했습니다", "error");
            }
        }

        // 🔑 Google API 키 테스트
        async function testGoogleKey() {
            const apiKey = document.getElementById('googleApiKey').value.trim();

            if (!apiKey || apiKey === '••••••••••••••••••••') {
                showStatus("테스트할 API 키를 입력해주세요", "warning");
                return;
            }

            updateApiKeyStatus('google', 'info', '🔄 API 키 테스트 중...');

            try {
                // Google TTS API 간단한 테스트 요청 (목소리 리스트 조회)
                const response = await fetch(`https://texttospeech.googleapis.com/v1/voices?key=${apiKey}`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    updateApiKeyStatus('google', 'success', '✅ Google API 키가 유효합니다');
                    showStatus("🔑 Google API 키 테스트 성공", "success");
                } else {
                    const errorText = await response.text();
                    updateApiKeyStatus('google', 'error', `❌ 유효하지 않은 API 키: ${response.status}`);
                    showStatus(`API 키 테스트 실패: ${response.status}`, "error");
                }

            } catch (error) {
                console.error('[API Keys] Google 키 테스트 오류:', error);
                updateApiKeyStatus('google', 'error', '❌ 테스트 중 오류 발생');
                showStatus("API 키 테스트 중 오류가 발생했습니다", "error");
            }
        }

        // 🔑 API 키 상태 업데이트
        function updateApiKeyStatus(provider, status, message) {
            const statusEl = document.getElementById(`${provider}KeyStatus`);
            if (!statusEl) return;

            statusEl.className = `api-key-status ${status}`;
            statusEl.textContent = message;
            statusEl.style.display = 'block';
        }

        // 🔑 인증된 API 요청에 토큰 추가
        function getAuthHeaders() {
            const headers = {
                'Content-Type': 'application/json'
            };

            if (authToken) {
                headers['Authorization'] = `Bearer ${authToken}`;
            }

            return headers;
        }

        // 🔑 API 키 입력 필드 이벤트 처리
        function setupApiKeyEvents() {
            // OpenAI 키 입력 시 상태 초기화
            const openaiInput = document.getElementById('openaiApiKey');
            if (openaiInput) {
                openaiInput.addEventListener('input', function () {
                    if (this.value && this.value !== '••••••••••••••••••••') {
                        updateApiKeyStatus('openai', '', '');
                    }
                });

                // 엔터키로 저장
                openaiInput.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') {
                        saveOpenAIKey();
                    }
                });
            }

            // Google 키 입력 시 상태 초기화
            const googleInput = document.getElementById('googleApiKey');
            if (googleInput) {
                googleInput.addEventListener('input', function () {
                    if (this.value && this.value !== '••••••••••••••••••••') {
                        updateApiKeyStatus('google', '', '');
                    }
                });

                // 엔터키로 저장
                googleInput.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') {
                        saveGoogleKey();
                    }
                });
            }
        }

        // AI 문맥 번역 설정
        let aiContextMode = false;
        let translationContext = [];
        let currentTranslationStyle = 'balanced';
        let qualityLevel = 3;
        let streamingMode = false; // 🚀 스트리밍 모드 상태

        // 🚀 스트리밍 모드 토글 함수
        function toggleStreamingMode() {
            const toggle = document.getElementById('streamingModeToggle');
            const status = document.getElementById('streamingModeStatus');
            streamingMode = toggle?.checked || false;

            if (status) {
                status.textContent = streamingMode ? '활성화 ⚡' : '비활성화';
                status.style.color = streamingMode ? 'var(--primary)' : 'var(--text-secondary)';
            }

            // 로컬 스토리지에 저장
            localStorage.setItem('streamingMode', streamingMode);
            console.log('[Streaming] 스트리밍 모드:', streamingMode ? 'ON' : 'OFF');
        }

        // 스트리밍 설정 로드
        function loadStreamingSettings() {
            const saved = localStorage.getItem('streamingMode');
            streamingMode = saved === 'true';
            const toggle = document.getElementById('streamingModeToggle');
            const status = document.getElementById('streamingModeStatus');

            if (toggle) toggle.checked = streamingMode;
            if (status) {
                status.textContent = streamingMode ? '활성화 ⚡' : '비활성화';
                status.style.color = streamingMode ? 'var(--primary)' : 'var(--text-secondary)';
            }
        }

        // 고급 단어장 시스템 - 초기화
        let vocabularyDict = new Map();
        let terminologyDict = new Map(); // 전문용어 사전 추가
        let currentVocabWord = null;
        let quizState = {
            active: false,
            words: [],
            currentIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            totalQuestions: 10,
            selectedAnswer: null
        }; // 🔧 수정: 닫는 괄호 추가

        let practiceState = {
            active: false,
            currentWord: null,
            isRecording: false,
            practiceTime: 0,
            lastRecording: null,
            recordingStartTime: null
        }; // 🔧 수정: 정의를 먼저 하고

        let vocabularyStats = {
            totalWords: 0,
            quizAccuracy: 0,
            practiceTime: 0,
            learningProgress: 0
        }; // 🔧 수정: 닫는 괄호 추가

        // 🔧 강제 비활성화 (정의 후에 실행)
        practiceState.active = false;
        quizState.active = false;

        // DOM 요소들
        // DOM 요소 캐싱 (성능 최적화)
        const els = {
            // 입력 및 결과 요소
            inputText: document.getElementById("inputText"),
            translation: document.getElementById("translation"),
            pronunciationContent: document.getElementById("pronunciation-content"),
            pronunciationSection: document.getElementById("pronunciationSection"),
            pronToggleIcon: document.getElementById("pronToggleIcon"),
            status: document.getElementById("status"),

            // 버튼 요소
            voiceBtn: document.getElementById("voiceBtn"),
            speakBtn: document.getElementById("speakBtn"),
            copyBtn: document.getElementById("copyBtn"),
            translateBtn: document.getElementById("translateBtn"),
            translateBtnText: document.getElementById("translateBtnText"),

            // 언어 선택
            sourceLangSelect: document.getElementById("sourceLangSelect"),
            targetLangSelect: document.getElementById("targetLangSelect"),
            voiceSelect: document.getElementById("voiceSelect"),
            googleVoiceSelect: document.getElementById("googleVoiceSelect"),
            autoDetectBadge: document.getElementById("autoDetectBadge"),

            // 패널 및 모드
            settingsPanel: document.getElementById("settingsPanel"),
            normalMode: document.getElementById("normalMode"),
            conversationMode: document.getElementById("conversationMode"),
            normalModeBtn: document.getElementById("normalModeBtn"),
            conversationModeBtn: document.getElementById("conversationModeBtn"),

            // 대화 모드 관련
            speakerCardA: document.getElementById("speakerCardA"),
            speakerCardB: document.getElementById("speakerCardB"),
            speakerLangA: document.getElementById("speakerLangA"),
            speakerLangB: document.getElementById("speakerLangB"),
            startConversationBtn: document.getElementById("startConversationBtn"),
            stopConversationBtn: document.getElementById("stopConversationBtn"),
            conversationHistory: document.getElementById("conversationHistory"),

            // TTS 및 재생
            ttsEngineMode: document.getElementById("ttsEngineMode"),
            cacheIndicator: document.getElementById("cacheIndicator"),
            engineIndicator: document.getElementById("engineIndicator"),
            recentPlays: document.getElementById("recentPlays"),
            recentPlayList: document.getElementById("recentPlayList"),

            // 모달
            dashboardModal: document.getElementById("dashboardModal"),
            historyModal: document.getElementById("historyModal"),
            historyList: document.getElementById("historyList"),

            // 대시보드
            todayTranslations: document.getElementById("todayTranslations"),
            totalTranslations: document.getElementById("totalTranslations"),
            cacheHitRate: document.getElementById("cacheHitRate"),

            // 설정
            autoModeSettings: document.getElementById("autoModeSettings"),
            autoThreshold: document.getElementById("autoThreshold"),
            thresholdValue: document.getElementById("thresholdValue"),
            volumeControl: document.getElementById("volumeControl"),
            volumeValue: document.getElementById("volumeValue"),
            pronunciationToggle: document.getElementById("pronunciationToggle"),

            // AI 기능
            aiToggle: document.getElementById("aiToggle"),
            aiContextBadge: document.getElementById("aiContextBadge"),
            aiIndicator: document.getElementById("aiIndicator"),
            qualitySlider: document.getElementById("qualitySlider"),
            aiSettingsSection: document.getElementById("aiSettingsSection"),

            // 단어장
            vocabularyOriginal: document.getElementById("vocabularyOriginal"),
            vocabularyTranslation: document.getElementById("vocabularyTranslation"),
            vocabularyDescription: document.getElementById("vocabularyDescription"),
            vocabularyList: document.getElementById("vocabularyList"),
            vocabularyStats: document.getElementById("vocabularyStats"),
            wordDetailModal: document.getElementById("wordDetailModal"),
            quizModal: document.getElementById("quizModal"),
            practiceModal: document.getElementById("practiceModal")
        };

        // 📊 개선: 실제 API 연동 사용량 추적기
        const usageTracker = {
            // 로컬 캐시 (성능 최적화용)
            localCache: {
                daily: {},
                monthly: {},
                lastRefresh: null
            },

            costs: {
                translation: 0.000015,
                openaiTTS: 0.000015,
                googleTTS: 0
            },

            // 🔧 초기화 - 실제 API에서 데이터 로드
            async initialize() {
                console.log('[UsageTracker] 초기화 시작');

                if (authToken) {
                    await this.refreshFromAPI();
                } else {
                    // 게스트 모드: 로컬 데이터 로드
                    this.loadLocalData();
                }

                this.updateDisplay();
            },

            // 🔧 API에서 데이터 새로고침
            async refreshFromAPI() {
                if (!authToken) {
                    console.log('[UsageTracker] 인증 토큰 없음 - 로컬 모드');
                    return;
                }

                try {
                    console.log('[UsageTracker] API에서 사용량 데이터 로드 중...');

                    const response = await fetch(AUTH_API_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${authToken}`
                        },
                        body: JSON.stringify({
                            action: 'get-dashboard-data'
                        })
                    });

                    if (response.ok) {
                        const result = await response.json();
                        if (result.success) {
                            this.updateLocalCacheFromAPI(result.dashboard);
                            console.log('[UsageTracker] API 데이터 로드 완료');
                        }
                    }

                } catch (error) {
                    console.error('[UsageTracker] API 데이터 로드 실패:', error);
                    // 실패 시 로컬 데이터 사용
                    this.loadLocalData();
                }

                this.localCache.lastRefresh = Date.now();
            },

            // 🔧 API 데이터로 로컬 캐시 업데이트
            updateLocalCacheFromAPI(dashboardData) {
                const today = new Date().toISOString().split('T')[0];
                const thisMonth = today.substring(0, 7);

                // 오늘 데이터
                this.localCache.daily[today] = {
                    translations: dashboardData.usage.today.translations || 0,
                    characters: dashboardData.usage.today.translations * 50, // 평균 추정
                    cost: dashboardData.usage.today.cost || 0,
                    saved: 0
                };

                // 이번 달 데이터
                this.localCache.monthly[thisMonth] = {
                    translations: dashboardData.usage.thisMonth.translations || 0,
                    characters: dashboardData.usage.thisMonth.translations * 50,
                    cost: dashboardData.usage.thisMonth.cost || 0,
                    saved: 0
                };

                // 주간 데이터 (차트용)
                this.localCache.weekly = dashboardData.usage.weekly || [];

                // 월별 데이터 (차트용)
                this.localCache.monthlyChart = dashboardData.monthlyData || [];
            },

            // 🔧 로컬 데이터 로드 (게스트 모드)
            loadLocalData() {
                try {
                    const saved = localStorage.getItem('usageData');
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.localCache.daily = data.daily || {};
                        this.localCache.monthly = data.monthly || {};
                    }
                } catch (error) {
                    console.error('[UsageTracker] 로컬 데이터 로드 실패:', error);
                }
            },

            // 🔧 사용량 추적 - API 전송 + 로컬 업데이트
            async track(type, count, provider = 'openai') {
                const today = new Date().toISOString().split('T')[0];
                const thisMonth = today.substring(0, 7);

                // 로컬 캐시 업데이트
                if (!this.localCache.daily[today]) {
                    this.localCache.daily[today] = { translations: 0, characters: 0, cost: 0, saved: 0 };
                }
                if (!this.localCache.monthly[thisMonth]) {
                    this.localCache.monthly[thisMonth] = { translations: 0, characters: 0, cost: 0, saved: 0 };
                }

                const dailyData = this.localCache.daily[today];
                const monthlyData = this.localCache.monthly[thisMonth];

                if (type === 'translation') {
                    dailyData.translations++;
                    monthlyData.translations++;
                    dailyData.characters += count;
                    monthlyData.characters += count;
                    const cost = count * this.costs.translation;
                    dailyData.cost += cost;
                    monthlyData.cost += cost;
                } else if (type === 'tts') {
                    const cost = provider === 'openai' ? count * this.costs.openaiTTS : 0;
                    const saved = provider === 'google' ? count * this.costs.openaiTTS : 0;

                    dailyData.cost += cost;
                    monthlyData.cost += cost;
                    dailyData.saved += saved;
                    monthlyData.saved += saved;
                }

                // 로컬 저장 (게스트 모드용)
                this.saveLocalData();

                // UI 업데이트
                this.updateDisplay();
                this.checkLimits();

                // 🔧 API에 사용량 전송 (인증된 사용자만)
                if (authToken && currentUser) {
                    try {
                        // 실제 trackUsage는 translate.js에서 호출되므로 여기서는 로그만
                        console.log(`[UsageTracker] ${type} 사용량 추적: ${count} (${provider})`);
                    } catch (error) {
                        console.error('[UsageTracker] API 전송 실패:', error);
                    }
                }
            },

            // 로컬 데이터 저장
            saveLocalData() {
                try {
                    const data = {
                        daily: this.localCache.daily,
                        monthly: this.localCache.monthly,
                        lastSaved: new Date().toISOString()
                    };
                    localStorage.setItem('usageData', JSON.stringify(data));
                } catch (error) {
                    console.error('[UsageTracker] 로컬 데이터 저장 실패:', error);
                }
            },

            // 🔧 개선: 실제 데이터로 디스플레이 업데이트
            updateDisplay() {
                const today = new Date().toISOString().split('T')[0];
                const thisMonth = today.substring(0, 7);

                const todayData = this.localCache.daily[today] || { translations: 0, cost: 0, saved: 0 };
                const monthData = this.localCache.monthly[thisMonth] || { translations: 0, cost: 0, saved: 0 };

                // 대시보드 카드 업데이트
                const todayUsageEl = document.getElementById('todayUsage');
                const monthUsageEl = document.getElementById('monthUsage');
                const todayCostEl = document.getElementById('todayCost');
                const monthCostEl = document.getElementById('monthCost');
                const savedCostEl = document.getElementById('savedCost');

                if (todayUsageEl) todayUsageEl.textContent = todayData.translations;
                if (monthUsageEl) monthUsageEl.textContent = monthData.translations;
                if (todayCostEl) todayCostEl.textContent = `$${todayData.cost.toFixed(4)}`;
                if (monthCostEl) monthCostEl.textContent = `$${monthData.cost.toFixed(4)}`;
                if (savedCostEl) savedCostEl.textContent = `$${monthData.saved.toFixed(4)}`;

                this.updateChart();
                this.updateMonthlyChart();
                this.updateBudgetProgress();
            },

            // 🔧 주간 차트 업데이트 (실제 데이터)
            updateChart() {
                const chartEl = document.getElementById('weeklyChart');
                if (!chartEl) return;

                // 실제 API 데이터가 있으면 사용, 없으면 로컬 데이터
                const weeklyData = this.localCache.weekly || this.generateLocalWeeklyData();

                if (weeklyData.length === 0) return;

                const maxCount = Math.max(...weeklyData.map(d => d.translation_count || 0), 1);

                chartEl.innerHTML = weeklyData.map(dayData => {
                    const count = dayData.translation_count || 0;
                    const height = (count / maxCount) * 100;
                    const date = new Date(dayData.date);
                    const dayLabel = date.toLocaleDateString('ko-KR', { weekday: 'short' });

                    return `<div class="bar" style="height: ${height}%">
                <span class="bar-value">${count}</span>
                <span class="bar-label">${dayLabel}</span>
            </div>`;
                }).join('');
            },

            // 로컬 데이터로 주간 차트 생성
            generateLocalWeeklyData() {
                const weekData = [];
                for (let i = 6; i >= 0; i--) {
                    const date = new Date();
                    date.setDate(date.getDate() - i);
                    const dateStr = date.toISOString().split('T')[0];
                    const dayData = this.localCache.daily[dateStr] || { translations: 0 };

                    weekData.push({
                        date: dateStr,
                        translation_count: dayData.translations
                    });
                }
                return weekData;
            },

            // 🔧 월별 차트 업데이트 (실제 데이터)
            updateMonthlyChart() {
                const chartEl = document.getElementById('monthlyChart');
                if (!chartEl) return;

                // 실제 API 데이터가 있으면 사용, 없으면 로컬 데이터
                const monthlyData = this.localCache.monthlyChart || this.generateLocalMonthlyData();

                if (monthlyData.length === 0) return;

                const maxCost = Math.max(...monthlyData.map(m => m.cost || 0), 0.01);

                chartEl.innerHTML = monthlyData.map(monthData => {
                    const cost = monthData.cost || 0;
                    const height = maxCost > 0 ? (cost / maxCost * 100) : 0;
                    const monthLabel = monthData.monthLabel ||
                        new Date(monthData.month + '-01').toLocaleDateString('ko-KR', { month: 'short' });

                    return `<div class="bar" style="height: ${height}%; background: linear-gradient(135deg, #10A37F, #059669);">
                <span class="bar-value">${cost.toFixed(3)}</span>
                <span class="bar-label">${monthLabel}</span>
            </div>`;
                }).join('');
            },

            // 로컬 데이터로 월별 차트 생성
            generateLocalMonthlyData() {
                const monthData = [];
                const currentDate = new Date();

                for (let i = 5; i >= 0; i--) {
                    const date = new Date(currentDate.getFullYear(), currentDate.getMonth() - i, 1);
                    const monthStr = date.toISOString().substring(0, 7);
                    const data = this.localCache.monthly[monthStr] || { cost: 0 };

                    monthData.push({
                        month: monthStr,
                        cost: data.cost,
                        monthLabel: date.toLocaleDateString('ko-KR', { month: 'short' })
                    });
                }
                return monthData;
            },

            updateBudgetProgress() {
                const today = new Date().toISOString().split('T')[0];
                const todayCost = this.localCache.daily[today]?.cost || 0;
                const dailyBudget = parseFloat(document.getElementById('dailyBudget')?.value) || 1.00;
                const percentage = Math.min((todayCost / dailyBudget) * 100, 100);

                const progressEl = document.getElementById('budgetProgress');
                const percentageEl = document.getElementById('budgetPercentage');

                if (progressEl) progressEl.style.width = `${percentage}%`;
                if (percentageEl) percentageEl.textContent = `${percentage.toFixed(1)}% 사용`;

                this.checkLimits();
            },

            checkLimits() {
                const today = new Date().toISOString().split('T')[0];
                const todayCost = this.localCache.daily[today]?.cost || 0;
                const dailyBudget = parseFloat(document.getElementById('dailyBudget')?.value) || 1.00;

                if (todayCost >= dailyBudget) {
                    const limitAction = document.getElementById('limitAction')?.value;
                    if (limitAction === 'switch') {
                        els.ttsEngineMode.value = 'google';
                        showStatus("⚠️ 예산 도달 - Google TTS로 전환", "warning");
                    } else if (limitAction === 'warn') {
                        showStatus("⚠️ 일일 예산을 초과했습니다", "warning");
                    } else if (limitAction === 'block') {
                        window.budgetExceeded = true;
                        showStatus("⛔ 예산 초과 - 유료 기능 제한", "error");
                    }
                } else {
                    window.budgetExceeded = false;
                }
            }
        };

        // 캐시 관리자
        const cacheManager = { translation: new Map, tts: new Map, recentPlays: [], stats: { hits: 0, misses: 0 }, getTranslation(e) { const t = this.translation.get(e); return t && Date.now() - t.ts < 36e5 ? (this.stats.hits++, t.data) : (this.stats.misses++, null) }, setTranslation(e, t) { this.translation.set(e, { ts: Date.now(), data: t }), this.translation.size > 100 && this.translation.delete(this.translation.keys().next().value) }, getTTS(e) { const t = this.tts.get(e); return t && Date.now() - t.ts < 72e5 ? t.blob : null }, setTTS(e, t) { this.tts.set(e, { ts: Date.now(), blob: t }), this.tts.size > 50 && this.tts.delete(this.tts.keys().next().value) }, addRecentPlay(e, t, s, a) { this.recentPlays.unshift({ text: e, translation: t, lang: s, engine: a }), this.recentPlays.length > 10 && this.recentPlays.pop(), this.save(), updateRecentPlays() }, save() { localStorage.setItem("cacheData", JSON.stringify({ recentPlays: this.recentPlays, stats: this.stats })) }, load() { const e = localStorage.getItem("cacheData"); if (e) { const { recentPlays: t, stats: a } = JSON.parse(e); this.recentPlays = t || [], this.stats = a || { hits: 0, misses: 0 } } }, clear() { this.translation.clear(), this.tts.clear(), this.recentPlays = [], this.stats = { hits: 0, misses: 0 }, this.save() } };

        let currentTranslation = "", currentSource = "", recognition = null, isRecording = !1, isPronunciationEnabled = !0;
        // ✅ 단어장 전용 음성인식 객체 (충돌 방지)
        let practiceRecognition = null;
        const conversationState = { isActive: !1, currentSpeaker: "A", messages: [], autoRecognition: !1 }, langCodeMap = { Korean: "ko-KR", Vietnamese: "vi-VN", English: "en-US" };
        let audioContext = null; const audioQueue = []; let isQueuePlaying = !1;

        // ✅ 전문용어 관리 함수들 (간소화된 UI)
        function addTerminology() {
            const input = document.getElementById('terminologyInput').value.trim();

            if (!input) {
                showStatus("용어를 입력해주세요 (예: AI | 인공지능)", "warning");
                return;
            }

            // 파이프(|)로 분리
            const parts = input.split('|').map(part => part.trim());

            if (parts.length !== 2) {
                showStatus("올바른 형식으로 입력하세요: 원어 | 번역어", "warning");
                return;
            }

            const [original, translation] = parts;

            if (!original || !translation) {
                showStatus("원어와 번역어를 모두 입력해주세요", "warning");
                return;
            }

            if (terminologyDict.has(original)) {
                showStatus("이미 등록된 용어입니다", "warning");
                return;
            }

            terminologyDict.set(original, translation);

            // 입력 필드 초기화
            document.getElementById('terminologyInput').value = '';

            updateTerminologyList();
            saveAISettings();
            showStatus(`🔧 용어 추가: ${original} → ${translation}`, "success");
        }

        function removeTerminology(original) {
            if (confirm(`"${original}" 용어를 삭제하시겠습니까?`)) {
                terminologyDict.delete(original);
                updateTerminologyList();
                saveAISettings();
                showStatus(`🗑️ 용어 삭제: ${original}`, "success");
            }
        }

        function updateTerminologyList() {
            const terminologyListEl = document.getElementById('terminologyList');
            if (!terminologyListEl) return;

            if (terminologyDict.size === 0) {
                terminologyListEl.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 10px; font-size: 12px;">등록된 전문용어가 없습니다</div>';
                return;
            }

            terminologyListEl.innerHTML = Array.from(terminologyDict.entries()).map(([original, translation]) =>
                `<div class="terminology-item">
            <div class="terminology-text">
                <span class="terminology-original">${original}</span>
                <span class="terminology-arrow">→</span>
                <span class="terminology-translated">${translation}</span>
            </div>
            <button class="terminology-remove" onclick="removeTerminology('${original.replace(/'/g, "\\'")}')">삭제</button>
        </div>`
            ).join('');
        }

        function addVocabulary() {
            const original = els.vocabularyOriginal.value.trim();
            const translation = els.vocabularyTranslation.value.trim();
            const description = els.vocabularyDescription.value.trim();

            if (!original || !translation) {
                showStatus("원어와 번역어를 모두 입력해주세요", "warning");
                return;
            }

            if (vocabularyDict.has(original)) {
                showStatus("이미 등록된 단어입니다", "warning");
                return;
            }

            const wordData = {
                original: original,
                translation: translation,
                description: description || "설명 없음",
                addedDate: new Date().toISOString(),
                correctCount: 0,
                wrongCount: 0,
                practiceTime: 0,
                lastStudied: null
            };

            vocabularyDict.set(original, wordData);

            // 입력 필드 초기화
            els.vocabularyOriginal.value = '';
            els.vocabularyTranslation.value = '';
            els.vocabularyDescription.value = '';

            updateVocabularyList();
            updateVocabularyStats();
            saveVocabularyData();
            showStatus(`📚 단어 추가: ${original} → ${translation}`, "success");
        }

        function showWordDetail(original) {
            const word = vocabularyDict.get(original);
            if (!word) {
                showStatus("단어를 찾을 수 없습니다", "error");
                return;
            }

            // currentVocabWord 설정 (중요!)
            currentVocabWord = word;

            // DOM 요소 존재 확인
            const wordDetailOriginalEl = document.getElementById('wordDetailOriginal');
            const wordDetailTranslationEl = document.getElementById('wordDetailTranslation');
            const wordDetailPronunciationEl = document.getElementById('wordDetailPronunciation');
            const wordDetailDescriptionEl = document.getElementById('wordDetailDescription');
            const wordDetailModal = document.getElementById('wordDetailModal');

            if (!wordDetailOriginalEl || !wordDetailTranslationEl || !wordDetailPronunciationEl || !wordDetailDescriptionEl || !wordDetailModal) {
                showStatus("단어 상세 UI 요소를 찾을 수 없습니다", "error");
                return;
            }

            wordDetailOriginalEl.textContent = word.original;
            wordDetailTranslationEl.textContent = word.translation;
            wordDetailPronunciationEl.textContent = `[${generatePronunciation(word.original)}]`;
            wordDetailDescriptionEl.textContent = word.description;

            wordDetailModal.classList.add('active');
        }

        function closeWordDetail() {
            els.wordDetailModal.classList.remove('active');
            currentVocabWord = null;
        }

        async function speakCurrentWord() {
            if (!currentVocabWord) return;

            // 단어장 전용 TTS 함수
            await speakVocabularyWord(currentVocabWord.original, currentVocabWord.translation);
        }

        function removeVocabulary(original) {
            if (confirm(`"${original}" 단어를 삭제하시겠습니까?`)) {
                vocabularyDict.delete(original);
                updateVocabularyList();
                updateVocabularyStats();
                saveVocabularyData();
                showStatus(`🗑️ 단어 삭제: ${original}`, "success");
            }
        }

        function startQuiz(difficulty = 'normal') {
            const words = Array.from(vocabularyDict.values());
            if (words.length < 3) {
                showStatus("퀴즈를 위해서는 최소 3개의 단어가 필요합니다", "warning");
                return;
            }

            let quizWords = words;
            if (difficulty === 'difficult') {
                // 정답률이 낮은 단어들을 우선적으로 선택
                quizWords = words.filter(word => {
                    const total = word.correctCount + word.wrongCount;
                    const accuracy = total > 0 ? word.correctCount / total : 0;
                    return accuracy < 0.7; // 정답률 70% 미만
                });

                if (quizWords.length < 3) {
                    quizWords = words; // 어려운 단어가 부족하면 전체에서 선택
                }
            }

            // 랜덤으로 섞기
            quizWords = shuffleArray([...quizWords]);

            quizState = {
                active: true,
                words: quizWords.slice(0, Math.min(10, quizWords.length)),
                currentIndex: 0,
                correctAnswers: 0,
                wrongAnswers: 0,
                totalQuestions: Math.min(10, quizWords.length),
                selectedAnswer: null
            };

            updateQuizDisplay();
            els.quizModal.classList.add('active');
        }

        function startSingleWordQuiz(wordKey = null) {
            const allWords = Array.from(vocabularyDict.values());
            if (allWords.length < 3) {
                showStatus("퀴즈를 위해서는 최소 3개의 단어가 필요합니다", "warning");
                return;
            }

            let targetWord;
            if (wordKey && vocabularyDict.has(wordKey)) {
                targetWord = vocabularyDict.get(wordKey);
            } else if (currentVocabWord) {
                targetWord = currentVocabWord;
            } else {
                showStatus("퀴즈할 단어를 찾을 수 없습니다", "error");
                return;
            }

            quizState = {
                active: true,
                words: [targetWord],
                currentIndex: 0,
                correctAnswers: 0,
                wrongAnswers: 0,
                totalQuestions: 1,
                selectedAnswer: null
            };

            closeWordDetail();
            updateQuizDisplay();
            els.quizModal.classList.add('active');
        }

        function selectQuizOption(optionIndex) {
            if (quizState.selectedAnswer !== null) return; // 이미 선택됨

            quizState.selectedAnswer = optionIndex;

            const options = document.querySelectorAll('.quiz-option');
            const currentWord = quizState.words[quizState.currentIndex];
            const correctIndex = parseInt(options[0].dataset.correct || '0');

            options.forEach((option, index) => {
                option.classList.remove('selected');
                if (index === optionIndex) {
                    option.classList.add('selected');
                }
                if (index === correctIndex) {
                    option.classList.add('correct');
                } else if (index === optionIndex) {
                    option.classList.add('wrong');
                }
            });

            // 정답 체크
            if (optionIndex === correctIndex) {
                quizState.correctAnswers++;
                currentWord.correctCount++;
                showStatus("✅ 정답!", "success");
            } else {
                quizState.wrongAnswers++;
                currentWord.wrongCount++;
                showStatus("❌ 오답!", "error");
            }

            currentWord.lastStudied = new Date().toISOString();

            document.getElementById('quizNextBtn').disabled = false;
            updateQuizStats();
        }

        function nextQuestion() {
            quizState.currentIndex++;
            quizState.selectedAnswer = null;

            if (quizState.currentIndex >= quizState.totalQuestions) {
                showQuizResult();
            } else {
                updateQuizDisplay();
            }

            document.getElementById('quizNextBtn').disabled = true;
        }

        function closeQuiz() {
            els.quizModal.classList.remove('active');
            quizState.active = false;
            saveVocabularyData();
            updateVocabularyStats();
        }

        function startPronunciationPractice() {
            console.log('startPronunciationPractice 시작');
            console.log('currentVocabWord:', currentVocabWord);

            if (!currentVocabWord) {
                showStatus("선택된 단어가 없습니다", "warning");
                return;
            }

            // 단어 상세 모달만 닫기 (단어장은 유지)
            closeWordDetail();

            practiceState = {
                active: true,
                currentWord: currentVocabWord,
                isRecording: false,
                practiceTime: Date.now(),
                lastRecording: null,
                recordingStartTime: null
            };

            // DOM 요소 존재 확인 후 업데이트
            const practiceWordEl = document.getElementById('practiceWord');
            const practicePronunciationEl = document.getElementById('practicePronunciation');
            const practiceTipsEl = document.getElementById('practiceTips');
            const practiceFeedbackEl = document.getElementById('practiceFeedback');
            const recordBtn = document.getElementById('recordBtn');

            console.log('DOM 요소 확인:');
            console.log('practiceWord:', practiceWordEl);
            console.log('practicePronunciation:', practicePronunciationEl);
            console.log('practiceTips:', practiceTipsEl);
            console.log('recordBtn:', recordBtn);

            if (!practiceWordEl || !practicePronunciationEl || !practiceTipsEl || !recordBtn) {
                showStatus("발음 연습 UI 요소를 찾을 수 없습니다", "error");
                return;
            }

            practiceWordEl.textContent = practiceState.currentWord.original;
            practicePronunciationEl.textContent = `[${generatePronunciation(practiceState.currentWord.original)}]`;
            practiceTipsEl.textContent = generatePronunciationTips(practiceState.currentWord.original);

            if (practiceFeedbackEl) {
                practiceFeedbackEl.style.display = 'none';
            }

            recordBtn.classList.remove('recording');
            recordBtn.textContent = '🎤';

            // 모달 표시 - 강제 스타일 적용
            const practiceModal = document.getElementById('practiceModal');
            if (practiceModal) {
                practiceModal.style.cssText = 'display: flex !important; visibility: visible !important; opacity: 1 !important; position: fixed !important; top: 0 !important; left: 0 !important; right: 0 !important; bottom: 0 !important; z-index: 3000 !important; padding: 20px !important; align-items: center !important; justify-content: center !important;';
                practiceModal.classList.add('active');
            } else {
                showStatus("발음 연습 모달을 찾을 수 없습니다", "error");
            }
        }

        function startWordPractice(wordKey = null) {
            const words = Array.from(vocabularyDict.values());
            if (words.length === 0) {
                showStatus("연습할 단어가 없습니다", "warning");
                return;
            }

            let selectedWord;
            if (wordKey && vocabularyDict.has(wordKey)) {
                selectedWord = vocabularyDict.get(wordKey);
            } else {
                selectedWord = words[Math.floor(Math.random() * words.length)];
            }

            // currentVocabWord 설정
            currentVocabWord = selectedWord;

            practiceState = {
                active: true,
                currentWord: selectedWord,
                isRecording: false,
                practiceTime: Date.now(),
                lastRecording: null,
                recordingStartTime: null
            };

            // DOM 요소 존재 확인 후 업데이트
            const practiceWordEl = document.getElementById('practiceWord');
            const practicePronunciationEl = document.getElementById('practicePronunciation');
            const practiceTipsEl = document.getElementById('practiceTips');
            const practiceFeedbackEl = document.getElementById('practiceFeedback');
            const recordBtn = document.getElementById('recordBtn');

            if (!practiceWordEl || !practicePronunciationEl || !practiceTipsEl || !recordBtn) {
                showStatus("발음 연습 UI 요소를 찾을 수 없습니다", "error");
                return;
            }

            practiceWordEl.textContent = selectedWord.original;
            practicePronunciationEl.textContent = `[${generatePronunciation(selectedWord.original)}]`;
            practiceTipsEl.textContent = generatePronunciationTips(selectedWord.original);

            if (practiceFeedbackEl) {
                practiceFeedbackEl.style.display = 'none';
            }

            recordBtn.classList.remove('recording');
            recordBtn.textContent = '🎤';

            // 모달 표시 - 단어장은 유지
            const practiceModal = document.getElementById('practiceModal');
            if (practiceModal) {
                practiceModal.style.cssText = 'display: flex !important; visibility: visible !important; opacity: 1 !important; position: fixed !important; top: 0 !important; left: 0 !important; right: 0 !important; bottom: 0 !important; z-index: 3000 !important; padding: 20px !important; align-items: center !important; justify-content: center !important;';
                practiceModal.classList.add('active');
            } else {
                showStatus("발음 연습 모달을 찾을 수 없습니다", "error");
            }
        }

        // ✅ 단어장 전용 TTS 함수 추가
        async function speakVocabularyWord(word, translation = null) {
            try {
                // 언어 자동 감지 - 간단한 방식
                let language = 'English'; // 기본값
                let useGoogleTTS = true;

                if (/[가-힣]/.test(word)) {
                    language = 'Korean';
                } else if (/[àáạảãâầấậẩẫăằắặẳẵèéẹẻẽêềếệểễìíịỉĩòóọỏõôồốộổỗơờớợởỡùúụủũưừứựửữỳýỵỷỹđĐ]/.test(word)) {
                    language = 'Vietnamese';
                }

                // TTS 엔진 선택
                const engineMode = els.ttsEngineMode.value;
                if (engineMode === 'openai') {
                    useGoogleTTS = false;
                } else if (engineMode === 'google') {
                    useGoogleTTS = true;
                } else {
                    // auto 모드: 짧은 단어는 Google, 긴 단어는 OpenAI
                    useGoogleTTS = word.length < 50;
                }

                const voiceName = useGoogleTTS ? els.googleVoiceSelect.value : els.voiceSelect.value;
                const cacheKey = `vocab:${word}:${language}:${useGoogleTTS}:${voiceName}`;

                // 캐시 확인
                const cachedAudio = cacheManager.getTTS(cacheKey);
                if (cachedAudio) {
                    queueAudioBlob(cachedAudio);
                    showStatus("🔊 단어 재생 (캐시)", "success");
                    return;
                }

                showStatus("🔊 단어 음성 생성 중...", "info");

                const response = await fetch(API_URL, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        action: "speak",
                        inputText: word,
                        language: language,
                        useGoogleTTS: useGoogleTTS,
                        voice: voiceName,
                        voiceName: voiceName
                    })
                });

                if (!response.ok) {
                    throw new Error(`TTS API 오류: ${response.statusText}`);
                }

                const audioBlob = await response.blob();
                cacheManager.setTTS(cacheKey, audioBlob);
                queueAudioBlob(audioBlob);

                showStatus(`🔊 ${word} 재생 완료`, "success");

            } catch (error) {
                console.error('단어 TTS 오류:', error);
                showStatus(`음성 재생 실패: ${error.message}`, "error");
            }
        }

        // ✅ 발음 연습 전용 TTS 함수
        async function listenPracticeWord() {
            if (!practiceState.currentWord) return;

            await speakVocabularyWord(practiceState.currentWord.original);
        }

        // ✅ 단어장 전용 음성인식 설정 (충돌 방지)
        function setupPracticeRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                console.error('음성 인식을 지원하지 않는 브라우저입니다');
                return false;
            }

            practiceRecognition = new SpeechRecognition();
            practiceRecognition.continuous = false;
            practiceRecognition.interimResults = true;

            return true;
        }

        // ✅ 마이크/녹음 기능 완전 수정
        function toggleRecording() {
            if (!practiceState.currentWord) return;

            const recordBtn = document.getElementById('recordBtn');

            if (practiceState.isRecording) {
                // 녹음 중지
                stopPracticeRecording();
            } else {
                // 녹음 시작
                startPracticeRecording();
            }
        }

        function startPracticeRecording() {
            if (!practiceRecognition && !setupPracticeRecognition()) {
                showStatus("음성 인식을 지원하지 않는 브라우저입니다", "error");
                return;
            }

            // 언어 설정
            const word = practiceState.currentWord.original;
            let langCode = 'en-US'; // 기본값

            if (/[가-힣]/.test(word)) {
                langCode = 'ko-KR';
            } else if (/[àáạảãâầấậẩẫăằắặẳẵèéẹẻẽêềếệểễìíịỉĩòóọỏõôồốộổỗơờớợởỡùúụủũưừứựửữỳýỵỷỹđĐ]/.test(word)) {
                langCode = 'vi-VN';
            }

            try {
                practiceState.isRecording = true;
                practiceState.recordingStartTime = Date.now();

                const recordBtn = document.getElementById('recordBtn');
                recordBtn.classList.add('recording');
                recordBtn.textContent = '⏹️';

                practiceRecognition.lang = langCode;

                // 단어장 전용 이벤트 핸들러
                practiceRecognition.onresult = function (event) {
                    let transcript = '';
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        if (event.results[i].isFinal) {
                            transcript += event.results[i][0].transcript;
                        }
                    }

                    if (transcript.trim()) {
                        practiceState.lastRecording = transcript.trim();
                    }
                };

                practiceRecognition.onend = function () {
                    stopPracticeRecording();
                };

                practiceRecognition.onerror = function (event) {
                    console.error('단어장 음성 인식 오류:', event.error);
                    showStatus(`음성 인식 오류: ${event.error}`, "error");
                    stopPracticeRecording();
                };

                practiceRecognition.start();
                showStatus("🎤 발음을 시작하세요...", "info");

            } catch (error) {
                console.error('단어장 녹음 시작 오류:', error);
                showStatus("녹음 시작에 실패했습니다", "error");
                stopPracticeRecording();
            }
        }

        function stopPracticeRecording() {
            practiceState.isRecording = false;

            const recordBtn = document.getElementById('recordBtn');
            recordBtn.classList.remove('recording');
            recordBtn.textContent = '🎤';

            // ✅ 단어장 전용 recognition 중단
            if (practiceRecognition && practiceRecognition.abort) {
                practiceRecognition.abort();
            }

            // 녹음 시간 계산
            if (practiceState.recordingStartTime) {
                const recordingTime = Math.floor((Date.now() - practiceState.recordingStartTime) / 1000);
                practiceState.currentWord.practiceTime += recordingTime;
            }

            // 피드백 표시
            const feedback = document.getElementById('practiceFeedback');
            const feedbackText = document.getElementById('practiceFeedbackText');

            if (practiceState.lastRecording) {
                const originalWord = practiceState.currentWord.original.toLowerCase();
                const recordedWord = practiceState.lastRecording.toLowerCase();

                // 간단한 유사도 검사
                const similarity = calculateSimilarity(originalWord, recordedWord);
                let feedbackMessage = '';

                if (similarity > 0.8) {
                    feedbackMessage = `✅ 훌륭합니다! "${practiceState.lastRecording}"로 정확하게 발음했습니다.`;
                } else if (similarity > 0.6) {
                    feedbackMessage = `👍 좋습니다! "${practiceState.lastRecording}"로 들렸습니다. 조금 더 명확하게 발음해보세요.`;
                } else if (similarity > 0.3) {
                    feedbackMessage = `📝 "${practiceState.lastRecording}"로 들렸습니다. 정확한 발음은 "${practiceState.currentWord.original}"입니다. 다시 시도해보세요.`;
                } else {
                    feedbackMessage = `🔄 명확하게 들리지 않았습니다. 천천히 또박또박 발음해보세요.`;
                }

                feedbackText.textContent = feedbackMessage;
                feedback.style.display = 'block';

                // 통계 업데이트
                if (similarity > 0.7) {
                    practiceState.currentWord.correctCount++;
                } else {
                    practiceState.currentWord.wrongCount++;
                }

            } else {
                feedbackText.textContent = "음성이 인식되지 않았습니다. 마이크 권한을 확인하고 다시 시도해주세요.";
                feedback.style.display = 'block';
            }

            practiceState.lastRecording = null;
            practiceState.recordingStartTime = null;

            // 데이터 저장
            saveVocabularyData();
        }

        // 텍스트 유사도 계산 함수
        function calculateSimilarity(str1, str2) {
            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;

            if (longer.length === 0) return 1.0;

            const distance = levenshteinDistance(longer, shorter);
            return (longer.length - distance) / longer.length;
        }

        // 레벤슈타인 거리 계산
        function levenshteinDistance(str1, str2) {
            const matrix = [];

            for (let i = 0; i <= str2.length; i++) {
                matrix[i] = [i];
            }

            for (let j = 0; j <= str1.length; j++) {
                matrix[0][j] = j;
            }

            for (let i = 1; i <= str2.length; i++) {
                for (let j = 1; j <= str1.length; j++) {
                    if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }

            return matrix[str2.length][str1.length];
        }

        function nextPracticeWord() {
            const words = Array.from(vocabularyDict.values());
            if (words.length === 0) return;

            const randomWord = words[Math.floor(Math.random() * words.length)];
            practiceState.currentWord = randomWord;
            practiceState.isRecording = false;
            practiceState.practiceTime = Date.now();
            practiceState.lastRecording = null;
            practiceState.recordingStartTime = null;

            document.getElementById('practiceWord').textContent = randomWord.original;
            document.getElementById('practicePronunciation').textContent = `[${generatePronunciation(randomWord.original)}]`;
            document.getElementById('practiceTips').textContent = generatePronunciationTips(randomWord.original);
            document.getElementById('practiceFeedback').style.display = 'none';

            const recordBtn = document.getElementById('recordBtn');
            recordBtn.classList.remove('recording');
            recordBtn.textContent = '🎤';
        }

        function closePractice() {
            // 녹음 중이면 중지
            if (practiceState.isRecording) {
                stopPracticeRecording();
            }

            // 음성인식 정리
            if (practiceRecognition) {
                try {
                    practiceRecognition.abort();
                } catch (e) {
                    console.log('practiceRecognition 중단 중 오류:', e);
                }
                practiceRecognition = null;
            }

            // 모달 완전 숨김
            const practiceModal = document.getElementById('practiceModal');
            practiceModal.classList.remove('active');
            practiceModal.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important;';

            practiceState = {
                active: false,
                currentWord: null,
                isRecording: false,
                practiceTime: 0,
                lastRecording: null,
                recordingStartTime: null
            };

            saveVocabularyData();
            updateVocabularyStats();
        }

        // ✅ 보조 함수들
        function switchVocabTab(tabName) {
            // 탭 활성화
            document.querySelectorAll('.vocab-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');

            // 컨텐츠 표시
            document.querySelectorAll('.vocab-content').forEach(content => {
                content.style.display = 'none';
            });

            const targetContent = document.getElementById(`vocab${tabName.charAt(0).toUpperCase() + tabName.slice(1)}`);
            if (targetContent) {
                targetContent.style.display = 'block';
            }

            // 목록 탭일 때 업데이트
            if (tabName === 'list') {
                updateVocabularyList();
            } else if (tabName === 'stats') {
                updateVocabularyStats();
            }
        }

        function updateVocabularyList() {
            if (!els.vocabularyList) return;

            const words = Array.from(vocabularyDict.values());

            if (words.length === 0) {
                els.vocabularyList.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">등록된 단어가 없습니다</div>';
                return;
            }

            els.vocabularyList.innerHTML = words.map(word => {
                const accuracy = word.correctCount + word.wrongCount > 0
                    ? Math.round(word.correctCount / (word.correctCount + word.wrongCount) * 100)
                    : 0;

                return `
            <div class="vocabulary-item" onclick="showWordDetail('${word.original.replace(/'/g, "\\'")}')">
                <div class="vocabulary-word">
                    <div class="vocabulary-word-main">${word.original}</div>
                    <div class="vocabulary-word-sub">${word.translation} (정답률: ${accuracy}%)</div>
                </div>
                <div class="vocabulary-actions">
                    <button class="vocabulary-btn listen" onclick="event.stopPropagation(); speakVocabularyWord('${word.original.replace(/'/g, "\\'")}');" title="듣기">🔊</button>
                    <button class="vocabulary-btn practice" onclick="event.stopPropagation(); startWordPractice('${word.original.replace(/'/g, "\\'")}');" title="연습">🎤</button>
                    <button class="vocabulary-btn remove" onclick="event.stopPropagation(); removeVocabulary('${word.original.replace(/'/g, "\\'")}');" title="삭제">🗑️</button>
                </div>
            </div>
        `;
            }).join('');
        }

        function updateVocabularyStats() {
            const words = Array.from(vocabularyDict.values());
            const totalWords = words.length;

            let totalCorrect = 0;
            let totalAnswered = 0;
            let totalPracticeTime = 0;

            words.forEach(word => {
                totalCorrect += word.correctCount;
                totalAnswered += word.correctCount + word.wrongCount;
                totalPracticeTime += word.practiceTime || 0;
            });

            const accuracy = totalAnswered > 0 ? Math.round(totalCorrect / totalAnswered * 100) : 0;
            const practiceMinutes = Math.floor(totalPracticeTime / 60);
            const learningProgress = totalWords > 0 ? Math.min(Math.round(accuracy * totalWords / 100), 100) : 0;

            vocabularyStats = {
                totalWords: totalWords,
                quizAccuracy: accuracy,
                practiceTime: practiceMinutes,
                learningProgress: learningProgress
            };

            // UI 업데이트
            const elements = {
                totalWords: document.getElementById('totalWords'),
                quizAccuracy: document.getElementById('quizAccuracy'),
                practiceTime: document.getElementById('practiceTime'),
                learningProgress: document.getElementById('learningProgress'),
                progressBar: document.getElementById('progressBar')
            };

            if (elements.totalWords) elements.totalWords.textContent = totalWords;
            if (elements.quizAccuracy) elements.quizAccuracy.textContent = `${accuracy}%`;
            if (elements.practiceTime) elements.practiceTime.textContent = `${practiceMinutes}분`;
            if (elements.learningProgress) elements.learningProgress.textContent = `${learningProgress}%`;
            if (elements.progressBar) elements.progressBar.style.width = `${learningProgress}%`;
        }

        function loadVocabularyData() {
            try {
                const savedVocab = localStorage.getItem('vocabularyData');
                if (savedVocab) {
                    const data = JSON.parse(savedVocab);
                    vocabularyDict = new Map(data.words || []);
                    vocabularyStats = data.stats || {
                        totalWords: 0,
                        quizAccuracy: 0,
                        practiceTime: 0,
                        learningProgress: 0
                    };
                }

                updateVocabularyList();
                updateVocabularyStats();
            } catch (error) {
                console.error('단어장 데이터 로드 실패:', error);
                vocabularyDict = new Map();
                vocabularyStats = {
                    totalWords: 0,
                    quizAccuracy: 0,
                    practiceTime: 0,
                    learningProgress: 0
                };
            }
        }

        function saveVocabularyData() {
            try {
                const data = {
                    words: Array.from(vocabularyDict.entries()),
                    stats: vocabularyStats,
                    lastSaved: new Date().toISOString()
                };
                localStorage.setItem('vocabularyData', JSON.stringify(data));
            } catch (error) {
                console.error('단어장 데이터 저장 실패:', error);
            }
        }

        // 퀴즈 관련 보조 함수들
        function updateQuizDisplay() {
            if (!quizState.active || quizState.currentIndex >= quizState.words.length) return;

            const currentWord = quizState.words[quizState.currentIndex];
            const progress = (quizState.currentIndex / quizState.totalQuestions) * 100;

            document.getElementById('quizProgressBar').style.width = `${progress}%`;
            document.getElementById('quizCurrent').textContent = quizState.currentIndex + 1;
            document.getElementById('quizTotal').textContent = quizState.totalQuestions;
            document.getElementById('quizCorrect').textContent = quizState.correctAnswers;
            document.getElementById('quizWrong').textContent = quizState.wrongAnswers;

            document.getElementById('quizQuestionText').textContent = currentWord.original;
            document.getElementById('quizQuestionHint').textContent = `"${currentWord.original}"의 뜻은?`;

            // 선택지 생성
            generateQuizOptions(currentWord);

            document.getElementById('quizNextBtn').disabled = true;
            document.getElementById('quizResult').style.display = 'none';
        }

        function generateQuizOptions(correctWord) {
            const allWords = Array.from(vocabularyDict.values());
            const wrongWords = allWords.filter(word => word.original !== correctWord.original);

            // 랜덤 오답 3개 선택
            const wrongOptions = shuffleArray(wrongWords).slice(0, 3);
            const options = [correctWord, ...wrongOptions];
            const shuffledOptions = shuffleArray(options);

            const correctIndex = shuffledOptions.findIndex(word => word.original === correctWord.original);

            const optionsContainer = document.getElementById('quizOptions');
            optionsContainer.innerHTML = shuffledOptions.map((word, index) =>
                `<div class="quiz-option" data-correct="${correctIndex}" onclick="selectQuizOption(${index})">
            ${word.translation}
        </div>`
            ).join('');
        }

        function showQuizResult() {
            const accuracy = Math.round((quizState.correctAnswers / quizState.totalQuestions) * 100);

            document.getElementById('quizFinalScore').textContent = `${accuracy}%`;

            let message = '';
            if (accuracy >= 90) {
                message = '🎉 완벽합니다! 훌륭한 실력이에요!';
            } else if (accuracy >= 70) {
                message = '👍 잘했습니다! 조금만 더 연습하면 완벽해질 거예요!';
            } else if (accuracy >= 50) {
                message = '📚 더 연습이 필요해요. 단어장을 다시 살펴보세요!';
            } else {
                message = '💪 포기하지 마세요! 꾸준한 연습이 실력 향상의 비결입니다!';
            }

            document.getElementById('quizMessage').textContent = message;
            document.getElementById('quizResult').style.display = 'block';

            // 다른 요소들 숨기기
            document.querySelector('.quiz-question').style.display = 'none';
            document.querySelector('.quiz-options').style.display = 'none';
            document.querySelector('.quiz-controls').style.display = 'none';
        }

        function updateQuizStats() {
            document.getElementById('quizCorrect').textContent = quizState.correctAnswers;
            document.getElementById('quizWrong').textContent = quizState.wrongAnswers;
        }

        // 보조 함수들
        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function generatePronunciation(word) {
            // 간단한 발음 표기 생성 (실제로는 더 복잡한 로직 필요)
            if (/^[a-zA-Z]+$/.test(word)) {
                // 영어 단어인 경우 간단한 발음 표기
                return word.toLowerCase().replace(/[aeiou]/g, match => {
                    const vowelMap = { 'a': 'ㅏ', 'e': 'ㅓ', 'i': 'ㅣ', 'o': 'ㅗ', 'u': 'ㅜ' };
                    return vowelMap[match] || match;
                });
            } else if (/[가-힣]/.test(word)) {
                // 한국어인 경우 그대로 반환
                return word;
            } else {
                // 베트남어나 기타 언어인 경우
                return word;
            }
        }

        function generatePronunciationTips(word) {
            // 발음 팁 생성
            if (/^[a-zA-Z]+$/.test(word)) {
                return "영어 발음 시 입 모양과 혀의 위치에 주의하세요. 천천히 따라해보세요.";
            } else if (/[가-힣]/.test(word)) {
                return "한국어 발음 시 정확한 받침 발음에 주의하세요.";
            } else {
                return "해당 언어의 특징적인 발음에 주의하여 연습하세요.";
            }
        }

        // ✅ 단어장 드롭다운 토글 함수
        function toggleVocabulary() {
            const vocabDropdown = document.getElementById('vocabularyDropdown');
            const vocabToggle = document.getElementById('vocabToggle');

            vocabDropdown.classList.toggle('active');
            vocabToggle.classList.toggle('active');

            if (vocabDropdown.classList.contains('active')) {
                updateVocabularyList();
                updateVocabularyStats();

                // 다른 모달들 닫기
                const dashboardModal = document.getElementById('dashboardModal');
                const settingsPanel = document.getElementById('settingsPanel');
                if (dashboardModal) dashboardModal.classList.remove('active');
                if (settingsPanel) settingsPanel.classList.remove('active');

                // 외부 클릭 시 닫기 이벤트 추가
                setTimeout(() => {
                    document.addEventListener('click', closeVocabularyOnOutsideClick);
                }, 100);
            } else {
                document.removeEventListener('click', closeVocabularyOnOutsideClick);
            }
        }

        function closeVocabularyOnOutsideClick(event) {
            const vocabDropdown = document.getElementById('vocabularyDropdown');
            const vocabToggle = document.getElementById('vocabToggle');

            if (!vocabDropdown.contains(event.target) && !vocabToggle.contains(event.target)) {
                vocabDropdown.classList.remove('active');
                vocabToggle.classList.remove('active');
                document.removeEventListener('click', closeVocabularyOnOutsideClick);
            }
        }

        function toggleRecentPlays() {
            const recentPlayList = document.getElementById('recentPlayList');
            const toggleBtn = document.getElementById('recentPlaysToggleBtn');

            if (recentPlayList.style.display === 'none') {
                recentPlayList.style.display = 'block';
                toggleBtn.textContent = '접기';
            } else {
                recentPlayList.style.display = 'none';
                toggleBtn.textContent = '펼치기';
            }
        }

        // AI 문맥 번역 함수들
        function toggleAIMode() {
            aiContextMode = !aiContextMode;
            els.aiToggle.classList.toggle('active', aiContextMode);
            els.aiContextBadge.classList.toggle('active', aiContextMode);
            els.translateBtn.classList.toggle('ai-enhanced', aiContextMode);
            els.translateBtnText.textContent = aiContextMode ? 'AI 번역' : '번역하기';
            els.aiSettingsSection.style.display = aiContextMode ? 'block' : 'none';

            if (aiContextMode) {
                showStatus("🧠 AI 문맥 번역 모드 활성화", "success");
            } else {
                showStatus("📝 일반 번역 모드로 전환", "info");
            }

            saveAISettings();
        }

        function buildContextualPrompt(inputText, targetLang) {
            const sourceLang = els.sourceLangSelect.value;
            let prompt = `번역할 텍스트: "${inputText}"\n번역 방향: ${sourceLang} → ${targetLang}\n`;

            // 번역 스타일 적용
            const styleInstructions = {
                balanced: "자연스럽고 균형잡힌 번역을 제공하세요.",
                formal: "격식있고 공손한 어조로 번역하세요.",
                casual: "친근하고 편안한 어조로 번역하세요.",
                literal: "원문의 의미를 정확히 보존하여 직역하세요."
            };
            prompt += `번역 스타일: ${styleInstructions[currentTranslationStyle]}\n`;

            // 품질 레벨 적용
            if (qualityLevel >= 4) {
                prompt += "매우 정확하고 자연스러운 고품질 번역을 제공하세요. 문화적 뉘앙스와 관용표현을 적절히 반영하세요.\n";
            } else if (qualityLevel >= 3) {
                prompt += "정확하고 자연스러운 번역을 제공하세요.\n";
            }

            // 전문용어 사전 적용
            if (terminologyDict.size > 0) {
                prompt += "다음 전문용어를 일관성있게 사용하세요:\n";
                terminologyDict.forEach((translation, original) => {
                    prompt += `- "${original}" → "${translation}"\n`;
                });
            }

            // 문맥 정보 추가 (최근 5개 고정)
            if (translationContext.length > 0) {
                const recentContext = translationContext.slice(-5);
                prompt += "\n이전 번역 맥락:\n";
                recentContext.forEach((ctx, index) => {
                    prompt += `${index + 1}. "${ctx.source}" → "${ctx.translation}"\n`;
                });
                prompt += "\n위 맥락을 고려하여 일관성있게 번역하세요.\n";
            }

            return prompt;
        }

        async function handleTranslate() {
            const inputText = els.inputText.value.trim();
            if (!inputText) return;

            const targetLang = els.targetLangSelect.value;
            // 🔧 AI 모드 권한 체크
            if (aiContextMode && !currentUser) {
                showPremiumAlert('AI 문맥 번역');
                return;
            }

            // 🔧 게스트 모드 알림 (첫 번역 시에만)
            if (!currentUser && !sessionStorage.getItem('guestWarningShown')) {
                showStatus("🎯 게스트 모드로 이용 중입니다. 로그인하시면 더 많은 기능을 이용하실 수 있습니다.", "info");
                sessionStorage.setItem('guestWarningShown', 'true');
            }
            const cacheKey = `${inputText}:${targetLang}:${aiContextMode}`;

            // 캐시 확인
            const cachedResult = isPronunciationEnabled ? cacheManager.getTranslation(cacheKey) : null;
            if (cachedResult) {
                displayTranslation(cachedResult.translation, cachedResult.pronunciation_hangul, inputText, true);
                showStatus("📦 캐시에서 로드됨", "success");
                updateStats(true);
                return;
            }

            showStatus(aiContextMode ? "🧠 AI 문맥 번역 중..." : "번역 중...", "info");
            els.cacheIndicator.style.display = "none";
            els.aiIndicator.style.display = aiContextMode ? "inline-block" : "none";

            usageTracker.track("translation", inputText.length);

            try {
                let requestBody;

                if (aiContextMode) {
                    // AI 문맥 번역 요청
                    const contextualPrompt = buildContextualPrompt(inputText, targetLang);
                    requestBody = {
                        action: "translate",
                        inputText: inputText,
                        targetLang: targetLang,
                        getPronunciation: isPronunciationEnabled,
                        useAIContext: true,
                        contextualPrompt: contextualPrompt,
                        qualityLevel: qualityLevel,
                        model: getOptimalModel(inputText), // 🤖 AI 모델 선택
                        domain: selectedDomain // 🏭 전문 분야
                    };
                } else {
                    // 일반 번역 요청
                    requestBody = {
                        action: "translate",
                        inputText: inputText,
                        targetLang: targetLang,
                        getPronunciation: isPronunciationEnabled,
                        model: getOptimalModel(inputText), // 🤖 AI 모델 선택
                        domain: selectedDomain // 🏭 전문 분야
                    };
                }

                const response = await fetch(API_URL, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        ...(authToken && { "Authorization": `Bearer ${authToken}` })
                    },
                    body: JSON.stringify(requestBody)
                });

                const result = await response.json();
                if (result.error) throw new Error(result.error);

                // 📝 피드백 학습용 번역 정보 저장
                lastOriginalText = inputText;
                lastOriginalTranslation = result.translation;
                lastTargetLang = targetLang;

                displayTranslation(result.translation, result.pronunciation_hangul, inputText, false);

                // 📝 피드백 적용 표시
                if (result.feedbackApplied) {
                    showStatus(`📝 사용자 피드백 적용됨 (${result.feedbackMatchType === 'exact' ? '정확 일치' : '유사 일치'})`, 'success');
                }

                // 번역 컨텍스트에 추가 (AI 모드일 때만)
                if (aiContextMode) {
                    translationContext.push({
                        source: inputText,
                        translation: result.translation,
                        timestamp: Date.now()
                    });

                    // 컨텍스트 크기 제한
                    if (translationContext.length > 20) {
                        translationContext = translationContext.slice(-20);
                    }
                }

                if (isPronunciationEnabled) {
                    cacheManager.setTranslation(cacheKey, result);
                }

                saveToHistory(inputText, result.translation, els.sourceLangSelect.value, targetLang);
                updateStats(false);
                showStatus(aiContextMode ? "🧠 AI 번역 완료" : "번역 완료", "success");

            } catch (error) {
                showStatus(`번역 실패: ${error.message}`, "error");
            }
        }

        // AI 설정 저장/로드
        function saveAISettings() {
            const aiSettings = {
                aiContextMode,
                translationContext: translationContext.slice(-20), // 최근 20개만 저장
                currentTranslationStyle,
                qualityLevel,
                terminologyDict: Array.from(terminologyDict.entries()) // 전문용어 사전 저장
            };
            localStorage.setItem('aiSettings', JSON.stringify(aiSettings));
        }

        function loadAISettings() {
            const saved = localStorage.getItem('aiSettings');
            if (saved) {
                try {
                    const aiSettings = JSON.parse(saved);
                    aiContextMode = aiSettings.aiContextMode || false;
                    translationContext = aiSettings.translationContext || [];
                    currentTranslationStyle = aiSettings.currentTranslationStyle || 'balanced';
                    qualityLevel = aiSettings.qualityLevel || 3;

                    // 전문용어 사전 복원
                    if (aiSettings.terminologyDict) {
                        terminologyDict = new Map(aiSettings.terminologyDict);
                    }

                    // UI 업데이트
                    els.aiToggle.classList.toggle('active', aiContextMode);
                    els.aiContextBadge.classList.toggle('active', aiContextMode);
                    els.translateBtn.classList.toggle('ai-enhanced', aiContextMode);
                    els.translateBtnText.textContent = aiContextMode ? 'AI 번역' : '번역하기';
                    els.aiSettingsSection.style.display = aiContextMode ? 'block' : 'none';
                    els.qualitySlider.value = qualityLevel;

                    // 모델 정보 표시 초기화
                    updateModelInfo(qualityLevel);

                    // 스타일 버튼 업데이트
                    document.querySelectorAll('.style-btn').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.style === currentTranslationStyle);
                    });

                    // 전문용어 목록 업데이트
                    updateTerminologyList();
                } catch (e) {
                    console.error('AI 설정 로드 실패:', e);
                }
            }
        }

        // 기존 함수들 (기본 번역기 기능)

        // 🤖 AI 모델 선택 상태 변수
        let selectedAIModel = localStorage.getItem('selectedAIModel') || 'auto';

        // 🏭 전문 분야 선택 상태 변수
        let selectedDomain = localStorage.getItem('selectedDomain') || 'general';

        // 🏭 전문 분야 선택 업데이트 함수
        function updateDomainSelection() {
            const select = document.getElementById('domainSelect');
            if (!select) return;

            selectedDomain = select.value;
            localStorage.setItem('selectedDomain', selectedDomain);

            console.log('[Domain] 선택된 분야:', selectedDomain);

            if (selectedDomain === 'manufacturing') {
                showStatus('🏭 제조 자동화 모드 활성화 - 전문 용어 자동 적용', 'success');
            }
        }

        // 📝 번역 피드백 학습 변수
        let lastOriginalText = '';
        let lastOriginalTranslation = '';
        let lastTargetLang = '';

        // 📝 번역 피드백 저장 함수
        async function saveTranslationFeedback(correctedTranslation) {
            if (!currentUser || !lastOriginalText) {
                showStatus('❌ 피드백 저장: 로그인이 필요합니다.', 'error');
                return;
            }

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('authToken')}`
                    },
                    body: JSON.stringify({
                        action: 'save-feedback',
                        originalText: lastOriginalText,
                        originalTranslation: lastOriginalTranslation,
                        correctedTranslation: correctedTranslation,
                        feedbackTargetLang: lastTargetLang
                    })
                });

                const result = await response.json();
                if (result.success) {
                    showStatus('✅ 피드백 저장 완료! 다음에 동일한 문장 번역 시 적용됩니다.', 'success');
                } else {
                    showStatus('❌ 피드백 저장 실패: ' + result.error, 'error');
                }
            } catch (error) {
                console.error('[Feedback] 저장 오류:', error);
                showStatus('❌ 피드백 저장 중 오류 발생', 'error');
            }
        }

        // 📝 번역 수정 모달 표시
        function showEditTranslationModal() {
            if (!lastOriginalTranslation) {
                showStatus('수정할 번역이 없습니다.', 'error');
                return;
            }

            const corrected = prompt('📝 번역 수정:\n\n원문: ' + lastOriginalText + '\n\n현재 번역을 수정해주세요:', lastOriginalTranslation);

            if (corrected && corrected !== lastOriginalTranslation) {
                saveTranslationFeedback(corrected);

                // UI에 수정된 번역 즉시 반영
                const outputEl = document.getElementById('outputText');
                if (outputEl) {
                    outputEl.innerText = corrected;
                }
            }
        }

        // 🤖 AI 모델 선택 업데이트 함수
        function updateAIModelSelection() {
            const select = document.getElementById('aiModelSelect');
            if (!select) return;

            selectedAIModel = select.value;
            localStorage.setItem('selectedAIModel', selectedAIModel);

            const indicator = document.getElementById('modelIndicator');
            const modelDescriptions = {
                'auto': '🔄 <strong>자동 최적화</strong> - 텍스트 길이에 따라 최적 모델 선택',
                'gpt-4.1': '🟢 <strong>GPT-4.1</strong> - 최고 품질의 번역 (비용 높음)',
                'gpt-4.1-mini': '🟢 <strong>GPT-4.1 Mini</strong> - 빠른 번역 속도 (품질 양호)',
                'gemini-2.0-flash': '🔵 <strong>Gemini 2.0 Flash</strong> - 매우 빠름, 비용 저렴'
            };

            if (indicator) {
                indicator.innerHTML = `현재 모드: ${modelDescriptions[selectedAIModel] || modelDescriptions['auto']}`;
            }

            console.log('[AI Model] 선택된 모델:', selectedAIModel);
        }

        // 🤖 텍스트 길이에 따른 자동 모델 선택 (하이브리드 모드)
        function getOptimalModel(text) {
            if (selectedAIModel !== 'auto') {
                return selectedAIModel;
            }

            const charCount = text.length;
            // 자동 모드: 짧은 텍스트 → Gemini (빠름), 긴 텍스트 → GPT (정확)
            if (charCount < 100) {
                return 'gemini-2.0-flash';
            } else if (charCount < 500) {
                return 'gpt-4.1-mini';
            } else {
                return 'gpt-4.1';
            }
        }

        // 옵션 1: 품질 슬라이더의 모델 정보를 실시간으로 업데이트하는 함수
        function updateModelInfo(level) {
            const modelConfig = {
                1: { model: 'gemini-2.0-flash', cost: '매우 낮음', tokens: '1000', provider: 'Google' },
                2: { model: 'gpt-4.1-mini', cost: '낮음', tokens: '1200', provider: 'OpenAI' },
                3: { model: 'gpt-4.1', cost: '중간', tokens: '1500', provider: 'OpenAI' },
                4: { model: 'gpt-4.1', cost: '높음', tokens: '2000', provider: 'OpenAI' },
                5: { model: 'gpt-4.1', cost: '매우 높음', tokens: '2500', provider: 'OpenAI' }
            };

            const config = modelConfig[level];
            const modelInfoDisplay = document.getElementById('modelInfoDisplay');

            if (modelInfoDisplay && config) {
                const providerIcon = config.provider === 'Google' ? '🔵' : '🟢';
                modelInfoDisplay.innerHTML = `
            <span class="model-name">${providerIcon} ${config.model}</span>
            <span class="model-cost">비용: ${config.cost}</span>
            <span class="model-tokens">토큰: ${config.tokens}</span>
        `;
            }
        }

        // 📱 iOS 오디오 컨텍스트 잠금 해제 (전역 설정)
        let audioContextUnlocked = false;
        function unlockAudio() {
            if (audioContextUnlocked) return;
            initAudioContext();
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    audioContextUnlocked = true;
                    // 빈 오디오 버퍼 재생으로 확실하게 잠금 해제
                    const buffer = audioContext.createBuffer(1, 1, 22050);
                    const source = audioContext.createBufferSource();
                    source.buffer = buffer;
                    source.connect(audioContext.destination);
                    source.start(0);
                });
            } else {
                audioContextUnlocked = true;
            }
            // 이벤트 리스너 제거 (한 번만 실행하면 됨)
            document.removeEventListener('touchstart', unlockAudio);
            document.removeEventListener('click', unlockAudio);
        }
        document.addEventListener('touchstart', unlockAudio, { passive: true });
        document.addEventListener('click', unlockAudio, { passive: true });

        async function handleSpeak() {
            // 📱 iOS 호환성: 비동기 호출 전에 오디오 컨텍스트 초기화 (필수)
            initAudioContext();

            if (!currentTranslation) return;
            window.budgetExceeded && (els.ttsEngineMode.value = "google", showStatus("⛔ 예산 초과. Google TTS만 사용 가능", "error"));
            const e = els.targetLangSelect.value, t = els.ttsEngineMode.value;
            let a = "openai";
            "google" === t ? a = "google" : "openai" === t ? a = "openai" : "auto" === t ? "Vietnamese" === e || currentTranslation.length < parseInt(els.autoThreshold.value) ? a = "google" : a = "openai" : "smart" === t ? currentTranslation.length < 100 || conversationState.isActive || "Vietnamese" === e ? a = "google" : a = "openai" : a = "openai";
            const s = "google" === a ? els.googleVoiceSelect.value : els.voiceSelect.value, i = `${currentTranslation}:${e}:${a}:${s}`, o = cacheManager.getTTS(i);
            if (els.engineIndicator.textContent = a.charAt(0).toUpperCase(), els.engineIndicator.className = `engine-indicator ${a}`, els.engineIndicator.style.display = "inline-block", o) return queueAudioBlob(o), showStatus("🔊 캐시된 음성 재생", "success"), void cacheManager.addRecentPlay(currentSource, currentTranslation, e, a);
            showStatus("음성 생성 중...", "info"), usageTracker.track("tts", currentTranslation.length, a);
            try {
                const t = await fetch(API_URL, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ action: "speak", inputText: currentTranslation, language: e, useGoogleTTS: "google" === a, voice: s, voiceName: s }) });
                if (!t.ok) throw new Error(`API 오류: ${t.statusText}`);
                const o = await t.blob();
                cacheManager.setTTS(i, o), queueAudioBlob(o), cacheManager.addRecentPlay(currentSource, currentTranslation, e, a), showStatus(`🔊 ${a} TTS 재생`, "success")
            } catch (e) {
                showStatus(`음성 생성 실패: ${e.message}`, "error")
            }
        }

        function handleVoiceTranslate() { recognition || setupSpeechRecognition(), isRecording ? recognition.stop() : (recognition.lang = langCodeMap[els.sourceLangSelect.value], recognition.start()) }
        function displayTranslation(e, t, a, s) { currentTranslation = e, currentSource = a, els.translation.textContent = e, els.pronunciationSection.style.display = isPronunciationEnabled ? "block" : "none", isPronunciationEnabled && (els.pronunciationContent.textContent = t || ""), els.speakBtn.disabled = !1, els.copyBtn.disabled = !1, els.cacheIndicator.style.display = s ? "inline-block" : "none" }
        function setupSpeechRecognition() { const e = window.SpeechRecognition || window.webkitSpeechRecognition; if (!e) return void showStatus("음성 인식 미지원 브라우저", "error"); recognition = new e, recognition.continuous = !1, recognition.interimResults = !0; let t = ""; recognition.onstart = () => { isRecording = !0, t = "", els.voiceBtn.classList.add("recording") }, recognition.onresult = e => { let a = ""; for (let s = e.resultIndex; s < e.results.length; ++s)e.results[s].isFinal ? t += e.results[s][0].transcript : a += e.results[s][0].transcript; conversationState.isActive || (els.inputText.value = t + a) }, recognition.onend = () => { isRecording = !1, els.voiceBtn.classList.remove("recording"); const e = t.trim(); conversationState.isActive ? e ? handleConversationTranslation(e) : startAutoRecognition() : e && (els.inputText.value = e, handleTranslate()) }, recognition.onerror = e => { showStatus(`음성 인식 오류: ${e.error}`, "error"), isRecording = !1, els.voiceBtn.classList.remove("recording") } }
        function toggleDashboard() { els.dashboardModal.classList.toggle("active"), els.dashboardModal.classList.contains("active") && usageTracker.updateDisplay() }
        function toggleSettings() { els.settingsPanel.classList.toggle("active") }
        function toggleTheme() { const e = "dark" === document.documentElement.getAttribute("data-theme") ? "light" : "dark"; document.documentElement.setAttribute("data-theme", e), localStorage.setItem("theme", e) }
        function swapLanguages() { const e = els.sourceLangSelect.value; els.sourceLangSelect.value = els.targetLangSelect.value, els.targetLangSelect.value = e, saveSettings() }
        function copyTranslation() { navigator.clipboard.writeText(currentTranslation).then(() => showStatus("📋 번역문 복사 완료", "success")) }
        function copyInputText() { const e = els.inputText.value; e ? navigator.clipboard.writeText(e).then(() => showStatus("📋 원문 복사 완료", "success")) : showStatus("복사할 내용이 없습니다", "warning") }
        async function pasteFromClipboard() { try { const e = await navigator.clipboard.readText(); e ? (els.inputText.value += e, showStatus("📋 붙여넣기 완료", "success")) : showStatus("클립보드가 비어있습니다", "warning") } catch (e) { console.error("붙여넣기 실패:", e), showStatus("붙여넣기에 실패했습니다", "error") } }
        function clearAll() { els.inputText.value = "", els.translation.textContent = "", els.pronunciationContent.textContent = "", els.speakBtn.disabled = !0, els.copyBtn.disabled = !0, els.cacheIndicator.style.display = "none", els.aiIndicator.style.display = "none" }
        function showStatus(e, t = "") { els.status.textContent = e, els.status.className = `status ${t}`, setTimeout(() => { els.status.textContent = "", els.status.className = "status" }, 3e3) }
        function clearAllCache() { confirm("모든 캐시 데이터를 삭제하시겠습니까?") && (cacheManager.clear(), updateRecentPlays(), displayStats(), showStatus("✨ 캐시가 초기화되었습니다.", "success")) }
        function switchToNormalMode() { conversationState.isActive && stopConversation(), els.normalModeBtn.classList.add("active"), els.conversationModeBtn.classList.remove("active"), els.normalMode.classList.remove("hidden"), els.conversationMode.classList.remove("active") }
        function switchToConversationMode() { els.conversationModeBtn.classList.add("active"), els.normalModeBtn.classList.remove("active"), els.normalMode.classList.add("hidden"), els.conversationMode.classList.add("active"), updateActiveSpeaker() }
        function updateSpeakerLanguages() { els.speakerLangA.textContent = els.sourceLangSelect.options[els.sourceLangSelect.selectedIndex].text, els.speakerLangB.textContent = els.targetLangSelect.options[els.targetLangSelect.selectedIndex].text }
        function startConversation() { conversationState.isActive = !0, conversationState.currentSpeaker = "A", conversationState.autoRecognition = !0, els.startConversationBtn.disabled = !0, els.stopConversationBtn.disabled = !1, updateActiveSpeaker(), startAutoRecognition() }
        function stopConversation() { conversationState.isActive = !1, conversationState.autoRecognition = !1, recognition && isRecording && recognition.stop(), els.startConversationBtn.disabled = !1, els.stopConversationBtn.disabled = !0, els.speakerCardA.classList.remove("active"), els.speakerCardB.classList.remove("active") }
        function clearConversation() { conversationState.messages = [], updateConversationHistory() }
        function updateActiveSpeaker() { "A" === conversationState.currentSpeaker ? (els.speakerCardA.classList.add("active"), els.speakerCardB.classList.remove("active")) : (els.speakerCardA.classList.remove("active"), els.speakerCardB.classList.add("active")) }
        async function startAutoRecognition() { if (!conversationState.autoRecognition) return; isRecording && (recognition.stop(), await new Promise(e => setTimeout(e, 100))); const e = "A" === conversationState.currentSpeaker ? els.sourceLangSelect.value : els.targetLangSelect.value; recognition.lang = langCodeMap[e], recognition.start() }
        async function handleConversationTranslation(e) { const t = conversationState.currentSpeaker, a = "B" === t, s = a ? els.targetLangSelect.value : els.sourceLangSelect.value, i = a ? els.sourceLangSelect.value : els.targetLangSelect.value; usageTracker.track("translation", e.length), updateStats(!1); const o = await fetch(API_URL, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ action: "translate", inputText: e, targetLang: i, getPronunciation: !1 }) }), r = await o.json(); conversationState.messages.push({ speaker: t, original: e, translation: r.translation }), updateConversationHistory(), playChunkedAudio(r.chunks || [r.translation], i), conversationState.currentSpeaker = "A" === t ? "B" : "A", updateActiveSpeaker(), setTimeout(startAutoRecognition, 500) }
        function updateConversationHistory() { 0 === conversationState.messages.length ? els.conversationHistory.innerHTML = '<div style="text-align:center; padding: 20px; color: var(--text-secondary);">대화를 시작하세요</div>' : (els.conversationHistory.innerHTML = conversationState.messages.map(e => `<div class="conversation-message"><div class="message-speaker speaker-${"A" === e.speaker ? "a" : "b"}">${e.speaker}</div><div class="message-content"><div class="message-original">${e.original}</div><div class="message-translation">${e.translation}</div></div></div>`).join(""), els.conversationHistory.scrollTop = els.conversationHistory.scrollHeight) }
        async function playChunkedAudio(e, t) { for (const a of e) { usageTracker.track("tts", a.length, "google"); const e = await fetch(API_URL, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ action: "speak", inputText: a, language: t, useGoogleTTS: !0, voiceName: els.googleVoiceSelect.value }) }); e.ok && queueAudioBlob(await e.blob()) } }
        function initAudioContext() { audioContext || (audioContext = new (window.AudioContext || window.webkitAudioContext)), "suspended" === audioContext?.state && audioContext.resume() }
        async function playAudioBlob(e) {
            try {
                initAudioContext();
                const audioBuffer = await audioContext.decodeAudioData(await e.arrayBuffer());
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;

                // 🎯 볼륨 조절기(GainNode) 생성
                const gainNode = audioContext.createGain();

                // 🎯 증폭 설정 (1.0이 기본값, 숫자를 키울수록 소리가 커집니다)
                gainNode.gain.value = 4.5; // 예: 2.5배 증폭

                // 🎯 오디오 연결: 소스 -> 볼륨 조절기 -> 스피커
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);

                source.onended = playNextInQueue;
                source.start(0);
            } catch (t) {
                // Web Audio API를 지원하지 않는 경우의 대체 코드
                const audio = new Audio(URL.createObjectURL(e));
                audio.volume = 1.0; // HTML Audio 요소의 볼륨은 0.0 ~ 1.0
                audio.onended = playNextInQueue;
                audio.play();
            }
        }
        function queueAudioBlob(e) { audioQueue.push(e), isQueuePlaying || playNextInQueue() }
        function playNextInQueue() { if (0 === audioQueue.length) return void (isQueuePlaying = !1); isQueuePlaying = !0, playAudioBlob(audioQueue.shift()) }
        function getStats() { const e = localStorage.getItem("translationStats"); return e ? JSON.parse(e) : { totalTranslations: 0, todayTranslations: 0, lastDate: (new Date).toDateString() } }
        function updateStats(e) { const t = getStats(); (new Date).toDateString() !== t.lastDate && (t.todayTranslations = 0, t.lastDate = (new Date).toDateString()), e || (t.totalTranslations++, t.todayTranslations++), localStorage.setItem("translationStats", JSON.stringify(t)), displayStats() }
        function displayStats() { const e = getStats(); els.todayTranslations.textContent = e.todayTranslations, els.totalTranslations.textContent = e.totalTranslations; const t = cacheManager.stats.hits + cacheManager.stats.misses > 0 ? Math.round(cacheManager.stats.hits / (cacheManager.stats.hits + cacheManager.stats.misses) * 100) : 0; els.cacheHitRate.textContent = `${t}%` }
        function saveToHistory(e, t, a, s) { const i = JSON.parse(localStorage.getItem("translationHistory") || "[]"); i.unshift({ source: e, translation: t, sourceLang: a, targetLang: s, time: (new Date).toLocaleString("ko-KR") }), i.length > 50 && i.pop(), localStorage.setItem("translationHistory", JSON.stringify(i)) }
        function showHistory() { const e = JSON.parse(localStorage.getItem("translationHistory") || "[]"); els.historyList.innerHTML = e.length ? e.map((e, t) => `<div class="recent-play-item" onclick="loadFromHistory(${t})"><div><div class="recent-play-text" style="white-space: normal;"><b>${e.sourceLang}:</b> ${e.source}</div><div class="recent-play-text" style="white-space: normal; color: var(--primary);"><b>${e.targetLang}:</b> ${e.translation}</div></div><small style="color: var(--text-secondary);">${e.time}</small></div>`).join("") : `<p style="text-align:center;">기록 없음</p>`, els.historyModal.classList.add("active") }
        function hideHistory() { els.historyModal.classList.remove("active") }
        function loadFromHistory(e) { const t = JSON.parse(localStorage.getItem("translationHistory"))[e]; t && (els.inputText.value = t.source, els.sourceLangSelect.value = t.sourceLang, els.targetLangSelect.value = t.targetLang, hideHistory(), handleTranslate()) }
        function clearHistory() { confirm("모든 기록을 삭제합니까?") && (localStorage.removeItem("translationHistory"), showHistory()) }

        function updateRecentPlays() {
            const recentPlaysEl = els.recentPlays;
            const recentPlayListEl = els.recentPlayList;

            // 최근 재생 항목이 있을 때만 표시하되, 기본은 접힌 상태
            if (cacheManager.recentPlays.length > 0) {
                recentPlaysEl.classList.add("active");
                recentPlayListEl.innerHTML = cacheManager.recentPlays.map((e, t) => `<div class="recent-play-item"><div class="recent-play-text">${e.text.substring(0, 25)}...</div><div class="recent-play-actions"><button class="recent-play-btn" onclick="replayRecent(${t})">🔊</button><span class="engine-indicator ${e.engine}">${e.engine[0].toUpperCase()}</span></div></div>`).join("");

                // 기본 접힌 상태 유지
                if (!recentPlayListEl.style.display || recentPlayListEl.style.display === 'none') {
                    recentPlayListEl.style.display = 'none';
                    document.getElementById('recentPlaysToggleBtn').textContent = '펼치기';
                }
            } else {
                recentPlaysEl.classList.remove("active");
            }
        }

        async function replayRecent(e) { const t = cacheManager.recentPlays[e], a = "google" === t.engine ? els.googleVoiceSelect.value : els.voiceSelect.value, s = `${t.translation}:${t.lang}:${t.engine}:${a}`, i = cacheManager.getTTS(s); if (i) return void queueAudioBlob(i); currentTranslation = t.translation, currentSource = t.text, await handleSpeak() }
        function saveSettings() { localStorage.setItem("ttsEngine", els.ttsEngineMode.value), localStorage.setItem("autoThreshold", els.autoThreshold.value), localStorage.setItem("voice", els.voiceSelect.value), localStorage.setItem("googleVoice", els.googleVoiceSelect.value), localStorage.setItem("volume", els.volumeControl.value), localStorage.setItem("sourceLang", els.sourceLangSelect.value), localStorage.setItem("targetLang", els.targetLangSelect.value), localStorage.setItem("pronunciationEnabled", isPronunciationEnabled) }
        function loadSettings() { document.documentElement.setAttribute("data-theme", localStorage.getItem("theme") || "light"), isPronunciationEnabled = "false" !== localStorage.getItem("pronunciationEnabled"), els.pronunciationToggle.classList.toggle("active", isPronunciationEnabled), els.pronunciationSection.style.display = isPronunciationEnabled ? "block" : "none", els.sourceLangSelect.value = localStorage.getItem("sourceLang") || "Korean", els.targetLangSelect.value = localStorage.getItem("targetLang") || "Vietnamese", els.ttsEngineMode.value = localStorage.getItem("ttsEngine") || "auto", els.autoThreshold.value = localStorage.getItem("autoThreshold") || "50", els.thresholdValue.textContent = `${els.autoThreshold.value}자`, els.voiceSelect.value = localStorage.getItem("voice") || "nova", els.googleVoiceSelect.value = localStorage.getItem("googleVoice") || "vi-VN-Standard-A", els.volumeControl.value = localStorage.getItem("volume") || "0.8", els.volumeValue.textContent = `${Math.round(100 * els.volumeControl.value)}%`, updateAutoModeVisibility(), document.getElementById("dailyBudget").value = localStorage.getItem("dailyBudget") || "1.00", document.getElementById("monthlyBudget").value = localStorage.getItem("monthlyBudget") || "30.00" }
        function updateAutoModeVisibility() { const e = els.ttsEngineMode.value; els.autoModeSettings.style.display = "auto" === e || "smart" === e ? "grid" : "none" }
        function togglePronunciationView() { const e = els.pronunciationContent; e.style.display = "none" === e.style.display || "" === e.style.display ? "block" : "none", els.pronToggleIcon.textContent = "block" === e.style.display ? "▼" : "▶" }

        // ✅ 전역 함수로 할당 (HTML에서 호출 가능하도록)
        window.addVocabulary = addVocabulary;
        window.showWordDetail = showWordDetail;
        window.closeWordDetail = closeWordDetail;
        window.speakCurrentWord = speakCurrentWord;
        window.removeVocabulary = removeVocabulary;
        window.startQuiz = startQuiz;
        window.startSingleWordQuiz = startSingleWordQuiz;
        window.selectQuizOption = selectQuizOption;
        window.nextQuestion = nextQuestion;
        window.closeQuiz = closeQuiz;
        window.startPronunciationPractice = startPronunciationPractice;
        window.startWordPractice = startWordPractice;
        window.listenPracticeWord = listenPracticeWord;
        window.toggleRecording = toggleRecording;
        window.nextPracticeWord = nextPracticeWord;
        window.closePractice = closePractice;
        window.showPreviousWord = showPreviousWord;
        window.showNextWord = showNextWord;
        window.speakVocabularyWord = speakVocabularyWord;
        // 🔧 추가: 인증 관련 전역 함수들
        window.toggleAuth = toggleAuth;
        window.toggleApiKeys = toggleApiKeys;
        window.handleLogin = handleLogin;
        window.handleRegister = handleRegister;
        window.continueAsGuest = continueAsGuest;
        window.showForgotPassword = showForgotPassword;
        window.showLoginForm = showLoginForm;
        window.handleForgotPassword = handleForgotPassword;
        window.switchAuthTab = switchAuthTab;
        window.saveOpenAIKey = saveOpenAIKey;
        window.saveGoogleKey = saveGoogleKey;
        window.testOpenAIKey = testOpenAIKey;
        window.testGoogleKey = testGoogleKey;
        window.speakCurrentWord = speakCurrentWord;

        // 🔧 권한 체크가 포함된 전역 함수들
        window.toggleAIModeWithAuth = toggleAIModeWithAuth;
        window.toggleVocabularyWithAuth = toggleVocabularyWithAuth;
        window.switchVocabTab = switchVocabTab;
        window.addTerminology = addTerminology;
        window.removeTerminology = removeTerminology;

        // 모든 모달 닫기 함수
        function closeAllModals() {
            const modals = [
                'practiceModal',
                'wordDetailModal',
                'quizModal',
                'dashboardModal',
                'historyModal',
                'vocabularyDropdown'
            ];

            modals.forEach(modalId => {
                const modal = document.getElementById(modalId);
                if (modal) {
                    modal.classList.remove('active');
                    if (modalId === 'practiceModal') {
                        modal.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important;';
                    }
                }
            });
        }

        // 이전 단어 보기
        function showPreviousWord() {
            const words = Array.from(vocabularyDict.values());
            if (words.length <= 1) return;

            const currentIndex = words.findIndex(word => word.original === currentVocabWord.original);
            const previousIndex = currentIndex > 0 ? currentIndex - 1 : words.length - 1;
            const previousWord = words[previousIndex];

            showWordDetail(previousWord.original);
        }

        // 다음 단어 보기
        function showNextWord() {
            const words = Array.from(vocabularyDict.values());
            if (words.length <= 1) return;

            const currentIndex = words.findIndex(word => word.original === currentVocabWord.original);
            const nextIndex = currentIndex < words.length - 1 ? currentIndex + 1 : 0;
            const nextWord = words[nextIndex];

            showWordDetail(nextWord.original);
        }

        // ✅ 초기화
        document.addEventListener("DOMContentLoaded", function () {
            try {
                // 시스템 초기화
                usageTracker.initialize();
                cacheManager.load();
                loadSettings();
                loadAISettings();
                loadVocabularyData();
                setupSpeechRecognition();
                updateRecentPlays();
                updateSpeakerLanguages();
                displayStats();
                // 🔧 인증 시스템 초기화
                initAuthSystem();

                // 🤖 AI 모델 선택 초기화
                const savedModel = localStorage.getItem('selectedAIModel') || 'auto';
                const aiModelSelect = document.getElementById('aiModelSelect');
                if (aiModelSelect) {
                    aiModelSelect.value = savedModel;
                    updateAIModelSelection();
                }

                // 🏭 전문 분야 선택 초기화
                const savedDomain = localStorage.getItem('selectedDomain') || 'general';
                const domainSelect = document.getElementById('domainSelect');
                if (domainSelect) {
                    domainSelect.value = savedDomain;
                }

                // 🔧 UI 상태 초기 설정
                updateAuthUI(!!currentUser);

                // 기존 이벤트 리스너들
                if (els.ttsEngineMode) {
                    els.ttsEngineMode.addEventListener("change", function () {
                        updateAutoModeVisibility();
                        saveSettings();
                    });
                }

                if (els.autoThreshold) {
                    els.autoThreshold.addEventListener("input", function (e) {
                        if (els.thresholdValue) els.thresholdValue.textContent = `${e.target.value}자`;
                        saveSettings();
                    });
                }

                if (els.volumeControl) {
                    els.volumeControl.addEventListener("input", function (e) {
                        if (els.volumeValue) els.volumeValue.textContent = `${Math.round(100 * e.target.value)}%`;
                        saveSettings();
                    });
                }

                if (els.voiceSelect) {
                    els.voiceSelect.addEventListener("change", saveSettings);
                }

                if (els.googleVoiceSelect) {
                    els.googleVoiceSelect.addEventListener("change", saveSettings);
                }

                if (els.pronunciationToggle) {
                    els.pronunciationToggle.addEventListener("click", function () {
                        isPronunciationEnabled = !isPronunciationEnabled;
                        els.pronunciationToggle.classList.toggle("active", isPronunciationEnabled);
                        if (els.pronunciationSection) {
                            els.pronunciationSection.style.display = isPronunciationEnabled ? "block" : "none";
                        }
                        saveSettings();
                        showStatus(`발음 도우미 ${isPronunciationEnabled ? "ON" : "OFF"}`, "success");
                    });
                }

                const dailyBudgetEl = document.getElementById("dailyBudget");
                const monthlyBudgetEl = document.getElementById("monthlyBudget");

                if (dailyBudgetEl) {
                    dailyBudgetEl.addEventListener("change", function (e) {
                        localStorage.setItem("dailyBudget", e.target.value);
                    });
                }

                if (monthlyBudgetEl) {
                    monthlyBudgetEl.addEventListener("change", function (e) {
                        localStorage.setItem("monthlyBudget", e.target.value);
                    });
                }

                if (els.sourceLangSelect) {
                    els.sourceLangSelect.addEventListener("change", function () {
                        saveSettings();
                        updateSpeakerLanguages();
                    });
                }

                if (els.targetLangSelect) {
                    els.targetLangSelect.addEventListener("change", function () {
                        saveSettings();
                        updateSpeakerLanguages();
                    });
                }

                // AI 기능 이벤트 리스너들
                if (els.qualitySlider) {
                    els.qualitySlider.addEventListener("input", function (e) {
                        qualityLevel = parseInt(e.target.value);
                        updateModelInfo(qualityLevel); // 옵션 1: 슬라이더 변경 시 모델 정보 업데이트
                        saveAISettings();
                    });
                    // 초기 모델 정보 표시
                    updateModelInfo(qualityLevel);
                }

                // 번역 스타일 버튼 이벤트
                document.querySelectorAll('.style-btn').forEach(function (btn) {
                    btn.addEventListener('click', function () {
                        document.querySelectorAll('.style-btn').forEach(function (b) {
                            b.classList.remove('active');
                        });
                        btn.classList.add('active');
                        currentTranslationStyle = btn.dataset.style;
                        saveAISettings();
                    });
                });

                // 단어장 탭 이벤트
                document.querySelectorAll('.vocab-tab').forEach(function (tab) {
                    tab.addEventListener('click', function () {
                        switchVocabTab(tab.dataset.tab);
                    });
                });

                // 전문용어 입력 필드 엔터키 이벤트 (간소화)
                const terminologyInputEl = document.getElementById('terminologyInput');

                if (terminologyInputEl) {
                    terminologyInputEl.addEventListener('keypress', function (e) {
                        if (e.key === 'Enter') {
                            addTerminology();
                        }
                    });
                }

                // 단어장 입력 필드 엔터키 이벤트
                if (els.vocabularyOriginal) {
                    els.vocabularyOriginal.addEventListener('keypress', function (e) {
                        if (e.key === 'Enter' && els.vocabularyTranslation) {
                            els.vocabularyTranslation.focus();
                        }
                    });
                }

                if (els.vocabularyTranslation) {
                    els.vocabularyTranslation.addEventListener('keypress', function (e) {
                        if (e.key === 'Enter' && els.vocabularyDescription) {
                            els.vocabularyDescription.focus();
                        }
                    });
                }

                if (els.vocabularyDescription) {
                    els.vocabularyDescription.addEventListener('keypress', function (e) {
                        if (e.key === 'Enter') {
                            addVocabulary();
                        }
                    });
                }

                // 모달 외부 클릭 시 닫기
                if (els.wordDetailModal) {
                    els.wordDetailModal.addEventListener('click', function (e) {
                        if (e.target === els.wordDetailModal) {
                            closeWordDetail();
                        }
                    });
                }

                if (els.quizModal) {
                    els.quizModal.addEventListener('click', function (e) {
                        if (e.target === els.quizModal) {
                            closeQuiz();
                        }
                    });
                }

                if (els.practiceModal) {
                    els.practiceModal.addEventListener('click', function (e) {
                        if (e.target === els.practiceModal) {
                            closePractice();
                        }
                    });
                }

                // 오디오 컨텍스트 초기화
                ["touchstart", "click"].forEach(function (event) {
                    document.addEventListener(event, initAudioContext, { once: true });
                });

                console.log("✅ 번역기 v6.0 초기화 완료");

                // 🚀 스트리밍 설정 로드
                loadStreamingSettings();

                // 🔧 모든 모달 강제 숨김 처리
                // 🔧 모든 모달 강제 숨김 처리 (로그인 모달 제외)
                setTimeout(() => {
                    const modals = [
                        'practiceModal',
                        'wordDetailModal',
                        'quizModal',
                        // 'authModal' 제거 - 로그인 모달은 숨기지 않음
                        'dashboardModal',
                        'historyModal',
                        'vocabularyDropdown'
                    ];

                    modals.forEach(modalId => {
                        const modal = document.getElementById(modalId);
                        if (modal) {
                            modal.classList.remove('active');
                            // practiceModal만 특별 처리
                            if (modalId === 'practiceModal') {
                                modal.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important; position: fixed !important; top: -9999px !important; left: -9999px !important;';
                                modal.classList.remove('active');
                            }
                            console.log(`[Debug] ${modalId} 강제 숨김 처리`);
                        }
                    });

                    console.log("[Debug] 모달 숨김 처리 완료 (authModal 제외)");
                }, 100);

            } catch (error) {
                console.error('초기화 오류:', error);
                showStatus("⚠️ 시스템 초기화 중 오류 발생", "error");
            }
        });
    </script>
</body>

</html>