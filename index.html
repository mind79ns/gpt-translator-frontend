<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GPT ì–‘ë°©í–¥ ìŒì„± ë²ˆì—­ê¸° Pro v6.0 - AI ë¬¸ë§¥ ë²ˆì—­ ê³ ë„í™”</title>

    <!-- ğŸ“± PWA ì„¤ì • - ëª¨ë°”ì¼ ìµœì í™” -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#6366f1">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="GPT ë²ˆì—­ê¸°">

    <link rel="stylesheet" href="css/styles.css">
    <!-- ì„±ëŠ¥ ìµœì í™”: CSS ì™¸ë¶€ íŒŒì¼ë¡œ ë¶„ë¦¬í•˜ì—¬ ìºì‹± ê°€ëŠ¥ -->

    <!-- ğŸ”’ ì¤‘ë³µ íƒ­ ë°©ì§€ ìŠ¤í¬ë¦½íŠ¸ -->
    <script>
        (function () {
            const TAB_ID = Date.now() + '-' + Math.random().toString(36).substr(2, 9);
            const CHANNEL_NAME = 'gpt-translator-tab-channel';

            // BroadcastChannelë¡œ íƒ­ ê°„ í†µì‹ 
            if (typeof BroadcastChannel !== 'undefined') {
                const channel = new BroadcastChannel(CHANNEL_NAME);

                // ìƒˆ íƒ­ ì•Œë¦¼
                channel.postMessage({ type: 'NEW_TAB', tabId: TAB_ID });

                // ê¸°ì¡´ íƒ­ì—ì„œ ì‘ë‹µ ìˆ˜ì‹ 
                channel.onmessage = function (event) {
                    if (event.data.type === 'TAB_EXISTS' && event.data.tabId !== TAB_ID) {
                        // ê¸°ì¡´ íƒ­ì´ ìˆìœ¼ë©´ í˜„ì¬ íƒ­ ë‹«ê¸° ìœ ë„
                        if (confirm('âš ï¸ ì´ë¯¸ ë‹¤ë¥¸ íƒ­ì—ì„œ ë²ˆì—­ê¸°ê°€ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤.\n\nê¸°ì¡´ íƒ­ìœ¼ë¡œ ì´ë™í•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n(í™•ì¸: ì´ íƒ­ ë‹«ê¸°, ì·¨ì†Œ: ê³„ì† ì‚¬ìš©)')) {
                            window.close();
                            // ë‹«ê¸° ì‹¤íŒ¨ ì‹œ ì•ˆë‚´
                            setTimeout(function () {
                                document.body.innerHTML = '<div style="display:flex;align-items:center;justify-content:center;height:100vh;background:#1a1a2e;color:white;text-align:center;padding:20px;"><div><h2>âš ï¸ ì¤‘ë³µ íƒ­ ê°ì§€</h2><p>ë‹¤ë¥¸ íƒ­ì—ì„œ ì´ë¯¸ ë²ˆì—­ê¸°ê°€ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤.<br>í•´ë‹¹ íƒ­ìœ¼ë¡œ ì´ë™í•´ì£¼ì„¸ìš”.</p><button onclick="location.reload()" style="margin-top:20px;padding:10px 20px;background:#6366f1;color:white;border:none;border-radius:8px;cursor:pointer;">ì—¬ê¸°ì„œ ê³„ì† ì‚¬ìš©</button></div></div>';
                            }, 100);
                        }
                    }
                    if (event.data.type === 'NEW_TAB' && event.data.tabId !== TAB_ID) {
                        // ìƒˆ íƒ­ì—ê²Œ ì´ë¯¸ íƒ­ì´ ìˆìŒì„ ì•Œë¦¼
                        channel.postMessage({ type: 'TAB_EXISTS', tabId: TAB_ID });
                    }
                };

                // íƒ­ ë‹«í ë•Œ ì•Œë¦¼
                window.addEventListener('beforeunload', function () {
                    channel.postMessage({ type: 'TAB_CLOSED', tabId: TAB_ID });
                });
            }

            // ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ì¤‘ë³µ ë°©ì§€ë¥¼ ìœ„í•œ ì „ì—­ í”Œë˜ê·¸
            window.GPT_TRANSLATOR_TAB_ID = TAB_ID;
        })();
    </script>
</head>

<body>
    <div class="container">
        <div class="header">
            <!-- ì œëª©ì„ ë³„ë„ ì¤„ë¡œ -->
            <div class="header-title">
                <h1>GPT ë²ˆì—­ê¸° Pro v6.0</h1>
            </div>
            <!-- ì•„ì´ì½˜ë“¤ì„ ë³„ë„ ì¤„ë¡œ -->
            <div class="header-controls">
                <button class="ai-toggle" id="aiToggle" onclick="toggleAIModeWithAuth()" title="AI ë¬¸ë§¥ ë²ˆì—­">ğŸ§ </button>
                <button class="dashboard-toggle" onclick="toggleDashboard()">ğŸ“Š</button>
                <button class="settings-toggle" onclick="toggleSettings()">âš™ï¸</button>
                <button class="theme-toggle" onclick="toggleTheme()">ğŸŒ™</button>
                <button class="login-toggle" id="loginToggle" onclick="handleLoginClick()" title="ë¡œê·¸ì¸/íšŒì›ê°€ì…">ğŸ‘¤</button>
            </div>
            <div class="language-selector">
                <select id="sourceLangSelect">
                    <option value="Korean">í•œêµ­ì–´</option>
                    <option value="Vietnamese">ë² íŠ¸ë‚¨ì–´</option>
                    <option value="English">ì˜ì–´</option>
                </select>
                <button onclick="swapLanguages()">â‡„</button>
                <select id="targetLangSelect">
                    <option value="Vietnamese">ë² íŠ¸ë‚¨ì–´</option>
                    <option value="Korean">í•œêµ­ì–´</option>
                    <option value="English">ì˜ì–´</option>
                </select>
            </div>
            <span class="auto-detect-badge" id="autoDetectBadge"></span>
            <span class="ai-context-badge" id="aiContextBadge">ğŸ§  AI ë¬¸ë§¥ ë²ˆì—­</span>
        </div>

        <div class="content">
            <div class="settings-panel" id="settingsPanel">
                <div class="settings-title"><span>âš™ï¸ ì„¤ì •</span><button class="settings-close"
                        onclick="toggleSettings()">Ã—</button></div>

                <!-- AI ë¬¸ë§¥ ë²ˆì—­ ì„¤ì • ì„¹ì…˜ -->
                <div class="ai-settings-section" id="aiSettingsSection">
                    <div class="ai-settings-title">ğŸ§  AI ë¬¸ë§¥ ë²ˆì—­ ê³ ë„í™”</div>

                    <!-- ğŸ¤– AI ëª¨ë¸ ì„ íƒ (í•˜ì´ë¸Œë¦¬ë“œ ëª¨ë“œ) -->
                    <div class="setting-item">
                        <label class="setting-label">ğŸ¤– AI ëª¨ë¸ ì„ íƒ<small>ìë™: í…ìŠ¤íŠ¸ ê¸¸ì´ì— ë”°ë¼ ìµœì  ëª¨ë¸ ì„ íƒ</small></label>
                        <div class="setting-control">
                            <select id="aiModelSelect" onchange="updateAIModelSelection()">
                                <option value="auto">ğŸ”„ ìë™ ìµœì í™” (ì¶”ì²œ)</option>
                                <option value="gpt-4o">ğŸŸ¢ GPT-4o (ìµœê³  í’ˆì§ˆ)</option>
                                <option value="gpt-4o-mini">ğŸŸ¢ GPT-4o Mini (ë¹ ë¦„)</option>
                                <option value="gemini-1.5-flash">ğŸ”µ Gemini 1.5 Flash (ì´ˆê³ ì†/ì•ˆì •)</option>
                            </select>
                        </div>
                    </div>
                    <div class="model-indicator" id="modelIndicator"
                        style="font-size: 11px; color: var(--text-secondary); padding: 5px 0; text-align: center;">
                        í˜„ì¬ ëª¨ë“œ: <strong>ìë™ ìµœì í™”</strong> - í…ìŠ¤íŠ¸ ê¸¸ì´ì— ë”°ë¼ ìµœì  ëª¨ë¸ ì„ íƒ
                    </div>

                    <!-- ğŸš€ ìŠ¤íŠ¸ë¦¬ë° ëª¨ë“œ í† ê¸€ - ë¹„í™œì„±í™” (Netlify í‘œì¤€ í•¨ìˆ˜ëŠ” ì‹¤ì‹œê°„ SSE ë¯¸ì§€ì›)
                    <div class="setting-item">
                        <label class="setting-label">ğŸš€ ìŠ¤íŠ¸ë¦¬ë° ëª¨ë“œ<small>ë²ˆì—­ ê²°ê³¼ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ í‘œì‹œ (ì‹¤í—˜ì )</small></label>
                        <div class="setting-control">
                            <label class="toggle-switch">
                                <input type="checkbox" id="streamingModeToggle" onchange="toggleStreamingMode()">
                                <span class="toggle-slider"></span>
                            </label>
                            <span id="streamingModeStatus"
                                style="font-size: 11px; margin-left: 8px; color: var(--text-secondary);">ë¹„í™œì„±í™”</span>
                        </div>
                    </div>
                    -->

                    <!-- ğŸ­ ì „ë¬¸ ë¶„ì•¼ ì„ íƒ -->
                    <div class="setting-item">
                        <label class="setting-label">ğŸ­ ì „ë¬¸ ë¶„ì•¼<small>ì œì¡° ìë™í™”: ì „ë¬¸ ìš©ì–´ ìë™ ì ìš©</small></label>
                        <div class="setting-control">
                            <select id="domainSelect" onchange="updateDomainSelection()">
                                <option value="general">ğŸ“ ì¼ë°˜</option>
                                <option value="manufacturing">ğŸ­ ì œì¡° ìë™í™”</option>
                            </select>
                        </div>
                    </div>

                    <div class="setting-item quality-setting-wrapper">
                        <div class="quality-setting-grid">
                            <label class="setting-label">ë²ˆì—­ í’ˆì§ˆ vs ì†ë„<small>ë†’ì„ìˆ˜ë¡ ì •í™•í•˜ì§€ë§Œ ëŠë¦¼</small></label>
                            <div class="setting-control">
                                <input type="range" class="quality-slider" id="qualitySlider" min="1" max="5" value="3"
                                    step="1">
                            </div>
                        </div>
                        <div class="quality-labels">
                            <span>ë¹ ë¦„</span><span>ê· í˜•</span><span>ì •í™•</span>
                        </div>
                        <!-- ì˜µì…˜ 1: ì‹¤ì‹œê°„ ëª¨ë¸ ì •ë³´ í‘œì‹œ -->
                        <div class="model-info-display" id="modelInfoDisplay">
                            <span class="model-name">ëª¨ë¸: gpt-4o</span>
                            <span class="model-cost">ë¹„ìš©: ì¤‘ê°„</span>
                            <span class="model-tokens">í† í°: 1500</span>
                        </div>
                    </div>

                    <div class="setting-item">
                        <label class="setting-label">ë²ˆì—­ ìŠ¤íƒ€ì¼</label>
                        <div class="style-buttons">
                            <div class="style-btn active" data-style="balanced">ê· í˜•ì¡íŒ</div>
                            <div class="style-btn" data-style="formal">ê²©ì‹ì²´</div>
                            <div class="style-btn" data-style="casual">ì¹œê·¼ì²´</div>
                            <div class="style-btn" data-style="literal">ì§ì—­ì²´</div>
                        </div>
                    </div>

                    <div class="setting-item">
                        <label class="setting-label">ğŸ”§ ì „ë¬¸ìš©ì–´ ì‚¬ì „<small>ì¼ê´€ëœ ë²ˆì—­ì„ ìœ„í•œ ìš©ì–´ì§‘ ê´€ë¦¬</small></label>
                        <div class="terminology-section">
                            <div class="terminology-input-group">
                                <input type="text" class="terminology-input-single" id="terminologyInput"
                                    placeholder="ìš©ì–´ ë“±ë¡: AI | ì¸ê³µì§€ëŠ¥">
                                <button onclick="addTerminology()" class="terminology-add-btn">â•</button>
                            </div>
                            <div class="terminology-list" id="terminologyList"></div>
                        </div>
                    </div>
                </div>

                <div class="settings-grid">
                    <div class="setting-item">
                        <label class="setting-label" for="ttsEngineMode">ğŸ”Š TTS ì—”ì§„ ì„ íƒ<small>Google: ë¬´ë£Œ/ì¼ë°˜ | OpenAI:
                                ìœ ë£Œ/ê³ í’ˆì§ˆ</small></label>
                        <div class="setting-control"><select id="ttsEngineMode">
                                <option value="auto">ğŸ¤– ìë™ ì„ íƒ (ì¶”ì²œ)</option>
                                <option value="google">ğŸ”µ Google TTS</option>
                                <option value="openai">ğŸŸ¢ OpenAI TTS</option>
                                <option value="smart">ğŸ’¡ ìŠ¤ë§ˆíŠ¸ ëª¨ë“œ</option>
                            </select></div>
                    </div>
                    <div class="setting-item" id="autoModeSettings">
                        <label class="setting-label" for="autoThreshold">ìë™ ëª¨ë“œ ì„ê³„ê°’<small>ì´ ê¸€ì ìˆ˜ ì´í•˜ëŠ” Google TTS
                                ì‚¬ìš©</small></label>
                        <div class="setting-control"><input type="range" id="autoThreshold" min="10" max="200"
                                value="50" step="10"><span class="setting-value" id="thresholdValue">50ì</span></div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label" for="voiceSelect">ìŒì„± ì„ íƒ (OpenAI)</label>
                        <div class="setting-control"><select id="voiceSelect">
                                <option value="nova">Nova (ì—¬ì„±/ì„ ëª…)</option>
                                <option value="shimmer">Shimmer (ì—¬ì„±/ë¶€ë“œëŸ¬ì›€)</option>
                                <option value="alloy">Alloy (ë‚¨ì„±/ì°¨ë¶„)</option>
                                <option value="echo">Echo (ë‚¨ì„±/ê¹ŠìŒ)</option>
                                <option value="fable">Fable (ë‚¨ì„±/í‘œí˜„ë ¥)</option>
                                <option value="onyx">Onyx (ë‚¨ì„±/ì €ìŒ)</option>
                            </select></div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label" for="googleVoiceSelect">ìŒì„± ì„ íƒ (Google)</label>
                        <div class="setting-control"><select id="googleVoiceSelect">
                                <option value="vi-VN-Standard-A">ğŸ‡»ğŸ‡³ Standard-A (ì—¬)</option>
                                <option value="vi-VN-Standard-B">ğŸ‡»ğŸ‡³ Standard-B (ë‚¨)</option>
                                <option value="vi-VN-Standard-C">ğŸ‡»ğŸ‡³ Standard-C (ì—¬)</option>
                                <option value="vi-VN-Standard-D">ğŸ‡»ğŸ‡³ Standard-D (ë‚¨)</option>
                                <option value="ko-KR-Standard-A">ğŸ‡°ğŸ‡· Standard-A (ì—¬)</option>
                                <option value="ko-KR-Standard-B">ğŸ‡°ğŸ‡· Standard-B (ì—¬)</option>
                                <option value="ko-KR-Standard-C">ğŸ‡°ğŸ‡· Standard-C (ë‚¨)</option>
                                <option value="ko-KR-Standard-D">ğŸ‡°ğŸ‡· Standard-D (ë‚¨)</option>
                            </select></div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label" for="volumeControl">ë³¼ë¥¨</label>
                        <div class="setting-control"><input type="range" id="volumeControl" min="0.1" max="1"
                                value="0.8" step="0.1"><span class="setting-value" id="volumeValue">80%</span></div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">ë°œìŒ ë„ìš°ë¯¸<small>OFF ì‹œ API ìš”ì²­ ë¹„ìš©ì´ ì ˆê°ë©ë‹ˆë‹¤.</small></label>
                        <div class="setting-control">
                            <div class="toggle-switch" id="pronunciationToggle"></div>
                        </div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">ğŸ’¾ ìºì‹œ ì„¤ì •<small>ë°˜ë³µ ìš”ì²­ ì‹œ ë¹„ìš© ì ˆê° ë° ì†ë„ í–¥ìƒ</small></label>
                        <div class="setting-control"><button onclick="clearAllCache()"
                                style="padding: 6px 12px; font-size: 11px; background-color: var(--error); border: none; border-radius: 5px; color: white;">ğŸ—‘ï¸
                                ìºì‹œ ì´ˆê¸°í™”</button></div>
                    </div>
                </div>
            </div>

            <div class="recent-plays collapsed" id="recentPlays">
                <div class="recent-plays-title"><span>ğŸ”„ ìµœê·¼ ì¬ìƒ</span><button class="recent-plays-toggle"
                        onclick="toggleRecentPlays()" id="recentPlaysToggleBtn">í¼ì¹˜ê¸°</button></div>
                <div class="recent-play-list" id="recentPlayList" style="display: none;"></div>
            </div>

            <div class="mode-selector">
                <div class="mode-btn active" id="normalModeBtn" onclick="switchToNormalMode()">ğŸ“ ì¼ë°˜ ë²ˆì—­</div>
                <div class="mode-btn" id="conversationModeBtn" onclick="switchToConversationMode()">ğŸ’¬ ëŒ€í™” ëª¨ë“œ</div>
            </div>

            <div class="conversation-mode" id="conversationMode">
                <div class="speaker-info">
                    <div class="speaker-card speaker-a" id="speakerCardA">
                        <div class="speaker-title">ğŸ™‹â€â™‚ï¸ í™”ì A</div>
                        <div class="speaker-lang" id="speakerLangA"></div>
                    </div>
                    <div class="speaker-card speaker-b" id="speakerCardB">
                        <div class="speaker-title">ğŸ™‹â€â™€ï¸ í™”ì B</div>
                        <div class="speaker-lang" id="speakerLangB"></div>
                    </div>
                </div>
                <div class="conversation-controls">
                    <button class="conv-btn conv-btn-start" id="startConversationBtn" onclick="startConversation()">ğŸ¤
                        ì‹œì‘</button>
                    <button class="conv-btn conv-btn-stop" id="stopConversationBtn" onclick="stopConversation()"
                        disabled>â¹ï¸ ì¢…ë£Œ</button>
                    <button class="conv-btn conv-btn-clear" onclick="clearConversation()">ğŸ—‘ï¸ ì§€ìš°ê¸°</button>
                </div>
                <div class="conversation-history" id="conversationHistory"></div>
            </div>

            <div class="normal-mode" id="normalMode">
                <div class="input-wrapper">
                    <textarea id="inputText" placeholder="ë²ˆì—­í•  í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”..."></textarea>
                    <div class="input-actions">
                        <button class="input-action-btn" onclick="copyInputText()">ë³µì‚¬</button>
                        <button class="input-action-btn" onclick="pasteFromClipboard()">ë¶™ì—¬ë„£ê¸°</button>
                    </div>
                </div>
                <div class="controls">
                    <button class="btn-translate" id="translateBtn" onclick="handleTranslate()"><span>ğŸ“</span> <span
                            id="translateBtnText">ë²ˆì—­í•˜ê¸°</span></button>
                    <button class="btn-voice" id="voiceBtn" onclick="handleVoiceTranslate()"><span>ğŸ¤</span> ìŒì„±
                        ë²ˆì—­</button>
                    <button class="btn-clear" onclick="clearAll()"><span>ğŸ—‘ï¸</span> ëª¨ë‘ ì§€ìš°ê¸°</button>
                    <button class="btn-history" onclick="showHistory()"><span>ğŸ“œ</span> ê¸°ë¡ ë³´ê¸°</button>
                </div>
                <div class="result-section">
                    <div class="result-header">
                        <span class="result-label">ë²ˆì—­ ê²°ê³¼<span id="cacheIndicator" class="cache-indicator"
                                style="display: none;">ìºì‹œë¨</span><span id="aiIndicator" class="engine-indicator ai"
                                style="display: none;">AI</span><span id="feedbackIndicator" class="engine-indicator"
                                style="display: none; background: var(--success);">ğŸ“</span></span>
                        <div class="result-actions">
                            <button class="btn-action" onclick="copyTranslation()" id="copyBtn" disabled>ğŸ“‹ ë³µì‚¬</button>
                            <button class="btn-action" id="speakBtn" onclick="handleSpeak()" disabled>ğŸ”Š ë“£ê¸°<span
                                    id="engineIndicator" class="engine-indicator"
                                    style="display: none;"></span></button>
                            <!-- ğŸ“ í”¼ë“œë°± í¸ì§‘ ë²„íŠ¼ -->
                            <button class="btn-action" id="editFeedbackBtn" onclick="enableTranslationEdit()"
                                style="display: none;">âœï¸ ìˆ˜ì •</button>
                            <button class="btn-action" id="saveFeedbackBtn" onclick="saveInlineTranslationFeedback()"
                                style="display: none; background: var(--success);">ğŸ’¾ ì €ì¥</button>
                            <button class="btn-action" id="cancelFeedbackBtn" onclick="cancelTranslationEdit()"
                                style="display: none; background: var(--error);">âœ–ï¸</button>
                        </div>
                    </div>
                    <div id="translation" contenteditable="false"></div>
                    <!-- ğŸ”„ ì—­ë²ˆì—­ ê²€ì¦ ì„¹ì…˜ -->
                    <div class="verification-section" id="verificationSection" style="display: none;">
                        <button class="btn-verify" onclick="verifyTranslation()">ğŸ”„ ì—­ë²ˆì—­ ê²€ì¦</button>
                        <div id="verificationResult" class="verification-result" style="display: none;"></div>
                    </div>
                </div>
                <div class="pronunciation-section" id="pronunciationSection">
                    <div class="pronunciation-label" onclick="togglePronunciationView()">ë°œìŒ ë„ìš°ë¯¸ <span
                            id="pronToggleIcon">â–¼</span></div>
                    <div id="pronunciation-content"></div>
                </div>
                <div class="translation-stats">
                    <div class="stat-item"><strong id="todayTranslations">0</strong><span>ì˜¤ëŠ˜ ë²ˆì—­</span></div>
                    <div class="stat-item"><strong id="totalTranslations">0</strong><span>ì´ ë²ˆì—­</span></div>
                    <div class="stat-item"><strong id="cacheHitRate">0%</strong><span>ìºì‹œ ì ì¤‘ë¥ </span></div>
                </div>
            </div>

            <div class="status" id="status"></div>
        </div>
    </div>


    <!-- ğŸ”§ ìˆ˜ì •: ëŒ€ì‹œë³´ë“œ ëª¨ë‹¬ì— ì›” ë¹„ìš© ì¹´ë“œ ì¶”ê°€ -->
    <div class="modal" id="dashboardModal">
        <div class="modal-content-wrapper">
            <div class="modal-header">
                <span class="modal-title">ğŸ“Š ëŒ€ì‹œë³´ë“œ</span>
                <button class="modal-close" onclick="toggleDashboard()">Ã—</button>
            </div>
            <div class="usage-cards">
                <div class="usage-card">
                    <div class="usage-card-value" id="todayUsage">0</div>
                    <div class="usage-card-label">ì˜¤ëŠ˜ ë²ˆì—­</div>
                </div>
                <div class="usage-card">
                    <div class="usage-card-value" id="monthUsage">0</div>
                    <div class="usage-card-label">ì´ë²ˆ ë‹¬</div>
                </div>
                <div class="usage-card">
                    <div class="usage-card-value" id="todayCost">$0.00</div>
                    <div class="usage-card-label">ì˜¤ëŠ˜ ë¹„ìš©</div>
                </div>
                <!-- â• ìƒˆë¡œ ì¶”ê°€: í•´ë‹¹ ì›” ë¹„ìš© ì¹´ë“œ -->
                <div class="usage-card">
                    <div class="usage-card-value" id="monthCost">$0.00</div>
                    <div class="usage-card-label">ì´ë²ˆ ë‹¬ ë¹„ìš©</div>
                </div>
                <div class="usage-card">
                    <div class="usage-card-value" id="savedCost">$0.00</div>
                    <div class="usage-card-label">ì ˆê° ë¹„ìš©</div>
                </div>
            </div>
            <div class="chart-container">
                <div class="chart-title">ğŸ“ˆ 7ì¼ ì‚¬ìš©ëŸ‰</div>
                <div class="simple-bar-chart" id="weeklyChart"></div>
            </div>
            <!-- â• ìƒˆë¡œ ì¶”ê°€: ì›”ë³„ ë¹„ìš© ì°¨íŠ¸ -->
            <div class="chart-container">
                <div class="chart-title">ğŸ’° ì›”ë³„ ë¹„ìš© ì¶”ì´ (ìµœê·¼ 6ê°œì›”)</div>
                <div class="simple-bar-chart" id="monthlyChart"></div>
            </div>
            <div class="limit-settings">
                <div class="limit-title">âš ï¸ API í•œë„ ê´€ë¦¬</div>
                <div class="limit-item">
                    <span class="limit-label">ì¼ì¼ ì˜ˆì‚° ($)</span>
                    <input type="number" class="limit-input" id="dailyBudget" value="1.00" step="0.10">
                </div>
                <div class="limit-item">
                    <span class="limit-label">ì›”ê°„ ì˜ˆì‚° ($)</span>
                    <input type="number" class="limit-input" id="monthlyBudget" value="30.00" step="1.00">
                </div>
                <div class="limit-progress">
                    <div class="limit-progress-bar" id="budgetProgress"></div>
                </div>
                <div class="limit-percentage" id="budgetPercentage">0% ì‚¬ìš©</div>
                <div class="limit-item" style="margin-top: 15px;">
                    <span class="limit-label">í•œë„ ë„ë‹¬ ì‹œ</span>
                    <select id="limitAction" style="width: 150px; padding: 5px; border-radius: 5px; font-size: 12px;">
                        <option value="switch">Googleë¡œ ì „í™˜</option>
                        <option value="warn">ê²½ê³ ë§Œ</option>
                        <option value="block">ì°¨ë‹¨</option>
                    </select>
                </div>
            </div>
        </div>
    </div>

    <div class="modal" id="historyModal">
        <div class="modal-content-wrapper">
            <div class="modal-header"><span class="modal-title">ğŸ“œ ë²ˆì—­ ê¸°ë¡</span><button class="modal-close"
                    onclick="hideHistory()">Ã—</button></div>
            <div id="historyList" style="max-height: 400px; overflow-y: auto;"></div><button onclick="clearHistory()"
                style="width: 100%; margin-top: 15px; background: var(--error); color: white; border: none; border-radius: 5px; padding: 8px;">ê¸°ë¡
                ëª¨ë‘ ì‚­ì œ</button>
        </div>
    </div>

    <!-- ğŸ” ë¡œê·¸ì¸/íšŒì›ê°€ì… ëª¨ë‹¬ -->
    <div class="auth-modal" id="authModal">
        <div class="auth-content">
            <div class="auth-header">
                <div class="auth-tabs">
                    <button class="auth-tab active" data-tab="login">ğŸ”‘ ë¡œê·¸ì¸</button>
                    <button class="auth-tab" data-tab="register">ğŸ“ íšŒì›ê°€ì…</button>
                </div>
                <button class="auth-close" onclick="toggleAuth()">Ã—</button>
            </div>

            <div class="auth-form active" id="loginForm">
                <div class="auth-form-title">GPT ë²ˆì—­ê¸° Pro ë¡œê·¸ì¸</div>
                <div class="auth-input-group">
                    <input type="email" id="loginEmail" placeholder="ì´ë©”ì¼ ì£¼ì†Œ" required>
                    <input type="password" id="loginPassword" placeholder="ë¹„ë°€ë²ˆí˜¸" required>
                </div>
                <button class="auth-btn primary" onclick="handleLogin()">ğŸ”‘ ë¡œê·¸ì¸</button>
                <div class="auth-divider">ë˜ëŠ”</div>
                <button class="auth-btn guest" onclick="continueAsGuest()">ğŸ¯ ê²ŒìŠ¤íŠ¸ë¡œ ê³„ì†í•˜ê¸°</button>
                <div class="auth-links">
                    <a href="#" onclick="event.preventDefault(); switchAuthTab('forgot');">ë¹„ë°€ë²ˆí˜¸ë¥¼ ìŠìœ¼ì…¨ë‚˜ìš”?</a>
                </div>
            </div>

            <div class="auth-form" id="registerForm">
                <div class="auth-form-title">ìƒˆ ê³„ì • ë§Œë“¤ê¸°</div>
                <div class="auth-input-group">
                    <input type="text" id="registerName" placeholder="ì´ë¦„ (ì„ íƒì‚¬í•­)">
                    <input type="email" id="registerEmail" placeholder="ì´ë©”ì¼ ì£¼ì†Œ" required>
                    <input type="password" id="registerPassword" placeholder="ë¹„ë°€ë²ˆí˜¸ (8ì ì´ìƒ)" required>
                    <input type="password" id="registerPasswordConfirm" placeholder="ë¹„ë°€ë²ˆí˜¸ í™•ì¸" required>
                </div>
                <div class="auth-agreement">
                    <label class="auth-checkbox">
                        <input type="checkbox" id="agreeTerms" required>
                        <span>ì„œë¹„ìŠ¤ ì´ìš©ì•½ê´€ ë° ê°œì¸ì •ë³´ì²˜ë¦¬ë°©ì¹¨ì— ë™ì˜í•©ë‹ˆë‹¤</span>
                    </label>
                </div>
                <button class="auth-btn primary" onclick="handleRegister()">ğŸ“ íšŒì›ê°€ì…</button>
                <div class="auth-links">
                    <a href="#" onclick="event.preventDefault(); switchAuthTab('login');">â† ë¡œê·¸ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°</a>
                </div>
            </div>

            <div class="auth-form" id="forgotForm">
                <div class="auth-form-title">ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì •</div>
                <div class="auth-input-group">
                    <input type="email" id="forgotEmail" placeholder="ê°€ì…í•œ ì´ë©”ì¼ ì£¼ì†Œ" required>
                </div>
                <button class="auth-btn primary" onclick="handleForgotPassword()">ğŸ“§ ì¬ì„¤ì • ë§í¬ ë³´ë‚´ê¸°</button>
                <div class="auth-links">
                    <a href="#" onclick="event.preventDefault(); switchAuthTab('login');">â† ë¡œê·¸ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°</a>
                </div>
            </div>
        </div>
    </div>

    <div class="auth-info">
    </div>
    </div>
    <div class="auth-info">
        <small>â€¢ ê°œì¸ API í‚¤ ë“±ë¡ìœ¼ë¡œ ë¬´ì œí•œ ë²ˆì—­</small>
        <small>â€¢ ì‚¬ìš©ëŸ‰ ì¶”ì  ë° ë¶„ì„</small>
        <small>â€¢ ê³ ê¸‰ ë‹¨ì–´ì¥ ë° í•™ìŠµ ê¸°ë¡ ì €ì¥</small>
    </div>
    </div>

    <!-- ë¹„ë°€ë²ˆí˜¸ ì°¾ê¸° í¼ -->
    <div class="auth-form" id="forgotForm" style="display: none;">
        <div class="auth-form-title">ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì •</div>
        <div class="auth-input-group">
            <input type="email" id="forgotEmail" placeholder="ê°€ì…í•œ ì´ë©”ì¼ ì£¼ì†Œ" required>
        </div>
        <button class="auth-btn primary" onclick="handleForgotPassword()">ğŸ“§ ì¬ì„¤ì • ë§í¬ ë³´ë‚´ê¸°</button>
        <div class="auth-links">
            <a href="#" onclick="showLoginForm()">â† ë¡œê·¸ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°</a>
        </div>
    </div>
    </div>
    </div>

    <!-- ğŸ”§ API í‚¤ ê´€ë¦¬ ëª¨ë‹¬ -->
    <div class="api-keys-modal" id="apiKeysModal">
        <div class="api-keys-content">
            <div class="api-keys-header">
                <span class="api-keys-title">ğŸ”‘ API í‚¤ ê´€ë¦¬</span>
                <button class="api-keys-close" onclick="toggleApiKeys()">Ã—</button>
            </div>
            <div class="api-keys-body">
                <div class="api-key-section">
                    <div class="api-key-title">ğŸ¤– OpenAI API í‚¤</div>
                    <div class="api-key-description">ë²ˆì—­ ë° TTS ê¸°ëŠ¥ì„ ìœ„í•œ OpenAI API í‚¤ë¥¼ ë“±ë¡í•˜ì„¸ìš”</div>
                    <div class="api-key-input-group">
                        <input type="password" id="openaiApiKey" placeholder="sk-..." maxlength="200">
                        <button class="api-key-btn test" onclick="testOpenAIKey()">í…ŒìŠ¤íŠ¸</button>
                        <button class="api-key-btn save" onclick="saveOpenAIKey()">ì €ì¥</button>
                    </div>
                    <div class="api-key-status" id="openaiKeyStatus"></div>
                </div>

                <div class="api-key-section">
                    <div class="api-key-title">ğŸ¤ Google TTS API í‚¤</div>
                    <div class="api-key-description">ê³ í’ˆì§ˆ ìŒì„± í•©ì„±ì„ ìœ„í•œ Google Cloud API í‚¤ (ì„ íƒì‚¬í•­)</div>
                    <div class="api-key-input-group">
                        <input type="password" id="googleApiKey" placeholder="AIza..." maxlength="200">
                        <button class="api-key-btn test" onclick="testGoogleKey()">í…ŒìŠ¤íŠ¸</button>
                        <button class="api-key-btn save" onclick="saveGoogleKey()">ì €ì¥</button>
                    </div>
                    <div class="api-key-status" id="googleKeyStatus"></div>
                </div>

                <div class="api-key-info">
                    <div class="api-key-info-title">ğŸ’¡ API í‚¤ ì‚¬ìš© í˜œíƒ</div>
                    <ul>
                        <li>âœ… ë¬´ì œí•œ ë²ˆì—­ ë° TTS ì‚¬ìš©</li>
                        <li>âœ… ê°œì¸ ì‚¬ìš©ëŸ‰ ë° ë¹„ìš© ì¶”ì </li>
                        <li>âœ… ë” ë¹ ë¥¸ ì‘ë‹µ ì†ë„</li>
                        <li>âœ… í”„ë¦¬ë¯¸ì—„ ê¸°ëŠ¥ ì´ìš©</li>
                    </ul>
                    <div class="api-key-help">
                        <a href="https://platform.openai.com/api-keys" target="_blank">OpenAI API í‚¤ ë°œê¸‰ë°›ê¸° â†’</a>
                        <br>
                        <a href="https://console.cloud.google.com/" target="_blank">Google Cloud API í‚¤ ë°œê¸‰ë°›ê¸° â†’</a>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========== localStorage ë¹„ë™ê¸° ë˜í¼ (ì„±ëŠ¥ ìµœì í™”) ==========
        // UI ë¸”ë¡œí‚¹ ë°©ì§€ë¥¼ ìœ„í•œ ë¹„ë™ê¸° ìŠ¤í† ë¦¬ì§€ ìœ í‹¸ë¦¬í‹°

        const AsyncStorage = {
            // ì½ê¸° (Promise ê¸°ë°˜)
            async getItem(key) {
                return new Promise((resolve) => {
                    // requestIdleCallbackìœ¼ë¡œ ìœ íœ´ ì‹œê°„ì— ì‹¤í–‰
                    if ('requestIdleCallback' in window) {
                        requestIdleCallback(() => {
                            resolve(localStorage.getItem(key));
                        });
                    } else {
                        // Fallback: setTimeoutìœ¼ë¡œ ë§ˆì´í¬ë¡œíƒœìŠ¤í¬ íì— ì¶”ê°€
                        setTimeout(() => {
                            resolve(localStorage.getItem(key));
                        }, 0);
                    }
                });
            },

            // ì“°ê¸° (Promise ê¸°ë°˜)
            async setItem(key, value) {
                return new Promise((resolve) => {
                    if ('requestIdleCallback' in window) {
                        requestIdleCallback(() => {
                            localStorage.setItem(key, value);
                            resolve();
                        });
                    } else {
                        setTimeout(() => {
                            localStorage.setItem(key, value);
                            resolve();
                        }, 0);
                    }
                });
            },

            // ì‚­ì œ (Promise ê¸°ë°˜)
            async removeItem(key) {
                return new Promise((resolve) => {
                    if ('requestIdleCallback' in window) {
                        requestIdleCallback(() => {
                            localStorage.removeItem(key);
                            resolve();
                        });
                    } else {
                        setTimeout(() => {
                            localStorage.removeItem(key);
                            resolve();
                        }, 0);
                    }
                });
            },

            // ë™ê¸°ì‹ ì½ê¸° (ì¦‰ì‹œ í•„ìš”í•œ ê²½ìš°ë§Œ ì‚¬ìš©)
            getItemSync(key) {
                return localStorage.getItem(key);
            },

            // ë™ê¸°ì‹ ì“°ê¸° (ì¦‰ì‹œ í•„ìš”í•œ ê²½ìš°ë§Œ ì‚¬ìš©)
            setItemSync(key, value) {
                localStorage.setItem(key, value);
            }
        };

        // ë””ë°”ìš´ìŠ¤ ìœ í‹¸ë¦¬í‹° (ë¹ˆë²ˆí•œ ì €ì¥ ë°©ì§€)
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // ===================================================
        // GPT ì–‘ë°©í–¥ ìŒì„± ë²ˆì—­ê¸° Pro v6.0 - AI ë¬¸ë§¥ ë²ˆì—­ ê³ ë„í™”
        // ===================================================
        const API_URL = 'https://knstranslator.netlify.app/.netlify/functions/translate';
        const AUTH_API_URL = 'https://knstranslator.netlify.app/.netlify/functions/auth'; // ğŸ”§ ì¶”ê°€: ì¸ì¦ API URL

        // ğŸ”„ ë„¤íŠ¸ì›Œí¬ ì¬ì‹œë„ ìœ í‹¸ë¦¬í‹° (ë¶ˆì•ˆì •í•œ ë„¤íŠ¸ì›Œí¬ ëŒ€ì‘)
        async function fetchWithRetry(url, options, maxRetries = 3) {
            // ì˜¤í”„ë¼ì¸ ìƒíƒœ ì²´í¬
            if (!navigator.onLine) {
                throw new Error('ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì´ ì—†ìŠµë‹ˆë‹¤. ì¸í„°ë„· ì—°ê²°ì„ í™•ì¸í•´ì£¼ì„¸ìš”.');
            }

            let lastError;
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30ì´ˆ íƒ€ì„ì•„ì›ƒ

                    const response = await fetch(url, {
                        ...options,
                        signal: controller.signal
                    });

                    clearTimeout(timeoutId);

                    if (!response.ok && response.status >= 500) {
                        throw new Error(`ì„œë²„ ì˜¤ë¥˜ (${response.status})`);
                    }

                    return response;
                } catch (error) {
                    lastError = error;

                    // ì·¨ì†Œëœ ìš”ì²­ì€ ì¬ì‹œë„í•˜ì§€ ì•ŠìŒ
                    if (error.name === 'AbortError') {
                        throw new Error('ìš”ì²­ ì‹œê°„ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤. ë„¤íŠ¸ì›Œí¬ ìƒíƒœë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.');
                    }

                    // ë§ˆì§€ë§‰ ì‹œë„ê°€ ì•„ë‹ˆë©´ ëŒ€ê¸° í›„ ì¬ì‹œë„
                    if (attempt < maxRetries) {
                        const delay = Math.pow(2, attempt - 1) * 1000; // 1ì´ˆ, 2ì´ˆ, 4ì´ˆ
                        console.log(`[Network] ì¬ì‹œë„ ${attempt}/${maxRetries}, ${delay}ms í›„...`);
                        showStatus(`â³ ë„¤íŠ¸ì›Œí¬ ì¬ì‹œë„ ì¤‘... (${attempt}/${maxRetries})`, 'warning');
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
            }

            // ëª¨ë“  ì¬ì‹œë„ ì‹¤íŒ¨
            if (lastError.message.includes('fetch')) {
                throw new Error('ì„œë²„ì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë„¤íŠ¸ì›Œí¬ ìƒíƒœë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.');
            }
            throw lastError;
        }

        // ğŸ” ì‚¬ìš©ì ì¸ì¦ ì‹œìŠ¤í…œ
        let currentUser = null;
        let authToken = null;

        // ğŸ” ì¸ì¦ ìƒíƒœ ê´€ë¦¬ (ê°œì„ )
        async function initAuthSystem() {
            console.log('[Auth] ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹œì‘');

            // ì €ì¥ëœ í† í° í™•ì¸
            const savedToken = localStorage.getItem('authToken');
            const savedUser = localStorage.getItem('currentUser');

            if (savedToken && savedUser) {
                try {
                    // ğŸ”§ ê°œì„ : ì‹¤ì œ í† í° ê²€ì¦
                    const isValidToken = await verifyStoredToken(savedToken);

                    if (isValidToken) {
                        authToken = savedToken;
                        currentUser = JSON.parse(savedUser);
                        updateAuthUI(true);

                        console.log('[Auth] ì‚¬ìš©ì ì„¸ì…˜ ë³µì› ì„±ê³µ:', currentUser.email);

                        // ğŸ”§ ì¶”ê°€: ì‚¬ìš©ì ë°ì´í„° ìƒˆë¡œê³ ì¹¨
                        await refreshUserData();

                        showStatus(`ğŸ‘‹ ${currentUser.displayName || currentUser.email}ë‹˜ í™˜ì˜í•©ë‹ˆë‹¤!`, "success");
                    } else {
                        console.log('[Auth] ì €ì¥ëœ í† í°ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤');
                        clearAuthData();
                        updateAuthUI(false);
                        showStatus("ì„¸ì…˜ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”", "warning");
                    }
                } catch (error) {
                    console.error('[Auth] ì„¸ì…˜ ë³µì› ì‹¤íŒ¨:', error);
                    clearAuthData();
                    updateAuthUI(false);
                }
            } else {
                console.log('[Auth] ì €ì¥ëœ ì¸ì¦ ì •ë³´ ì—†ìŒ - ê²ŒìŠ¤íŠ¸ ëª¨ë“œ');
                updateAuthUI(false);
            }

            // ğŸ”§ ì¶”ê°€: ì¸ì¦ ê´€ë ¨ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
            setupAuthEventListeners();
        }

        // ğŸ” ì €ì¥ëœ í† í° ê²€ì¦
        async function verifyStoredToken(token) {
            try {
                const response = await fetch(AUTH_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        action: 'verify-token'
                    })
                });

                const result = await response.json();
                return result.success || false;

            } catch (error) {
                console.error('[Auth] í† í° ê²€ì¦ ì˜¤ë¥˜:', error);
                return false;
            }
        }

        // ğŸ” ì‚¬ìš©ì ë°ì´í„° ìƒˆë¡œê³ ì¹¨
        async function refreshUserData() {
            if (!currentUser || !authToken) return;

            try {
                console.log('[Auth] ì‚¬ìš©ì ë°ì´í„° ìƒˆë¡œê³ ì¹¨ ì¤‘...');

                // ğŸ”§ API í‚¤ ìƒíƒœ í™•ì¸
                const apiKeysResponse = await fetch(AUTH_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({
                        action: 'get-api-keys'
                    })
                });

                if (apiKeysResponse.ok) {
                    const apiKeysData = await apiKeysResponse.json();
                    if (apiKeysData.success) {
                        // ğŸ”§ ì‚¬ìš©ì ê°ì²´ì— API í‚¤ ì •ë³´ ì¶”ê°€
                        currentUser.hasOpenAIKey = apiKeysData.openaiKey;
                        currentUser.hasGoogleKey = apiKeysData.googleKey;

                        console.log('[Auth] API í‚¤ ìƒíƒœ ì—…ë°ì´íŠ¸:', {
                            openai: currentUser.hasOpenAIKey,
                            google: currentUser.hasGoogleKey
                        });
                    }
                }

                // ğŸ”§ ì‚¬ìš©ëŸ‰ ë°ì´í„° ìƒˆë¡œê³ ì¹¨
                await refreshUsageData();

                // ğŸ”§ ì—…ë°ì´íŠ¸ëœ ì‚¬ìš©ì ì •ë³´ ì €ì¥
                localStorage.setItem('currentUser', JSON.stringify(currentUser));

            } catch (error) {
                console.error('[Auth] ì‚¬ìš©ì ë°ì´í„° ìƒˆë¡œê³ ì¹¨ ì‹¤íŒ¨:', error);
            }
        }

        // ğŸ” ì‚¬ìš©ëŸ‰ ë°ì´í„° ìƒˆë¡œê³ ì¹¨
        async function refreshUsageData() {
            if (!authToken) return;

            try {
                const response = await fetch(AUTH_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({
                        action: 'get-usage'
                    })
                });

                if (response.ok) {
                    const usageData = await response.json();
                    if (usageData.success) {
                        // ğŸ”§ ì‹¤ì œ ì‚¬ìš©ëŸ‰ ë°ì´í„°ë¡œ UI ì—…ë°ì´íŠ¸
                        updateUsageUI(usageData.usage);

                        console.log('[Auth] ì‚¬ìš©ëŸ‰ ë°ì´í„° ì—…ë°ì´íŠ¸ ì™„ë£Œ');
                    }
                }

            } catch (error) {
                console.error('[Auth] ì‚¬ìš©ëŸ‰ ë°ì´í„° ìƒˆë¡œê³ ì¹¨ ì‹¤íŒ¨:', error);
            }
        }

        // ğŸ” ì‚¬ìš©ëŸ‰ UI ì—…ë°ì´íŠ¸
        function updateUsageUI(usageData) {
            if (!usageData) return;

            // ëŒ€ì‹œë³´ë“œ ì¹´ë“œ ì—…ë°ì´íŠ¸
            const todayUsageEl = document.getElementById('todayUsage');
            const monthUsageEl = document.getElementById('monthUsage');
            const todayCostEl = document.getElementById('todayCost');
            const monthCostEl = document.getElementById('monthCost');

            if (todayUsageEl) todayUsageEl.textContent = usageData.today?.translations || 0;
            if (monthUsageEl) monthUsageEl.textContent = usageData.thisMonth?.translations || 0;
            if (todayCostEl) todayCostEl.textContent = `$${(usageData.today?.cost || 0).toFixed(4)}`;
            if (monthCostEl) monthCostEl.textContent = `$${(usageData.thisMonth?.cost || 0).toFixed(4)}`;

            // í†µê³„ ì •ë³´ ì—…ë°ì´íŠ¸
            const todayTranslationsEl = document.getElementById('todayTranslations');
            if (todayTranslationsEl) todayTranslationsEl.textContent = usageData.today?.translations || 0;

            // ì£¼ê°„ ì°¨íŠ¸ ì—…ë°ì´íŠ¸
            if (usageData.weekly && usageData.weekly.length > 0) {
                updateWeeklyChart(usageData.weekly);
            }
        }

        // ğŸ” ì£¼ê°„ ì°¨íŠ¸ ì—…ë°ì´íŠ¸
        function updateWeeklyChart(weeklyData) {
            const chartEl = document.getElementById('weeklyChart');
            if (!chartEl) return;

            const maxTranslations = Math.max(...weeklyData.map(d => d.translation_count || 0), 1);

            chartEl.innerHTML = weeklyData.map(dayData => {
                const count = dayData.translation_count || 0;
                const height = (count / maxTranslations) * 100;
                const date = new Date(dayData.date);
                const dayLabel = date.toLocaleDateString('ko-KR', { weekday: 'short' });

                return `
            <div class="bar" style="height: ${height}%">
                <span class="bar-value">${count}</span>
                <span class="bar-label">${dayLabel}</span>
            </div>
        `;
            }).join('');
        }

        // ğŸ” ì¸ì¦ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
        function setupAuthEventListeners() {
            // ğŸ”§ ì¸ì¦ íƒ­ ì „í™˜ ì´ë²¤íŠ¸
            document.querySelectorAll('.auth-tab').forEach(tab => {
                tab.addEventListener('click', function () {
                    switchAuthTab(this.dataset.tab);
                });
            });

            // ğŸ”§ API í‚¤ ê´€ë¦¬ ì´ë²¤íŠ¸ëŠ” ì´ë¯¸ setupApiKeyEvents()ì—ì„œ ì²˜ë¦¬
            setupApiKeyEvents();

            // ğŸ”§ ë¡œê·¸ì¸ í¼ ì—”í„°í‚¤ ì²˜ë¦¬
            const loginEmail = document.getElementById('loginEmail');
            const loginPassword = document.getElementById('loginPassword');

            if (loginEmail) {
                loginEmail.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') {
                        loginPassword?.focus();
                    }
                });
            }

            if (loginPassword) {
                loginPassword.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') {
                        handleLogin();
                    }
                });
            }

            // ğŸ”§ íšŒì›ê°€ì… í¼ ì—”í„°í‚¤ ì²˜ë¦¬
            const registerPassword = document.getElementById('registerPassword');
            const registerPasswordConfirm = document.getElementById('registerPasswordConfirm');

            if (registerPassword) {
                registerPassword.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') {
                        registerPasswordConfirm?.focus();
                    }
                });
            }

            if (registerPasswordConfirm) {
                registerPasswordConfirm.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') {
                        handleRegister();
                    }
                });
            }
        }

        // ğŸ”§ ë¡œê·¸ì¸ í´ë¦­ í•¸ë“¤ëŸ¬ (ë””ë²„ê·¸ìš©)
        function handleLoginClick() {
            if (currentUser) {
                // ë¡œê·¸ì¸ëœ ìƒíƒœ: ì‚¬ìš©ìì—ê²Œ ë¡œê·¸ì•„ì›ƒí• ì§€ API í‚¤ë¥¼ ê´€ë¦¬í• ì§€ ì„ íƒê¶Œì„ ì¤ë‹ˆë‹¤.
                if (confirm('ë¡œê·¸ì•„ì›ƒí•˜ì‹œê² ìŠµë‹ˆê¹Œ?\n\nì·¨ì†Œë¥¼ ëˆ„ë¥´ë©´ API í‚¤ ê´€ë¦¬ í™”ë©´ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.')) {
                    handleLogout(); // "í™•ì¸" í´ë¦­ ì‹œ ë¡œê·¸ì•„ì›ƒ í•¨ìˆ˜ í˜¸ì¶œ
                } else {
                    toggleApiKeys(); // "ì·¨ì†Œ" í´ë¦­ ì‹œ API í‚¤ ê´€ë¦¬ ì°½ ì—´ê¸°
                }
            } else {
                // ë¡œê·¸ì¸ ì•ˆëœ ìƒíƒœ: ë¡œê·¸ì¸ ëª¨ë‹¬ ì—´ê¸°
                toggleAuth();
            }
        }

        // ì°¸ê³ : handleLogout í•¨ìˆ˜ëŠ” ì´ë¯¸ ì•„ë˜ì™€ ê°™ì´ êµ¬í˜„ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
        function handleLogout() {
            if (confirm('ë¡œê·¸ì•„ì›ƒ í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                clearAuthData();
                updateAuthUI(false);
                showStatus("ë¡œê·¸ì•„ì›ƒë˜ì—ˆìŠµë‹ˆë‹¤", "info");
            }
        }

        // ğŸ” ì¸ì¦ ëª¨ë‹¬ í† ê¸€ (ê°•í™”ëœ ë””ë²„ê·¸)
        function toggleAuth() {
            console.log('[Debug] toggleAuth ì‹œì‘');

            const authModal = document.getElementById('authModal');

            if (!authModal) {
                console.error('[Debug] authModal ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                return;
            }

            // ì´ë¯¸ ë¡œê·¸ì¸ëœ ê²½ìš°
            if (currentUser) {
                console.log('[Debug] ë¡œê·¸ì¸ëœ ì‚¬ìš©ì - API í‚¤ ê´€ë¦¬ë¡œ ì „í™˜');
                toggleApiKeys();
                return;
            }

            // ëª¨ë‹¬ í† ê¸€
            const isActive = authModal.classList.contains('active');
            console.log('[Debug] í˜„ì¬ ëª¨ë‹¬ ìƒíƒœ:', isActive ? 'ì—´ë¦¼' : 'ë‹«í˜');

            if (isActive) {
                authModal.classList.remove('active');
                console.log('[Debug] ëª¨ë‹¬ ë‹«ê¸° ì™„ë£Œ');
            } else {
                authModal.classList.add('active');
                console.log('[Debug] ëª¨ë‹¬ ì—´ê¸° ì™„ë£Œ');

                // ë‹¤ë¥¸ ëª¨ë‹¬ë“¤ ë‹«ê¸°
                document.getElementById('dashboardModal')?.classList.remove('active');
                document.getElementById('settingsPanel')?.classList.remove('active');
                document.getElementById('vocabularyDropdown')?.classList.remove('active');
                document.getElementById('practiceModal')?.classList.remove('active');
                document.getElementById('wordDetailModal')?.classList.remove('active');
                document.getElementById('quizModal')?.classList.remove('active');
                console.log('[Debug] ë‹¤ë¥¸ ëª¨ë‹¬ë“¤ ë‹«ê¸° ì™„ë£Œ');
            }
        }

        // ğŸ” API í‚¤ ê´€ë¦¬ ëª¨ë‹¬ í† ê¸€
        function toggleApiKeys() {
            const apiKeysModal = document.getElementById('apiKeysModal');

            if (!currentUser) {
                showStatus("API í‚¤ ê´€ë¦¬ëŠ” ë¡œê·¸ì¸ í›„ ì´ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤", "warning");
                toggleAuth();
                return;
            }

            apiKeysModal.classList.toggle('active');

            if (apiKeysModal.classList.contains('active')) {
                loadUserApiKeys();
                // ë‹¤ë¥¸ ëª¨ë‹¬ë“¤ ë‹«ê¸°
                document.getElementById('authModal')?.classList.remove('active');
                document.getElementById('dashboardModal')?.classList.remove('active');
            }
        }

        // ğŸ” ì¸ì¦ íƒ­ ì „í™˜
        function switchAuthTab(tabName) {
            // íƒ­ í™œì„±í™”
            document.querySelectorAll('.auth-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            const activeTab = document.querySelector(`[data-tab="${tabName}"]`);
            if (activeTab) {
                activeTab.classList.add('active');
            }

            // ëª¨ë“  í¼ ìˆ¨ê¸°ê¸°
            document.querySelectorAll('.auth-form').forEach(form => {
                form.classList.remove('active');
            });

            // ëª©í‘œ í¼ í‘œì‹œ
            const targetFormId = tabName === 'login' ? 'loginForm' : 'registerForm';
            const targetForm = document.getElementById(targetFormId);
            if (targetForm) {
                targetForm.classList.add('active');
            }
        }

        // ğŸ” ë¡œê·¸ì¸ ì²˜ë¦¬
        async function handleLogin() {
            const email = document.getElementById('loginEmail').value.trim();
            const password = document.getElementById('loginPassword').value;

            if (!email || !password) {
                showStatus("ì´ë©”ì¼ê³¼ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”", "warning");
                return;
            }

            showStatus("ë¡œê·¸ì¸ ì¤‘...", "info");

            try {
                const response = await fetch(AUTH_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'login',
                        email: email,
                        password: password
                    })
                });

                const result = await response.json();

                if (result.success) {
                    currentUser = result.user;
                    authToken = result.token;

                    // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥
                    localStorage.setItem('authToken', authToken);
                    localStorage.setItem('currentUser', JSON.stringify(currentUser));

                    updateAuthUI(true);
                    toggleAuth(); // ëª¨ë‹¬ ë‹«ê¸°

                    showStatus(`âœ… ${currentUser.displayName || currentUser.email}ë‹˜ í™˜ì˜í•©ë‹ˆë‹¤!`, "success");

                    // í¼ ì´ˆê¸°í™”
                    document.getElementById('loginEmail').value = '';
                    document.getElementById('loginPassword').value = '';

                } else {
                    showStatus(`ë¡œê·¸ì¸ ì‹¤íŒ¨: ${result.error}`, "error");
                }

            } catch (error) {
                console.error('[Auth] ë¡œê·¸ì¸ ì˜¤ë¥˜:', error);
                showStatus("ë¡œê·¸ì¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤", "error");
            }
        }

        // ğŸ” íšŒì›ê°€ì… ì²˜ë¦¬
        async function handleRegister() {
            const name = document.getElementById('registerName').value.trim();
            const email = document.getElementById('registerEmail').value.trim();
            const password = document.getElementById('registerPassword').value;
            const passwordConfirm = document.getElementById('registerPasswordConfirm').value;
            const agreeTerms = document.getElementById('agreeTerms').checked;

            // ìœ íš¨ì„± ê²€ì‚¬
            if (!email || !password) {
                showStatus("ì´ë©”ì¼ê³¼ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”", "warning");
                return;
            }

            if (password.length < 8) {
                showStatus("ë¹„ë°€ë²ˆí˜¸ëŠ” 8ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤", "warning");
                return;
            }

            if (password !== passwordConfirm) {
                showStatus("ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤", "warning");
                return;
            }

            if (!agreeTerms) {
                showStatus("ì„œë¹„ìŠ¤ ì´ìš©ì•½ê´€ì— ë™ì˜í•´ì£¼ì„¸ìš”", "warning");
                return;
            }

            showStatus("íšŒì›ê°€ì… ì¤‘...", "info");

            try {
                const response = await fetch(AUTH_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'register',
                        email: email,
                        password: password,
                        displayName: name || null
                    })
                });

                const result = await response.json();

                if (result.success) {
                    showStatus("âœ… íšŒì›ê°€ì…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”", "success");

                    // í¼ ì´ˆê¸°í™”
                    document.getElementById('registerName').value = '';
                    document.getElementById('registerEmail').value = '';
                    document.getElementById('registerPassword').value = '';
                    document.getElementById('registerPasswordConfirm').value = '';
                    document.getElementById('agreeTerms').checked = false;

                    // ë¡œê·¸ì¸ íƒ­ìœ¼ë¡œ ì „í™˜
                    switchAuthTab('login');

                    // ì´ë©”ì¼ ìë™ ì…ë ¥
                    document.getElementById('loginEmail').value = email;

                } else {
                    showStatus(`íšŒì›ê°€ì… ì‹¤íŒ¨: ${result.error}`, "error");
                }

            } catch (error) {
                console.error('[Auth] íšŒì›ê°€ì… ì˜¤ë¥˜:', error);
                showStatus("íšŒì›ê°€ì… ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤", "error");
            }
        }

        // ğŸ” ë¡œê·¸ì•„ì›ƒ ì²˜ë¦¬
        function handleLogout() {
            if (confirm('ë¡œê·¸ì•„ì›ƒ í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                clearAuthData();
                updateAuthUI(false);
                showStatus("ë¡œê·¸ì•„ì›ƒë˜ì—ˆìŠµë‹ˆë‹¤", "info");
            }
        }

        // ğŸ” ê²ŒìŠ¤íŠ¸ ëª¨ë“œ ê³„ì†
        function continueAsGuest() {
            toggleAuth(); // ëª¨ë‹¬ ë‹«ê¸°
            showStatus("ğŸ¯ ê²ŒìŠ¤íŠ¸ ëª¨ë“œë¡œ ì´ìš© ì¤‘ì…ë‹ˆë‹¤", "info");
        }

        // ğŸ” ë¹„ë°€ë²ˆí˜¸ ì°¾ê¸° í‘œì‹œ
        function showForgotPassword() {
            document.querySelectorAll('.auth-form').forEach(form => {
                form.style.display = 'none';
            });
            document.getElementById('forgotForm').style.display = 'block';
        }

        // ğŸ” ë¡œê·¸ì¸ í¼ìœ¼ë¡œ ëŒì•„ê°€ê¸°
        function showLoginForm() {
            document.querySelectorAll('.auth-form').forEach(form => {
                form.style.display = 'none';
            });
            document.getElementById('loginForm').style.display = 'block';
        }

        // ğŸ” ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì • ì²˜ë¦¬
        async function handleForgotPassword() {
            const email = document.getElementById('forgotEmail').value.trim();

            if (!email) {
                showStatus("ì´ë©”ì¼ì„ ì…ë ¥í•´ì£¼ì„¸ìš”", "warning");
                return;
            }

            showStatus("ì¬ì„¤ì • ë§í¬ ë°œì†¡ ì¤‘...", "info");

            try {
                const response = await fetch(AUTH_API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'forgot-password',
                        email: email
                    })
                });

                const result = await response.json();

                if (result.success) {
                    showStatus("ğŸ“§ ì¬ì„¤ì • ë§í¬ê°€ ì´ë©”ì¼ë¡œ ë°œì†¡ë˜ì—ˆìŠµë‹ˆë‹¤", "success");
                    showLoginForm();
                } else {
                    showStatus(`ë°œì†¡ ì‹¤íŒ¨: ${result.error}`, "error");
                }

            } catch (error) {
                console.error('[Auth] ë¹„ë°€ë²ˆí˜¸ ì¬ì„¤ì • ì˜¤ë¥˜:', error);
                showStatus("ì¬ì„¤ì • ë§í¬ ë°œì†¡ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤", "error");
            }
        }

        // ğŸ” ì¸ì¦ ë°ì´í„° ì‚­ì œ
        function clearAuthData() {
            currentUser = null;
            authToken = null;
            localStorage.removeItem('authToken');
            localStorage.removeItem('currentUser');
        }

        // ğŸ” ì¸ì¦ UI ì—…ë°ì´íŠ¸ (ì™„ì „ ê°œì„ )
        function updateAuthUI(isLoggedIn) {
            const loginToggle = document.getElementById('loginToggle');

            if (isLoggedIn && currentUser) {
                // ğŸ”§ ë¡œê·¸ì¸ ìƒíƒœ UI
                loginToggle.classList.add('logged-in');
                loginToggle.title = `${currentUser.displayName || currentUser.email} - API í‚¤ ê´€ë¦¬`;
                loginToggle.innerHTML = 'ğŸ‘¤âœ“';

                // ğŸ”§ í”„ë¦¬ë¯¸ì—„ ê¸°ëŠ¥ í‘œì‹œ
                updatePremiumFeatures(true);

                // ğŸ”§ ëŒ€ì‹œë³´ë“œ ë°ì´í„° í‘œì‹œ
                updateDashboardAccess(true);

                // ğŸ”§ ì„¤ì • íŒ¨ë„ ê³ ê¸‰ ê¸°ëŠ¥ í‘œì‹œ
                updateAdvancedSettings(true);

                console.log('[UI] ë¡œê·¸ì¸ ìƒíƒœ UI ì ìš©:', currentUser.email);

            } else {
                // ğŸ”§ ê²ŒìŠ¤íŠ¸ ìƒíƒœ UI
                loginToggle.classList.remove('logged-in');
                loginToggle.title = 'ë¡œê·¸ì¸/íšŒì›ê°€ì…';
                loginToggle.innerHTML = 'ğŸ‘¤';

                // ğŸ”§ ê¸°ëŠ¥ ì œí•œ ì ìš©
                updatePremiumFeatures(false);
                updateDashboardAccess(false);
                updateAdvancedSettings(false);

                console.log('[UI] ê²ŒìŠ¤íŠ¸ ìƒíƒœ UI ì ìš©');
            }

            // ğŸ”§ ë²ˆì—­/TTS ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
            updateTranslationButtonStates();
        }

        // ğŸ”§ í”„ë¦¬ë¯¸ì—„ ê¸°ëŠ¥ UI ì—…ë°ì´íŠ¸
        function updatePremiumFeatures(hasAccess) {
            // AI ë²ˆì—­ í† ê¸€ ë²„íŠ¼
            const aiToggle = document.getElementById('aiToggle');
            if (aiToggle) {
                if (hasAccess) {
                    aiToggle.style.opacity = '1';
                    aiToggle.style.pointerEvents = 'auto';
                    aiToggle.title = 'AI ë¬¸ë§¥ ë²ˆì—­ (í”„ë¦¬ë¯¸ì—„)';
                } else {
                    if (aiContextMode) {
                        toggleAIMode(); // AI ëª¨ë“œ ë¹„í™œì„±í™”
                    }
                    aiToggle.style.opacity = '0.5';
                    aiToggle.style.pointerEvents = 'auto'; // í´ë¦­ì€ ê°€ëŠ¥í•˜ê²Œ (ê²½ê³  í‘œì‹œìš©)
                    aiToggle.title = 'AI ë¬¸ë§¥ ë²ˆì—­ (ë¡œê·¸ì¸ í•„ìš”)';
                }
            }

            // ê³ ê¸‰ ë‹¨ì–´ì¥ í† ê¸€ ë²„íŠ¼
            const vocabToggle = document.getElementById('vocabToggle');
            if (vocabToggle) {
                if (hasAccess) {
                    vocabToggle.style.opacity = '1';
                    vocabToggle.style.pointerEvents = 'auto';
                    vocabToggle.title = 'ê³ ê¸‰ ë‹¨ì–´ì¥ (í”„ë¦¬ë¯¸ì—„)';
                } else {
                    vocabToggle.style.opacity = '0.5';
                    vocabToggle.style.pointerEvents = 'auto';
                    vocabToggle.title = 'ê³ ê¸‰ ë‹¨ì–´ì¥ (ë¡œê·¸ì¸ í•„ìš”)';
                }
            }

            // ì„¤ì • íŒ¨ë„ì˜ AI ì„¹ì…˜
            const aiSettingsSection = document.getElementById('aiSettingsSection');
            if (aiSettingsSection) {
                if (!hasAccess) {
                    aiSettingsSection.style.opacity = '0.5';
                    // ë¹„í™œì„±í™” ì˜¤ë²„ë ˆì´ ì¶”ê°€
                    if (!aiSettingsSection.querySelector('.premium-overlay')) {
                        const overlay = document.createElement('div');
                        overlay.className = 'premium-overlay';
                        overlay.style.cssText = `
                    position: absolute; top: 0; left: 0; right: 0; bottom: 0;
                    background: rgba(0,0,0,0.1); z-index: 10; cursor: pointer;
                    display: flex; align-items: center; justify-content: center;
                    font-size: 12px; color: var(--primary); font-weight: bold;
                `;
                        overlay.innerHTML = 'ğŸ”’ ë¡œê·¸ì¸ í•„ìš”';
                        overlay.onclick = () => showPremiumAlert('AI ë¬¸ë§¥ ë²ˆì—­ ì„¤ì •');
                        aiSettingsSection.style.position = 'relative';
                        aiSettingsSection.appendChild(overlay);
                    }
                } else {
                    aiSettingsSection.style.opacity = '1';
                    const overlay = aiSettingsSection.querySelector('.premium-overlay');
                    if (overlay) overlay.remove();
                }
            }
        }

        // ğŸ”§ ëŒ€ì‹œë³´ë“œ ì ‘ê·¼ ì œì–´
        function updateDashboardAccess(hasAccess) {
            // ëŒ€ì‹œë³´ë“œ ë²„íŠ¼ ìƒíƒœëŠ” í•­ìƒ í™œì„±í™” (ê²ŒìŠ¤íŠ¸ë„ ë¡œì»¬ ë°ì´í„° ë³¼ ìˆ˜ ìˆìŒ)
            // í•˜ì§€ë§Œ ë‚´ìš©ì´ ë‹¤ë¥´ê²Œ í‘œì‹œë¨
        }

        // ğŸ”§ ê³ ê¸‰ ì„¤ì • í‘œì‹œ/ìˆ¨ê¹€
        function updateAdvancedSettings(hasAccess) {
            // í˜„ì¬ëŠ” ëª¨ë“  ì„¤ì •ì´ ê²ŒìŠ¤íŠ¸ë„ ì‚¬ìš© ê°€ëŠ¥í•˜ë¯€ë¡œ íŠ¹ë³„í•œ ì œí•œ ì—†ìŒ
            // ì¶”í›„ í”„ë¦¬ë¯¸ì—„ ì „ìš© ì„¤ì • ì¶”ê°€ ì‹œ ì—¬ê¸°ì„œ ì œì–´
        }

        // ğŸ”§ ë²ˆì—­/TTS ë²„íŠ¼ ìƒíƒœ ì—…ë°ì´íŠ¸
        function updateTranslationButtonStates() {
            const translateBtn = document.getElementById('translateBtn');
            const speakBtn = document.getElementById('speakBtn');

            if (!currentUser) {
                // ê²ŒìŠ¤íŠ¸ ëª¨ë“œ í‘œì‹œ
                if (translateBtn) {
                    const originalText = translateBtn.textContent;
                    if (!originalText.includes('(ê²ŒìŠ¤íŠ¸)')) {
                        translateBtn.innerHTML = translateBtn.innerHTML.replace('ë²ˆì—­í•˜ê¸°', 'ë²ˆì—­í•˜ê¸° (ê²ŒìŠ¤íŠ¸)');
                    }
                }
            } else {
                // ë¡œê·¸ì¸ ëª¨ë“œ í‘œì‹œ
                if (translateBtn) {
                    translateBtn.innerHTML = translateBtn.innerHTML.replace(' (ê²ŒìŠ¤íŠ¸)', '');
                }
            }
        }

        // ğŸ”§ í”„ë¦¬ë¯¸ì—„ ê¸°ëŠ¥ ì ‘ê·¼ ì‹œ ì•Œë¦¼
        function showPremiumAlert(featureName) {
            if (currentUser) {
                showStatus(`${featureName} ê¸°ëŠ¥ì€ ì´ë¯¸ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤`, "info");
                return;
            }

            // ì¤‘ë³µ íŒì—… ë°©ì§€ë¥¼ ìœ„í•œ í”Œë˜ê·¸ ì²´í¬
            if (window.alertShowing) {
                console.log('[Debug] ì´ë¯¸ íŒì—…ì´ í‘œì‹œ ì¤‘ì…ë‹ˆë‹¤');
                return;
            }

            window.alertShowing = true;

            const shouldLogin = confirm(
                `ğŸ”’ ${featureName} ê¸°ëŠ¥ì€ ë¡œê·¸ì¸ í›„ ì´ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.\n\n` +
                `â€¢ ë¬´ì œí•œ ë²ˆì—­ ë° TTS\n` +
                `â€¢ ê°œì¸ API í‚¤ ë“±ë¡\n` +
                `â€¢ ì‚¬ìš©ëŸ‰ ì¶”ì  ë° ë¶„ì„\n` +
                `â€¢ ê³ ê¸‰ ë‹¨ì–´ì¥ ë° í•™ìŠµ ê¸°ë¡\n\n` +
                `ì§€ê¸ˆ ë¡œê·¸ì¸í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`
            );

            window.alertShowing = false;

            if (shouldLogin) {
                // ì§ì ‘ ëª¨ë‹¬ ì—´ê¸° (toggleAuth ëŒ€ì‹ )
                const authModal = document.getElementById('authModal');
                if (authModal) {
                    authModal.classList.add('active');
                    console.log('[Debug] ë¡œê·¸ì¸ ëª¨ë‹¬ ì—´ê¸°');
                } else {
                    console.error('[Debug] authModalì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                }
            }
        }

        // ğŸ”§ AI ëª¨ë“œ í† ê¸€ ì‹œ ê¶Œí•œ ì²´í¬
        function toggleAIModeWithAuth() {
            if (!currentUser) {
                showPremiumAlert('AI ë¬¸ë§¥ ë²ˆì—­');
                return;
            }

            toggleAIMode();
        }

        // ğŸ”§ ë‹¨ì–´ì¥ í† ê¸€ ì‹œ ê¶Œí•œ ì²´í¬  
        function toggleVocabularyWithAuth() {
            if (!currentUser) {
                showPremiumAlert('ê³ ê¸‰ ë‹¨ì–´ì¥');
                return;
            }

            toggleVocabulary();
        }

        // ğŸ”‘ API í‚¤ ê´€ë¦¬ ì‹œìŠ¤í…œ (ê°œì„ )
        async function loadUserApiKeys() {
            if (!currentUser || !authToken) {
                console.log('[API Keys] ì‚¬ìš©ì ë¯¸ì¸ì¦');
                // ë¹„ì¸ì¦ ìƒíƒœ UI í‘œì‹œ
                updateApiKeyStatus('openai', 'error', 'âŒ ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤');
                updateApiKeyStatus('google', 'error', 'âŒ ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤');
                return;
            }

            console.log('[API Keys] ì‚¬ìš©ì API í‚¤ ë¡œë“œ ì‹œì‘');

            // ë¡œë”© ìƒíƒœ í‘œì‹œ
            updateApiKeyStatus('openai', 'info', 'ğŸ”„ API í‚¤ ì •ë³´ ë¡œë“œ ì¤‘...');
            updateApiKeyStatus('google', 'info', 'ğŸ”„ API í‚¤ ì •ë³´ ë¡œë“œ ì¤‘...');

            try {
                const response = await fetch(AUTH_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({
                        action: 'get-api-keys'
                    })
                });

                if (!response.ok) {
                    throw new Error(`API ìš”ì²­ ì‹¤íŒ¨: ${response.status}`);
                }

                const result = await response.json();

                if (result.success) {
                    console.log('[API Keys] í‚¤ ì •ë³´ ë¡œë“œ ì„±ê³µ:', result);

                    // ğŸ”§ OpenAI í‚¤ ìƒíƒœ ì—…ë°ì´íŠ¸
                    if (result.openaiKey) {
                        document.getElementById('openaiApiKey').value = 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢';
                        document.getElementById('openaiApiKey').placeholder = 'API í‚¤ê°€ ë“±ë¡ë˜ì–´ ìˆìŠµë‹ˆë‹¤';
                        updateApiKeyStatus('openai', 'success', 'âœ… OpenAI API í‚¤ê°€ ë“±ë¡ë˜ì–´ ìˆìŠµë‹ˆë‹¤');

                        // ê¸€ë¡œë²Œ ìƒíƒœ ì—…ë°ì´íŠ¸
                        if (currentUser) currentUser.hasOpenAIKey = true;
                    } else {
                        document.getElementById('openaiApiKey').value = '';
                        document.getElementById('openaiApiKey').placeholder = 'sk-...';
                        updateApiKeyStatus('openai', 'error', 'âŒ OpenAI API í‚¤ê°€ ë“±ë¡ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');

                        if (currentUser) currentUser.hasOpenAIKey = false;
                    }

                    // ğŸ”§ Google í‚¤ ìƒíƒœ ì—…ë°ì´íŠ¸
                    if (result.googleKey) {
                        document.getElementById('googleApiKey').value = 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢';
                        document.getElementById('googleApiKey').placeholder = 'API í‚¤ê°€ ë“±ë¡ë˜ì–´ ìˆìŠµë‹ˆë‹¤';
                        updateApiKeyStatus('google', 'success', 'âœ… Google API í‚¤ê°€ ë“±ë¡ë˜ì–´ ìˆìŠµë‹ˆë‹¤');

                        if (currentUser) currentUser.hasGoogleKey = true;
                    } else {
                        document.getElementById('googleApiKey').value = '';
                        document.getElementById('googleApiKey').placeholder = 'AIza...';
                        updateApiKeyStatus('google', 'error', 'âŒ Google API í‚¤ê°€ ë“±ë¡ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤');

                        if (currentUser) currentUser.hasGoogleKey = false;
                    }

                    // ğŸ”§ ì‚¬ìš©ì ì •ë³´ ì—…ë°ì´íŠ¸ ë° ì €ì¥
                    if (currentUser) {
                        localStorage.setItem('currentUser', JSON.stringify(currentUser));
                    }

                } else {
                    console.error('[API Keys] ë¡œë“œ ì‹¤íŒ¨:', result.error);
                    updateApiKeyStatus('openai', 'error', `âŒ ë¡œë“œ ì‹¤íŒ¨: ${result.error}`);
                    updateApiKeyStatus('google', 'error', `âŒ ë¡œë“œ ì‹¤íŒ¨: ${result.error}`);
                }

            } catch (error) {
                console.error('[API Keys] ë¡œë“œ ì˜¤ë¥˜:', error);
                updateApiKeyStatus('openai', 'error', 'âŒ ë¡œë“œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ');
                updateApiKeyStatus('google', 'error', 'âŒ ë¡œë“œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ');
            }
        }

        // ğŸ”‘ OpenAI API í‚¤ ì €ì¥ (ê°œì„ )
        async function saveOpenAIKey() {
            const apiKey = document.getElementById('openaiApiKey').value.trim();

            if (!currentUser || !authToken) {
                showStatus("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤", "warning");
                updateApiKeyStatus('openai', 'error', 'âŒ ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤');
                return;
            }

            if (!apiKey || apiKey === 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢') {
                showStatus("ìœ íš¨í•œ OpenAI API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”", "warning");
                updateApiKeyStatus('openai', 'error', 'âŒ API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”');
                return;
            }

            if (!apiKey.startsWith('sk-')) {
                showStatus("OpenAI API í‚¤ëŠ” 'sk-'ë¡œ ì‹œì‘í•´ì•¼ í•©ë‹ˆë‹¤", "warning");
                updateApiKeyStatus('openai', 'error', 'âŒ ì˜¬ë°”ë¥¸ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤');
                return;
            }

            if (apiKey.length < 20) {
                showStatus("API í‚¤ê°€ ë„ˆë¬´ ì§§ìŠµë‹ˆë‹¤", "warning");
                updateApiKeyStatus('openai', 'error', 'âŒ API í‚¤ê°€ ë„ˆë¬´ ì§§ìŠµë‹ˆë‹¤');
                return;
            }

            updateApiKeyStatus('openai', 'info', 'ğŸ”„ API í‚¤ ì €ì¥ ì¤‘...');

            try {
                const response = await fetch(AUTH_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({
                        action: 'save-api-key',
                        provider: 'openai',
                        apiKey: apiKey,
                        keyName: 'OpenAI API Key'
                    })
                });

                if (!response.ok) {
                    throw new Error(`API ìš”ì²­ ì‹¤íŒ¨: ${response.status}`);
                }

                const result = await response.json();

                if (result.success) {
                    console.log('[API Keys] OpenAI í‚¤ ì €ì¥ ì„±ê³µ');

                    // UI ì—…ë°ì´íŠ¸
                    document.getElementById('openaiApiKey').value = 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢';
                    document.getElementById('openaiApiKey').placeholder = 'API í‚¤ê°€ ë“±ë¡ë˜ì–´ ìˆìŠµë‹ˆë‹¤';
                    updateApiKeyStatus('openai', 'success', 'âœ… OpenAI API í‚¤ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤');
                    showStatus("ğŸ”‘ OpenAI API í‚¤ ì €ì¥ ì™„ë£Œ", "success");

                    // ğŸ”§ ì‚¬ìš©ì ìƒíƒœ ì—…ë°ì´íŠ¸
                    if (currentUser) {
                        currentUser.hasOpenAIKey = true;
                        localStorage.setItem('currentUser', JSON.stringify(currentUser));
                    }

                } else {
                    console.error('[API Keys] OpenAI í‚¤ ì €ì¥ ì‹¤íŒ¨:', result.error);
                    updateApiKeyStatus('openai', 'error', `âŒ ì €ì¥ ì‹¤íŒ¨: ${result.error}`);
                    showStatus(`API í‚¤ ì €ì¥ ì‹¤íŒ¨: ${result.error}`, "error");
                }

            } catch (error) {
                console.error('[API Keys] OpenAI í‚¤ ì €ì¥ ì˜¤ë¥˜:', error);
                updateApiKeyStatus('openai', 'error', 'âŒ ì €ì¥ ì¤‘ ì˜¤ë¥˜ ë°œìƒ');
                showStatus("API í‚¤ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤", "error");
            }
        }

        // ğŸ”‘ Google API í‚¤ ì €ì¥ (ê°œì„ )
        async function saveGoogleKey() {
            const apiKey = document.getElementById('googleApiKey').value.trim();

            if (!currentUser || !authToken) {
                showStatus("ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤", "warning");
                updateApiKeyStatus('google', 'error', 'âŒ ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤');
                return;
            }

            if (!apiKey || apiKey === 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢') {
                showStatus("ìœ íš¨í•œ Google API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”", "warning");
                updateApiKeyStatus('google', 'error', 'âŒ API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”');
                return;
            }

            if (!apiKey.startsWith('AIza')) {
                showStatus("Google API í‚¤ëŠ” 'AIza'ë¡œ ì‹œì‘í•´ì•¼ í•©ë‹ˆë‹¤", "warning");
                updateApiKeyStatus('google', 'error', 'âŒ ì˜¬ë°”ë¥¸ í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤');
                return;
            }

            if (apiKey.length < 20) {
                showStatus("API í‚¤ê°€ ë„ˆë¬´ ì§§ìŠµë‹ˆë‹¤", "warning");
                updateApiKeyStatus('google', 'error', 'âŒ API í‚¤ê°€ ë„ˆë¬´ ì§§ìŠµë‹ˆë‹¤');
                return;
            }

            updateApiKeyStatus('google', 'info', 'ğŸ”„ API í‚¤ ì €ì¥ ì¤‘...');

            try {
                const response = await fetch(AUTH_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${authToken}`
                    },
                    body: JSON.stringify({
                        action: 'save-api-key',
                        provider: 'google',
                        apiKey: apiKey,
                        keyName: 'Google API Key'
                    })
                });

                if (!response.ok) {
                    throw new Error(`API ìš”ì²­ ì‹¤íŒ¨: ${response.status}`);
                }

                const result = await response.json();

                if (result.success) {
                    console.log('[API Keys] Google í‚¤ ì €ì¥ ì„±ê³µ');

                    // UI ì—…ë°ì´íŠ¸
                    document.getElementById('googleApiKey').value = 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢';
                    document.getElementById('googleApiKey').placeholder = 'API í‚¤ê°€ ë“±ë¡ë˜ì–´ ìˆìŠµë‹ˆë‹¤';
                    updateApiKeyStatus('google', 'success', 'âœ… Google API í‚¤ê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤');
                    showStatus("ğŸ”‘ Google API í‚¤ ì €ì¥ ì™„ë£Œ", "success");

                    // ğŸ”§ ì‚¬ìš©ì ìƒíƒœ ì—…ë°ì´íŠ¸
                    if (currentUser) {
                        currentUser.hasGoogleKey = true;
                        localStorage.setItem('currentUser', JSON.stringify(currentUser));
                    }

                } else {
                    console.error('[API Keys] Google í‚¤ ì €ì¥ ì‹¤íŒ¨:', result.error);
                    updateApiKeyStatus('google', 'error', `âŒ ì €ì¥ ì‹¤íŒ¨: ${result.error}`);
                    showStatus(`API í‚¤ ì €ì¥ ì‹¤íŒ¨: ${result.error}`, "error");
                }

            } catch (error) {
                console.error('[API Keys] Google í‚¤ ì €ì¥ ì˜¤ë¥˜:', error);
                updateApiKeyStatus('google', 'error', 'âŒ ì €ì¥ ì¤‘ ì˜¤ë¥˜ ë°œìƒ');
                showStatus("API í‚¤ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤", "error");
            }
        }

        // ğŸ”‘ OpenAI API í‚¤ í…ŒìŠ¤íŠ¸
        async function testOpenAIKey() {
            const apiKey = document.getElementById('openaiApiKey').value.trim();

            if (!apiKey || apiKey === 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢') {
                showStatus("í…ŒìŠ¤íŠ¸í•  API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”", "warning");
                return;
            }

            updateApiKeyStatus('openai', 'info', 'ğŸ”„ API í‚¤ í…ŒìŠ¤íŠ¸ ì¤‘...');

            try {
                // OpenAI API ê°„ë‹¨í•œ í…ŒìŠ¤íŠ¸ ìš”ì²­
                const response = await fetch('https://api.openai.com/v1/models', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    updateApiKeyStatus('openai', 'success', 'âœ… OpenAI API í‚¤ê°€ ìœ íš¨í•©ë‹ˆë‹¤');
                    showStatus("ğŸ”‘ OpenAI API í‚¤ í…ŒìŠ¤íŠ¸ ì„±ê³µ", "success");
                } else {
                    const errorText = await response.text();
                    updateApiKeyStatus('openai', 'error', `âŒ ìœ íš¨í•˜ì§€ ì•Šì€ API í‚¤: ${response.status}`);
                    showStatus(`API í‚¤ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: ${response.status}`, "error");
                }

            } catch (error) {
                console.error('[API Keys] OpenAI í‚¤ í…ŒìŠ¤íŠ¸ ì˜¤ë¥˜:', error);
                updateApiKeyStatus('openai', 'error', 'âŒ í…ŒìŠ¤íŠ¸ ì¤‘ ì˜¤ë¥˜ ë°œìƒ');
                showStatus("API í‚¤ í…ŒìŠ¤íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤", "error");
            }
        }

        // ğŸ”‘ Google API í‚¤ í…ŒìŠ¤íŠ¸
        async function testGoogleKey() {
            const apiKey = document.getElementById('googleApiKey').value.trim();

            if (!apiKey || apiKey === 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢') {
                showStatus("í…ŒìŠ¤íŠ¸í•  API í‚¤ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”", "warning");
                return;
            }

            updateApiKeyStatus('google', 'info', 'ğŸ”„ API í‚¤ í…ŒìŠ¤íŠ¸ ì¤‘...');

            try {
                // Google TTS API ê°„ë‹¨í•œ í…ŒìŠ¤íŠ¸ ìš”ì²­ (ëª©ì†Œë¦¬ ë¦¬ìŠ¤íŠ¸ ì¡°íšŒ)
                const response = await fetch(`https://texttospeech.googleapis.com/v1/voices?key=${apiKey}`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                if (response.ok) {
                    updateApiKeyStatus('google', 'success', 'âœ… Google API í‚¤ê°€ ìœ íš¨í•©ë‹ˆë‹¤');
                    showStatus("ğŸ”‘ Google API í‚¤ í…ŒìŠ¤íŠ¸ ì„±ê³µ", "success");
                } else {
                    const errorText = await response.text();
                    updateApiKeyStatus('google', 'error', `âŒ ìœ íš¨í•˜ì§€ ì•Šì€ API í‚¤: ${response.status}`);
                    showStatus(`API í‚¤ í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨: ${response.status}`, "error");
                }

            } catch (error) {
                console.error('[API Keys] Google í‚¤ í…ŒìŠ¤íŠ¸ ì˜¤ë¥˜:', error);
                updateApiKeyStatus('google', 'error', 'âŒ í…ŒìŠ¤íŠ¸ ì¤‘ ì˜¤ë¥˜ ë°œìƒ');
                showStatus("API í‚¤ í…ŒìŠ¤íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤", "error");
            }
        }

        // ğŸ”‘ API í‚¤ ìƒíƒœ ì—…ë°ì´íŠ¸
        function updateApiKeyStatus(provider, status, message) {
            const statusEl = document.getElementById(`${provider}KeyStatus`);
            if (!statusEl) return;

            statusEl.className = `api-key-status ${status}`;
            statusEl.textContent = message;
            statusEl.style.display = 'block';
        }

        // ğŸ”‘ ì¸ì¦ëœ API ìš”ì²­ì— í† í° ì¶”ê°€
        function getAuthHeaders() {
            const headers = {
                'Content-Type': 'application/json'
            };

            if (authToken) {
                headers['Authorization'] = `Bearer ${authToken}`;
            }

            return headers;
        }

        // ğŸ”‘ API í‚¤ ì…ë ¥ í•„ë“œ ì´ë²¤íŠ¸ ì²˜ë¦¬
        function setupApiKeyEvents() {
            // OpenAI í‚¤ ì…ë ¥ ì‹œ ìƒíƒœ ì´ˆê¸°í™”
            const openaiInput = document.getElementById('openaiApiKey');
            if (openaiInput) {
                openaiInput.addEventListener('input', function () {
                    if (this.value && this.value !== 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢') {
                        updateApiKeyStatus('openai', '', '');
                    }
                });

                // ì—”í„°í‚¤ë¡œ ì €ì¥
                openaiInput.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') {
                        saveOpenAIKey();
                    }
                });
            }

            // Google í‚¤ ì…ë ¥ ì‹œ ìƒíƒœ ì´ˆê¸°í™”
            const googleInput = document.getElementById('googleApiKey');
            if (googleInput) {
                googleInput.addEventListener('input', function () {
                    if (this.value && this.value !== 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢') {
                        updateApiKeyStatus('google', '', '');
                    }
                });

                // ì—”í„°í‚¤ë¡œ ì €ì¥
                googleInput.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') {
                        saveGoogleKey();
                    }
                });
            }
        }

        // AI ë¬¸ë§¥ ë²ˆì—­ ì„¤ì •
        let aiContextMode = false;
        let translationContext = [];
        let currentTranslationStyle = 'balanced';
        let qualityLevel = 3;
        let streamingMode = false; // ğŸš€ ìŠ¤íŠ¸ë¦¬ë° ëª¨ë“œ ìƒíƒœ

        // ğŸš€ ìŠ¤íŠ¸ë¦¬ë° ëª¨ë“œ í† ê¸€ í•¨ìˆ˜
        function toggleStreamingMode() {
            const toggle = document.getElementById('streamingModeToggle');
            const status = document.getElementById('streamingModeStatus');
            streamingMode = toggle?.checked || false;

            if (status) {
                status.textContent = streamingMode ? 'í™œì„±í™” âš¡' : 'ë¹„í™œì„±í™”';
                status.style.color = streamingMode ? 'var(--primary)' : 'var(--text-secondary)';
            }

            // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì— ì €ì¥
            localStorage.setItem('streamingMode', streamingMode);
            console.log('[Streaming] ìŠ¤íŠ¸ë¦¬ë° ëª¨ë“œ:', streamingMode ? 'ON' : 'OFF');
        }

        // ìŠ¤íŠ¸ë¦¬ë° ì„¤ì • ë¡œë“œ
        function loadStreamingSettings() {
            const saved = localStorage.getItem('streamingMode');
            streamingMode = saved === 'true';
            const toggle = document.getElementById('streamingModeToggle');
            const status = document.getElementById('streamingModeStatus');

            if (toggle) toggle.checked = streamingMode;
            if (status) {
                status.textContent = streamingMode ? 'í™œì„±í™” âš¡' : 'ë¹„í™œì„±í™”';
                status.style.color = streamingMode ? 'var(--primary)' : 'var(--text-secondary)';
            }
        }

        // ê³ ê¸‰ ë‹¨ì–´ì¥ ì‹œìŠ¤í…œ - ì´ˆê¸°í™”
        let vocabularyDict = new Map();
        let terminologyDict = new Map(); // ì „ë¬¸ìš©ì–´ ì‚¬ì „ ì¶”ê°€
        let currentVocabWord = null;
        let quizState = {
            active: false,
            words: [],
            currentIndex: 0,
            correctAnswers: 0,
            wrongAnswers: 0,
            totalQuestions: 10,
            selectedAnswer: null
        }; // ğŸ”§ ìˆ˜ì •: ë‹«ëŠ” ê´„í˜¸ ì¶”ê°€

        let practiceState = {
            active: false,
            currentWord: null,
            isRecording: false,
            practiceTime: 0,
            lastRecording: null,
            recordingStartTime: null
        }; // ğŸ”§ ìˆ˜ì •: ì •ì˜ë¥¼ ë¨¼ì € í•˜ê³ 

        let vocabularyStats = {
            totalWords: 0,
            quizAccuracy: 0,
            practiceTime: 0,
            learningProgress: 0
        }; // ğŸ”§ ìˆ˜ì •: ë‹«ëŠ” ê´„í˜¸ ì¶”ê°€

        // ğŸ”§ ê°•ì œ ë¹„í™œì„±í™” (ì •ì˜ í›„ì— ì‹¤í–‰)
        practiceState.active = false;
        quizState.active = false;

        // DOM ìš”ì†Œë“¤
        // DOM ìš”ì†Œ ìºì‹± (ì„±ëŠ¥ ìµœì í™”)
        const els = {
            // ì…ë ¥ ë° ê²°ê³¼ ìš”ì†Œ
            inputText: document.getElementById("inputText"),
            translation: document.getElementById("translation"),
            pronunciationContent: document.getElementById("pronunciation-content"),
            pronunciationSection: document.getElementById("pronunciationSection"),
            pronToggleIcon: document.getElementById("pronToggleIcon"),
            status: document.getElementById("status"),

            // ë²„íŠ¼ ìš”ì†Œ
            voiceBtn: document.getElementById("voiceBtn"),
            speakBtn: document.getElementById("speakBtn"),
            copyBtn: document.getElementById("copyBtn"),
            translateBtn: document.getElementById("translateBtn"),
            translateBtnText: document.getElementById("translateBtnText"),

            // ì–¸ì–´ ì„ íƒ
            sourceLangSelect: document.getElementById("sourceLangSelect"),
            targetLangSelect: document.getElementById("targetLangSelect"),
            voiceSelect: document.getElementById("voiceSelect"),
            googleVoiceSelect: document.getElementById("googleVoiceSelect"),
            autoDetectBadge: document.getElementById("autoDetectBadge"),

            // íŒ¨ë„ ë° ëª¨ë“œ
            settingsPanel: document.getElementById("settingsPanel"),
            normalMode: document.getElementById("normalMode"),
            conversationMode: document.getElementById("conversationMode"),
            normalModeBtn: document.getElementById("normalModeBtn"),
            conversationModeBtn: document.getElementById("conversationModeBtn"),

            // ëŒ€í™” ëª¨ë“œ ê´€ë ¨
            speakerCardA: document.getElementById("speakerCardA"),
            speakerCardB: document.getElementById("speakerCardB"),
            speakerLangA: document.getElementById("speakerLangA"),
            speakerLangB: document.getElementById("speakerLangB"),
            startConversationBtn: document.getElementById("startConversationBtn"),
            stopConversationBtn: document.getElementById("stopConversationBtn"),
            conversationHistory: document.getElementById("conversationHistory"),

            // TTS ë° ì¬ìƒ
            ttsEngineMode: document.getElementById("ttsEngineMode"),
            cacheIndicator: document.getElementById("cacheIndicator"),
            engineIndicator: document.getElementById("engineIndicator"),
            recentPlays: document.getElementById("recentPlays"),
            recentPlayList: document.getElementById("recentPlayList"),

            // ëª¨ë‹¬
            dashboardModal: document.getElementById("dashboardModal"),
            historyModal: document.getElementById("historyModal"),
            historyList: document.getElementById("historyList"),

            // ëŒ€ì‹œë³´ë“œ
            todayTranslations: document.getElementById("todayTranslations"),
            totalTranslations: document.getElementById("totalTranslations"),
            cacheHitRate: document.getElementById("cacheHitRate"),

            // ì„¤ì •
            autoModeSettings: document.getElementById("autoModeSettings"),
            autoThreshold: document.getElementById("autoThreshold"),
            thresholdValue: document.getElementById("thresholdValue"),
            volumeControl: document.getElementById("volumeControl"),
            volumeValue: document.getElementById("volumeValue"),
            pronunciationToggle: document.getElementById("pronunciationToggle"),

            // AI ê¸°ëŠ¥
            aiToggle: document.getElementById("aiToggle"),
            aiContextBadge: document.getElementById("aiContextBadge"),
            aiIndicator: document.getElementById("aiIndicator"),
            qualitySlider: document.getElementById("qualitySlider"),
            aiSettingsSection: document.getElementById("aiSettingsSection"),

            // ë‹¨ì–´ì¥
            vocabularyOriginal: document.getElementById("vocabularyOriginal"),
            vocabularyTranslation: document.getElementById("vocabularyTranslation"),
            vocabularyDescription: document.getElementById("vocabularyDescription"),
            vocabularyList: document.getElementById("vocabularyList"),
            vocabularyStats: document.getElementById("vocabularyStats"),
            wordDetailModal: document.getElementById("wordDetailModal"),
            quizModal: document.getElementById("quizModal"),
            practiceModal: document.getElementById("practiceModal")
        };

        // ğŸ“Š ê°œì„ : ì‹¤ì œ API ì—°ë™ ì‚¬ìš©ëŸ‰ ì¶”ì ê¸°
        const usageTracker = {
            // ë¡œì»¬ ìºì‹œ (ì„±ëŠ¥ ìµœì í™”ìš©)
            localCache: {
                daily: {},
                monthly: {},
                lastRefresh: null
            },

            costs: {
                translation: 0.000015,
                openaiTTS: 0.000015,
                googleTTS: 0
            },

            // ğŸ”§ ì´ˆê¸°í™” - ì‹¤ì œ APIì—ì„œ ë°ì´í„° ë¡œë“œ
            async initialize() {
                console.log('[UsageTracker] ì´ˆê¸°í™” ì‹œì‘');

                if (authToken) {
                    await this.refreshFromAPI();
                } else {
                    // ê²ŒìŠ¤íŠ¸ ëª¨ë“œ: ë¡œì»¬ ë°ì´í„° ë¡œë“œ
                    this.loadLocalData();
                }

                this.updateDisplay();
            },

            // ğŸ”§ APIì—ì„œ ë°ì´í„° ìƒˆë¡œê³ ì¹¨
            async refreshFromAPI() {
                if (!authToken) {
                    console.log('[UsageTracker] ì¸ì¦ í† í° ì—†ìŒ - ë¡œì»¬ ëª¨ë“œ');
                    return;
                }

                try {
                    console.log('[UsageTracker] APIì—ì„œ ì‚¬ìš©ëŸ‰ ë°ì´í„° ë¡œë“œ ì¤‘...');

                    const response = await fetch(AUTH_API_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${authToken}`
                        },
                        body: JSON.stringify({
                            action: 'get-dashboard-data'
                        })
                    });

                    if (response.ok) {
                        const result = await response.json();
                        if (result.success) {
                            this.updateLocalCacheFromAPI(result.dashboard);
                            console.log('[UsageTracker] API ë°ì´í„° ë¡œë“œ ì™„ë£Œ');
                        }
                    }

                } catch (error) {
                    console.error('[UsageTracker] API ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', error);
                    // ì‹¤íŒ¨ ì‹œ ë¡œì»¬ ë°ì´í„° ì‚¬ìš©
                    this.loadLocalData();
                }

                this.localCache.lastRefresh = Date.now();
            },

            // ğŸ”§ API ë°ì´í„°ë¡œ ë¡œì»¬ ìºì‹œ ì—…ë°ì´íŠ¸
            updateLocalCacheFromAPI(dashboardData) {
                const today = new Date().toISOString().split('T')[0];
                const thisMonth = today.substring(0, 7);

                // ì˜¤ëŠ˜ ë°ì´í„°
                this.localCache.daily[today] = {
                    translations: dashboardData.usage.today.translations || 0,
                    characters: dashboardData.usage.today.translations * 50, // í‰ê·  ì¶”ì •
                    cost: dashboardData.usage.today.cost || 0,
                    saved: 0
                };

                // ì´ë²ˆ ë‹¬ ë°ì´í„°
                this.localCache.monthly[thisMonth] = {
                    translations: dashboardData.usage.thisMonth.translations || 0,
                    characters: dashboardData.usage.thisMonth.translations * 50,
                    cost: dashboardData.usage.thisMonth.cost || 0,
                    saved: 0
                };

                // ì£¼ê°„ ë°ì´í„° (ì°¨íŠ¸ìš©)
                this.localCache.weekly = dashboardData.usage.weekly || [];

                // ì›”ë³„ ë°ì´í„° (ì°¨íŠ¸ìš©)
                this.localCache.monthlyChart = dashboardData.monthlyData || [];
            },

            // ğŸ”§ ë¡œì»¬ ë°ì´í„° ë¡œë“œ (ê²ŒìŠ¤íŠ¸ ëª¨ë“œ)
            loadLocalData() {
                try {
                    const saved = localStorage.getItem('usageData');
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.localCache.daily = data.daily || {};
                        this.localCache.monthly = data.monthly || {};
                    }
                } catch (error) {
                    console.error('[UsageTracker] ë¡œì»¬ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', error);
                }
            },

            // ğŸ”§ ì‚¬ìš©ëŸ‰ ì¶”ì  - API ì „ì†¡ + ë¡œì»¬ ì—…ë°ì´íŠ¸
            async track(type, count, provider = 'openai') {
                const today = new Date().toISOString().split('T')[0];
                const thisMonth = today.substring(0, 7);

                // ë¡œì»¬ ìºì‹œ ì—…ë°ì´íŠ¸
                if (!this.localCache.daily[today]) {
                    this.localCache.daily[today] = { translations: 0, characters: 0, cost: 0, saved: 0 };
                }
                if (!this.localCache.monthly[thisMonth]) {
                    this.localCache.monthly[thisMonth] = { translations: 0, characters: 0, cost: 0, saved: 0 };
                }

                const dailyData = this.localCache.daily[today];
                const monthlyData = this.localCache.monthly[thisMonth];

                if (type === 'translation') {
                    dailyData.translations++;
                    monthlyData.translations++;
                    dailyData.characters += count;
                    monthlyData.characters += count;
                    const cost = count * this.costs.translation;
                    dailyData.cost += cost;
                    monthlyData.cost += cost;
                } else if (type === 'tts') {
                    const cost = provider === 'openai' ? count * this.costs.openaiTTS : 0;
                    const saved = provider === 'google' ? count * this.costs.openaiTTS : 0;

                    dailyData.cost += cost;
                    monthlyData.cost += cost;
                    dailyData.saved += saved;
                    monthlyData.saved += saved;
                }

                // ë¡œì»¬ ì €ì¥ (ê²ŒìŠ¤íŠ¸ ëª¨ë“œìš©)
                this.saveLocalData();

                // UI ì—…ë°ì´íŠ¸
                this.updateDisplay();
                this.checkLimits();

                // ğŸ”§ APIì— ì‚¬ìš©ëŸ‰ ì „ì†¡ (ì¸ì¦ëœ ì‚¬ìš©ìë§Œ)
                if (authToken && currentUser) {
                    try {
                        // ì‹¤ì œ trackUsageëŠ” translate.jsì—ì„œ í˜¸ì¶œë˜ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ë¡œê·¸ë§Œ
                        console.log(`[UsageTracker] ${type} ì‚¬ìš©ëŸ‰ ì¶”ì : ${count} (${provider})`);
                    } catch (error) {
                        console.error('[UsageTracker] API ì „ì†¡ ì‹¤íŒ¨:', error);
                    }
                }
            },

            // ë¡œì»¬ ë°ì´í„° ì €ì¥
            saveLocalData() {
                try {
                    const data = {
                        daily: this.localCache.daily,
                        monthly: this.localCache.monthly,
                        lastSaved: new Date().toISOString()
                    };
                    localStorage.setItem('usageData', JSON.stringify(data));
                } catch (error) {
                    console.error('[UsageTracker] ë¡œì»¬ ë°ì´í„° ì €ì¥ ì‹¤íŒ¨:', error);
                }
            },

            // ğŸ”§ ê°œì„ : ì‹¤ì œ ë°ì´í„°ë¡œ ë””ìŠ¤í”Œë ˆì´ ì—…ë°ì´íŠ¸
            updateDisplay() {
                const today = new Date().toISOString().split('T')[0];
                const thisMonth = today.substring(0, 7);

                const todayData = this.localCache.daily[today] || { translations: 0, cost: 0, saved: 0 };
                const monthData = this.localCache.monthly[thisMonth] || { translations: 0, cost: 0, saved: 0 };

                // ëŒ€ì‹œë³´ë“œ ì¹´ë“œ ì—…ë°ì´íŠ¸
                const todayUsageEl = document.getElementById('todayUsage');
                const monthUsageEl = document.getElementById('monthUsage');
                const todayCostEl = document.getElementById('todayCost');
                const monthCostEl = document.getElementById('monthCost');
                const savedCostEl = document.getElementById('savedCost');

                if (todayUsageEl) todayUsageEl.textContent = todayData.translations;
                if (monthUsageEl) monthUsageEl.textContent = monthData.translations;
                if (todayCostEl) todayCostEl.textContent = `$${todayData.cost.toFixed(4)}`;
                if (monthCostEl) monthCostEl.textContent = `$${monthData.cost.toFixed(4)}`;
                if (savedCostEl) savedCostEl.textContent = `$${monthData.saved.toFixed(4)}`;

                this.updateChart();
                this.updateMonthlyChart();
                this.updateBudgetProgress();
            },

            // ğŸ”§ ì£¼ê°„ ì°¨íŠ¸ ì—…ë°ì´íŠ¸ (ì‹¤ì œ ë°ì´í„°)
            updateChart() {
                const chartEl = document.getElementById('weeklyChart');
                if (!chartEl) return;

                // ì‹¤ì œ API ë°ì´í„°ê°€ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ ë¡œì»¬ ë°ì´í„°
                const weeklyData = this.localCache.weekly || this.generateLocalWeeklyData();

                if (weeklyData.length === 0) return;

                const maxCount = Math.max(...weeklyData.map(d => d.translation_count || 0), 1);

                chartEl.innerHTML = weeklyData.map(dayData => {
                    const count = dayData.translation_count || 0;
                    const height = (count / maxCount) * 100;
                    const date = new Date(dayData.date);
                    const dayLabel = date.toLocaleDateString('ko-KR', { weekday: 'short' });

                    return `<div class="bar" style="height: ${height}%">
                <span class="bar-value">${count}</span>
                <span class="bar-label">${dayLabel}</span>
            </div>`;
                }).join('');
            },

            // ë¡œì»¬ ë°ì´í„°ë¡œ ì£¼ê°„ ì°¨íŠ¸ ìƒì„±
            generateLocalWeeklyData() {
                const weekData = [];
                for (let i = 6; i >= 0; i--) {
                    const date = new Date();
                    date.setDate(date.getDate() - i);
                    const dateStr = date.toISOString().split('T')[0];
                    const dayData = this.localCache.daily[dateStr] || { translations: 0 };

                    weekData.push({
                        date: dateStr,
                        translation_count: dayData.translations
                    });
                }
                return weekData;
            },

            // ğŸ”§ ì›”ë³„ ì°¨íŠ¸ ì—…ë°ì´íŠ¸ (ì‹¤ì œ ë°ì´í„°)
            updateMonthlyChart() {
                const chartEl = document.getElementById('monthlyChart');
                if (!chartEl) return;

                // ì‹¤ì œ API ë°ì´í„°ê°€ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ ë¡œì»¬ ë°ì´í„°
                const monthlyData = this.localCache.monthlyChart || this.generateLocalMonthlyData();

                if (monthlyData.length === 0) return;

                const maxCost = Math.max(...monthlyData.map(m => m.cost || 0), 0.01);

                chartEl.innerHTML = monthlyData.map(monthData => {
                    const cost = monthData.cost || 0;
                    const height = maxCost > 0 ? (cost / maxCost * 100) : 0;
                    const monthLabel = monthData.monthLabel ||
                        new Date(monthData.month + '-01').toLocaleDateString('ko-KR', { month: 'short' });

                    return `<div class="bar" style="height: ${height}%; background: linear-gradient(135deg, #10A37F, #059669);">
                <span class="bar-value">${cost.toFixed(3)}</span>
                <span class="bar-label">${monthLabel}</span>
            </div>`;
                }).join('');
            },

            // ë¡œì»¬ ë°ì´í„°ë¡œ ì›”ë³„ ì°¨íŠ¸ ìƒì„±
            generateLocalMonthlyData() {
                const monthData = [];
                const currentDate = new Date();

                for (let i = 5; i >= 0; i--) {
                    const date = new Date(currentDate.getFullYear(), currentDate.getMonth() - i, 1);
                    const monthStr = date.toISOString().substring(0, 7);
                    const data = this.localCache.monthly[monthStr] || { cost: 0 };

                    monthData.push({
                        month: monthStr,
                        cost: data.cost,
                        monthLabel: date.toLocaleDateString('ko-KR', { month: 'short' })
                    });
                }
                return monthData;
            },

            updateBudgetProgress() {
                const today = new Date().toISOString().split('T')[0];
                const todayCost = this.localCache.daily[today]?.cost || 0;
                const dailyBudget = parseFloat(document.getElementById('dailyBudget')?.value) || 1.00;
                const percentage = Math.min((todayCost / dailyBudget) * 100, 100);

                const progressEl = document.getElementById('budgetProgress');
                const percentageEl = document.getElementById('budgetPercentage');

                if (progressEl) progressEl.style.width = `${percentage}%`;
                if (percentageEl) percentageEl.textContent = `${percentage.toFixed(1)}% ì‚¬ìš©`;

                this.checkLimits();
            },

            checkLimits() {
                const today = new Date().toISOString().split('T')[0];
                const todayCost = this.localCache.daily[today]?.cost || 0;
                const dailyBudget = parseFloat(document.getElementById('dailyBudget')?.value) || 1.00;

                if (todayCost >= dailyBudget) {
                    const limitAction = document.getElementById('limitAction')?.value;
                    if (limitAction === 'switch') {
                        els.ttsEngineMode.value = 'google';
                        showStatus("âš ï¸ ì˜ˆì‚° ë„ë‹¬ - Google TTSë¡œ ì „í™˜", "warning");
                    } else if (limitAction === 'warn') {
                        showStatus("âš ï¸ ì¼ì¼ ì˜ˆì‚°ì„ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤", "warning");
                    } else if (limitAction === 'block') {
                        window.budgetExceeded = true;
                        showStatus("â›” ì˜ˆì‚° ì´ˆê³¼ - ìœ ë£Œ ê¸°ëŠ¥ ì œí•œ", "error");
                    }
                } else {
                    window.budgetExceeded = false;
                }
            }
        };

        // ìºì‹œ ê´€ë¦¬ì
        const cacheManager = { translation: new Map, tts: new Map, recentPlays: [], stats: { hits: 0, misses: 0 }, getTranslation(e) { const t = this.translation.get(e); return t && Date.now() - t.ts < 36e5 ? (this.stats.hits++, t.data) : (this.stats.misses++, null) }, setTranslation(e, t) { this.translation.set(e, { ts: Date.now(), data: t }), this.translation.size > 100 && this.translation.delete(this.translation.keys().next().value) }, getTTS(e) { const t = this.tts.get(e); return t && Date.now() - t.ts < 72e5 ? t.blob : null }, setTTS(e, t) { this.tts.set(e, { ts: Date.now(), blob: t }), this.tts.size > 50 && this.tts.delete(this.tts.keys().next().value) }, addRecentPlay(e, t, s, a) { this.recentPlays.unshift({ text: e, translation: t, lang: s, engine: a }), this.recentPlays.length > 10 && this.recentPlays.pop(), this.save(), updateRecentPlays() }, save() { localStorage.setItem("cacheData", JSON.stringify({ recentPlays: this.recentPlays, stats: this.stats })) }, load() { const e = localStorage.getItem("cacheData"); if (e) { const { recentPlays: t, stats: a } = JSON.parse(e); this.recentPlays = t || [], this.stats = a || { hits: 0, misses: 0 } } }, clear() { this.translation.clear(), this.tts.clear(), this.recentPlays = [], this.stats = { hits: 0, misses: 0 }, this.save() } };

        let currentTranslation = "", currentSource = "", recognition = null, isRecording = !1, isPronunciationEnabled = !0;
        // âœ… ë‹¨ì–´ì¥ ì „ìš© ìŒì„±ì¸ì‹ ê°ì²´ (ì¶©ëŒ ë°©ì§€)
        let practiceRecognition = null;
        const conversationState = { isActive: !1, currentSpeaker: "A", messages: [], autoRecognition: !1 }, langCodeMap = { Korean: "ko-KR", Vietnamese: "vi-VN", English: "en-US" };
        let audioContext = null; const audioQueue = []; let isQueuePlaying = !1;

        // âœ… ì „ë¬¸ìš©ì–´ ê´€ë¦¬ í•¨ìˆ˜ë“¤ (ê°„ì†Œí™”ëœ UI)
        function addTerminology() {
            const input = document.getElementById('terminologyInput').value.trim();

            if (!input) {
                showStatus("ìš©ì–´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš” (ì˜ˆ: AI | ì¸ê³µì§€ëŠ¥)", "warning");
                return;
            }

            // íŒŒì´í”„(|)ë¡œ ë¶„ë¦¬
            const parts = input.split('|').map(part => part.trim());

            if (parts.length !== 2) {
                showStatus("ì˜¬ë°”ë¥¸ í˜•ì‹ìœ¼ë¡œ ì…ë ¥í•˜ì„¸ìš”: ì›ì–´ | ë²ˆì—­ì–´", "warning");
                return;
            }

            const [original, translation] = parts;

            if (!original || !translation) {
                showStatus("ì›ì–´ì™€ ë²ˆì—­ì–´ë¥¼ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”", "warning");
                return;
            }

            if (terminologyDict.has(original)) {
                showStatus("ì´ë¯¸ ë“±ë¡ëœ ìš©ì–´ì…ë‹ˆë‹¤", "warning");
                return;
            }

            terminologyDict.set(original, translation);

            // ì…ë ¥ í•„ë“œ ì´ˆê¸°í™”
            document.getElementById('terminologyInput').value = '';

            updateTerminologyList();
            saveAISettings();
            showStatus(`ğŸ”§ ìš©ì–´ ì¶”ê°€: ${original} â†’ ${translation}`, "success");
        }

        function removeTerminology(original) {
            if (confirm(`"${original}" ìš©ì–´ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                terminologyDict.delete(original);
                updateTerminologyList();
                saveAISettings();
                showStatus(`ğŸ—‘ï¸ ìš©ì–´ ì‚­ì œ: ${original}`, "success");
            }
        }

        function updateTerminologyList() {
            const terminologyListEl = document.getElementById('terminologyList');
            if (!terminologyListEl) return;

            if (terminologyDict.size === 0) {
                terminologyListEl.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 10px; font-size: 12px;">ë“±ë¡ëœ ì „ë¬¸ìš©ì–´ê°€ ì—†ìŠµë‹ˆë‹¤</div>';
                return;
            }

            terminologyListEl.innerHTML = Array.from(terminologyDict.entries()).map(([original, translation]) =>
                `<div class="terminology-item">
            <div class="terminology-text">
                <span class="terminology-original">${original}</span>
                <span class="terminology-arrow">â†’</span>
                <span class="terminology-translated">${translation}</span>
            </div>
            <button class="terminology-remove" onclick="removeTerminology('${original.replace(/'/g, "\\'")}')">ì‚­ì œ</button>
        </div>`
            ).join('');
        }

        function addVocabulary() {
            const original = els.vocabularyOriginal.value.trim();
            const translation = els.vocabularyTranslation.value.trim();
            const description = els.vocabularyDescription.value.trim();

            if (!original || !translation) {
                showStatus("ì›ì–´ì™€ ë²ˆì—­ì–´ë¥¼ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”", "warning");
                return;
            }

            if (vocabularyDict.has(original)) {
                showStatus("ì´ë¯¸ ë“±ë¡ëœ ë‹¨ì–´ì…ë‹ˆë‹¤", "warning");
                return;
            }

            const wordData = {
                original: original,
                translation: translation,
                description: description || "ì„¤ëª… ì—†ìŒ",
                addedDate: new Date().toISOString(),
                correctCount: 0,
                wrongCount: 0,
                practiceTime: 0,
                lastStudied: null
            };

            vocabularyDict.set(original, wordData);

            // ì…ë ¥ í•„ë“œ ì´ˆê¸°í™”
            els.vocabularyOriginal.value = '';
            els.vocabularyTranslation.value = '';
            els.vocabularyDescription.value = '';

            updateVocabularyList();
            updateVocabularyStats();
            saveVocabularyData();
            showStatus(`ğŸ“š ë‹¨ì–´ ì¶”ê°€: ${original} â†’ ${translation}`, "success");
        }

        function showWordDetail(original) {
            const word = vocabularyDict.get(original);
            if (!word) {
                showStatus("ë‹¨ì–´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤", "error");
                return;
            }

            // currentVocabWord ì„¤ì • (ì¤‘ìš”!)
            currentVocabWord = word;

            // DOM ìš”ì†Œ ì¡´ì¬ í™•ì¸
            const wordDetailOriginalEl = document.getElementById('wordDetailOriginal');
            const wordDetailTranslationEl = document.getElementById('wordDetailTranslation');
            const wordDetailPronunciationEl = document.getElementById('wordDetailPronunciation');
            const wordDetailDescriptionEl = document.getElementById('wordDetailDescription');
            const wordDetailModal = document.getElementById('wordDetailModal');

            if (!wordDetailOriginalEl || !wordDetailTranslationEl || !wordDetailPronunciationEl || !wordDetailDescriptionEl || !wordDetailModal) {
                showStatus("ë‹¨ì–´ ìƒì„¸ UI ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤", "error");
                return;
            }

            wordDetailOriginalEl.textContent = word.original;
            wordDetailTranslationEl.textContent = word.translation;
            wordDetailPronunciationEl.textContent = `[${generatePronunciation(word.original)}]`;
            wordDetailDescriptionEl.textContent = word.description;

            wordDetailModal.classList.add('active');
        }

        function closeWordDetail() {
            els.wordDetailModal.classList.remove('active');
            currentVocabWord = null;
        }

        async function speakCurrentWord() {
            if (!currentVocabWord) return;

            // ë‹¨ì–´ì¥ ì „ìš© TTS í•¨ìˆ˜
            await speakVocabularyWord(currentVocabWord.original, currentVocabWord.translation);
        }

        function removeVocabulary(original) {
            if (confirm(`"${original}" ë‹¨ì–´ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) {
                vocabularyDict.delete(original);
                updateVocabularyList();
                updateVocabularyStats();
                saveVocabularyData();
                showStatus(`ğŸ—‘ï¸ ë‹¨ì–´ ì‚­ì œ: ${original}`, "success");
            }
        }

        function startQuiz(difficulty = 'normal') {
            const words = Array.from(vocabularyDict.values());
            if (words.length < 3) {
                showStatus("í€´ì¦ˆë¥¼ ìœ„í•´ì„œëŠ” ìµœì†Œ 3ê°œì˜ ë‹¨ì–´ê°€ í•„ìš”í•©ë‹ˆë‹¤", "warning");
                return;
            }

            let quizWords = words;
            if (difficulty === 'difficult') {
                // ì •ë‹µë¥ ì´ ë‚®ì€ ë‹¨ì–´ë“¤ì„ ìš°ì„ ì ìœ¼ë¡œ ì„ íƒ
                quizWords = words.filter(word => {
                    const total = word.correctCount + word.wrongCount;
                    const accuracy = total > 0 ? word.correctCount / total : 0;
                    return accuracy < 0.7; // ì •ë‹µë¥  70% ë¯¸ë§Œ
                });

                if (quizWords.length < 3) {
                    quizWords = words; // ì–´ë ¤ìš´ ë‹¨ì–´ê°€ ë¶€ì¡±í•˜ë©´ ì „ì²´ì—ì„œ ì„ íƒ
                }
            }

            // ëœë¤ìœ¼ë¡œ ì„ê¸°
            quizWords = shuffleArray([...quizWords]);

            quizState = {
                active: true,
                words: quizWords.slice(0, Math.min(10, quizWords.length)),
                currentIndex: 0,
                correctAnswers: 0,
                wrongAnswers: 0,
                totalQuestions: Math.min(10, quizWords.length),
                selectedAnswer: null
            };

            updateQuizDisplay();
            els.quizModal.classList.add('active');
        }

        function startSingleWordQuiz(wordKey = null) {
            const allWords = Array.from(vocabularyDict.values());
            if (allWords.length < 3) {
                showStatus("í€´ì¦ˆë¥¼ ìœ„í•´ì„œëŠ” ìµœì†Œ 3ê°œì˜ ë‹¨ì–´ê°€ í•„ìš”í•©ë‹ˆë‹¤", "warning");
                return;
            }

            let targetWord;
            if (wordKey && vocabularyDict.has(wordKey)) {
                targetWord = vocabularyDict.get(wordKey);
            } else if (currentVocabWord) {
                targetWord = currentVocabWord;
            } else {
                showStatus("í€´ì¦ˆí•  ë‹¨ì–´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤", "error");
                return;
            }

            quizState = {
                active: true,
                words: [targetWord],
                currentIndex: 0,
                correctAnswers: 0,
                wrongAnswers: 0,
                totalQuestions: 1,
                selectedAnswer: null
            };

            closeWordDetail();
            updateQuizDisplay();
            els.quizModal.classList.add('active');
        }

        function selectQuizOption(optionIndex) {
            if (quizState.selectedAnswer !== null) return; // ì´ë¯¸ ì„ íƒë¨

            quizState.selectedAnswer = optionIndex;

            const options = document.querySelectorAll('.quiz-option');
            const currentWord = quizState.words[quizState.currentIndex];
            const correctIndex = parseInt(options[0].dataset.correct || '0');

            options.forEach((option, index) => {
                option.classList.remove('selected');
                if (index === optionIndex) {
                    option.classList.add('selected');
                }
                if (index === correctIndex) {
                    option.classList.add('correct');
                } else if (index === optionIndex) {
                    option.classList.add('wrong');
                }
            });

            // ì •ë‹µ ì²´í¬
            if (optionIndex === correctIndex) {
                quizState.correctAnswers++;
                currentWord.correctCount++;
                showStatus("âœ… ì •ë‹µ!", "success");
            } else {
                quizState.wrongAnswers++;
                currentWord.wrongCount++;
                showStatus("âŒ ì˜¤ë‹µ!", "error");
            }

            currentWord.lastStudied = new Date().toISOString();

            document.getElementById('quizNextBtn').disabled = false;
            updateQuizStats();
        }

        function nextQuestion() {
            quizState.currentIndex++;
            quizState.selectedAnswer = null;

            if (quizState.currentIndex >= quizState.totalQuestions) {
                showQuizResult();
            } else {
                updateQuizDisplay();
            }

            document.getElementById('quizNextBtn').disabled = true;
        }

        function closeQuiz() {
            els.quizModal.classList.remove('active');
            quizState.active = false;
            saveVocabularyData();
            updateVocabularyStats();
        }

        function startPronunciationPractice() {
            console.log('startPronunciationPractice ì‹œì‘');
            console.log('currentVocabWord:', currentVocabWord);

            if (!currentVocabWord) {
                showStatus("ì„ íƒëœ ë‹¨ì–´ê°€ ì—†ìŠµë‹ˆë‹¤", "warning");
                return;
            }

            // ë‹¨ì–´ ìƒì„¸ ëª¨ë‹¬ë§Œ ë‹«ê¸° (ë‹¨ì–´ì¥ì€ ìœ ì§€)
            closeWordDetail();

            practiceState = {
                active: true,
                currentWord: currentVocabWord,
                isRecording: false,
                practiceTime: Date.now(),
                lastRecording: null,
                recordingStartTime: null
            };

            // DOM ìš”ì†Œ ì¡´ì¬ í™•ì¸ í›„ ì—…ë°ì´íŠ¸
            const practiceWordEl = document.getElementById('practiceWord');
            const practicePronunciationEl = document.getElementById('practicePronunciation');
            const practiceTipsEl = document.getElementById('practiceTips');
            const practiceFeedbackEl = document.getElementById('practiceFeedback');
            const recordBtn = document.getElementById('recordBtn');

            console.log('DOM ìš”ì†Œ í™•ì¸:');
            console.log('practiceWord:', practiceWordEl);
            console.log('practicePronunciation:', practicePronunciationEl);
            console.log('practiceTips:', practiceTipsEl);
            console.log('recordBtn:', recordBtn);

            if (!practiceWordEl || !practicePronunciationEl || !practiceTipsEl || !recordBtn) {
                showStatus("ë°œìŒ ì—°ìŠµ UI ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤", "error");
                return;
            }

            practiceWordEl.textContent = practiceState.currentWord.original;
            practicePronunciationEl.textContent = `[${generatePronunciation(practiceState.currentWord.original)}]`;
            practiceTipsEl.textContent = generatePronunciationTips(practiceState.currentWord.original);

            if (practiceFeedbackEl) {
                practiceFeedbackEl.style.display = 'none';
            }

            recordBtn.classList.remove('recording');
            recordBtn.textContent = 'ğŸ¤';

            // ëª¨ë‹¬ í‘œì‹œ - ê°•ì œ ìŠ¤íƒ€ì¼ ì ìš©
            const practiceModal = document.getElementById('practiceModal');
            if (practiceModal) {
                practiceModal.style.cssText = 'display: flex !important; visibility: visible !important; opacity: 1 !important; position: fixed !important; top: 0 !important; left: 0 !important; right: 0 !important; bottom: 0 !important; z-index: 3000 !important; padding: 20px !important; align-items: center !important; justify-content: center !important;';
                practiceModal.classList.add('active');
            } else {
                showStatus("ë°œìŒ ì—°ìŠµ ëª¨ë‹¬ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤", "error");
            }
        }

        function startWordPractice(wordKey = null) {
            const words = Array.from(vocabularyDict.values());
            if (words.length === 0) {
                showStatus("ì—°ìŠµí•  ë‹¨ì–´ê°€ ì—†ìŠµë‹ˆë‹¤", "warning");
                return;
            }

            let selectedWord;
            if (wordKey && vocabularyDict.has(wordKey)) {
                selectedWord = vocabularyDict.get(wordKey);
            } else {
                selectedWord = words[Math.floor(Math.random() * words.length)];
            }

            // currentVocabWord ì„¤ì •
            currentVocabWord = selectedWord;

            practiceState = {
                active: true,
                currentWord: selectedWord,
                isRecording: false,
                practiceTime: Date.now(),
                lastRecording: null,
                recordingStartTime: null
            };

            // DOM ìš”ì†Œ ì¡´ì¬ í™•ì¸ í›„ ì—…ë°ì´íŠ¸
            const practiceWordEl = document.getElementById('practiceWord');
            const practicePronunciationEl = document.getElementById('practicePronunciation');
            const practiceTipsEl = document.getElementById('practiceTips');
            const practiceFeedbackEl = document.getElementById('practiceFeedback');
            const recordBtn = document.getElementById('recordBtn');

            if (!practiceWordEl || !practicePronunciationEl || !practiceTipsEl || !recordBtn) {
                showStatus("ë°œìŒ ì—°ìŠµ UI ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤", "error");
                return;
            }

            practiceWordEl.textContent = selectedWord.original;
            practicePronunciationEl.textContent = `[${generatePronunciation(selectedWord.original)}]`;
            practiceTipsEl.textContent = generatePronunciationTips(selectedWord.original);

            if (practiceFeedbackEl) {
                practiceFeedbackEl.style.display = 'none';
            }

            recordBtn.classList.remove('recording');
            recordBtn.textContent = 'ğŸ¤';

            // ëª¨ë‹¬ í‘œì‹œ - ë‹¨ì–´ì¥ì€ ìœ ì§€
            const practiceModal = document.getElementById('practiceModal');
            if (practiceModal) {
                practiceModal.style.cssText = 'display: flex !important; visibility: visible !important; opacity: 1 !important; position: fixed !important; top: 0 !important; left: 0 !important; right: 0 !important; bottom: 0 !important; z-index: 3000 !important; padding: 20px !important; align-items: center !important; justify-content: center !important;';
                practiceModal.classList.add('active');
            } else {
                showStatus("ë°œìŒ ì—°ìŠµ ëª¨ë‹¬ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤", "error");
            }
        }

        // âœ… ë‹¨ì–´ì¥ ì „ìš© TTS í•¨ìˆ˜ ì¶”ê°€
        async function speakVocabularyWord(word, translation = null) {
            try {
                // ì–¸ì–´ ìë™ ê°ì§€ - ê°„ë‹¨í•œ ë°©ì‹
                let language = 'English'; // ê¸°ë³¸ê°’
                let useGoogleTTS = true;

                if (/[ê°€-í£]/.test(word)) {
                    language = 'Korean';
                } else if (/[Ã Ã¡áº¡áº£Ã£Ã¢áº§áº¥áº­áº©áº«Äƒáº±áº¯áº·áº³áºµÃ¨Ã©áº¹áº»áº½Ãªá»áº¿á»‡á»ƒá»…Ã¬Ã­á»‹á»‰Ä©Ã²Ã³á»á»ÃµÃ´á»“á»‘á»™á»•á»—Æ¡á»á»›á»£á»Ÿá»¡Ã¹Ãºá»¥á»§Å©Æ°á»«á»©á»±á»­á»¯á»³Ã½á»µá»·á»¹Ä‘Ä]/.test(word)) {
                    language = 'Vietnamese';
                }

                // TTS ì—”ì§„ ì„ íƒ
                const engineMode = els.ttsEngineMode.value;
                if (engineMode === 'openai') {
                    useGoogleTTS = false;
                } else if (engineMode === 'google') {
                    useGoogleTTS = true;
                } else {
                    // auto ëª¨ë“œ: ì§§ì€ ë‹¨ì–´ëŠ” Google, ê¸´ ë‹¨ì–´ëŠ” OpenAI
                    useGoogleTTS = word.length < 50;
                }

                const voiceName = useGoogleTTS ? els.googleVoiceSelect.value : els.voiceSelect.value;
                const cacheKey = `vocab:${word}:${language}:${useGoogleTTS}:${voiceName}`;

                // ìºì‹œ í™•ì¸
                const cachedAudio = cacheManager.getTTS(cacheKey);
                if (cachedAudio) {
                    queueAudioBlob(cachedAudio);
                    showStatus("ğŸ”Š ë‹¨ì–´ ì¬ìƒ (ìºì‹œ)", "success");
                    return;
                }

                showStatus("ğŸ”Š ë‹¨ì–´ ìŒì„± ìƒì„± ì¤‘...", "info");

                const response = await fetch(API_URL, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        action: "speak",
                        inputText: word,
                        language: language,
                        useGoogleTTS: useGoogleTTS,
                        voice: voiceName,
                        voiceName: voiceName
                    })
                });

                if (!response.ok) {
                    throw new Error(`TTS API ì˜¤ë¥˜: ${response.statusText}`);
                }

                const audioBlob = await response.blob();
                cacheManager.setTTS(cacheKey, audioBlob);
                queueAudioBlob(audioBlob);

                showStatus(`ğŸ”Š ${word} ì¬ìƒ ì™„ë£Œ`, "success");

            } catch (error) {
                console.error('ë‹¨ì–´ TTS ì˜¤ë¥˜:', error);
                showStatus(`ìŒì„± ì¬ìƒ ì‹¤íŒ¨: ${error.message}`, "error");
            }
        }

        // âœ… ë°œìŒ ì—°ìŠµ ì „ìš© TTS í•¨ìˆ˜
        async function listenPracticeWord() {
            if (!practiceState.currentWord) return;

            await speakVocabularyWord(practiceState.currentWord.original);
        }

        // âœ… ë‹¨ì–´ì¥ ì „ìš© ìŒì„±ì¸ì‹ ì„¤ì • (ì¶©ëŒ ë°©ì§€)
        function setupPracticeRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                console.error('ìŒì„± ì¸ì‹ì„ ì§€ì›í•˜ì§€ ì•ŠëŠ” ë¸Œë¼ìš°ì €ì…ë‹ˆë‹¤');
                return false;
            }

            practiceRecognition = new SpeechRecognition();
            practiceRecognition.continuous = false;
            practiceRecognition.interimResults = true;

            return true;
        }

        // âœ… ë§ˆì´í¬/ë…¹ìŒ ê¸°ëŠ¥ ì™„ì „ ìˆ˜ì •
        function toggleRecording() {
            if (!practiceState.currentWord) return;

            const recordBtn = document.getElementById('recordBtn');

            if (practiceState.isRecording) {
                // ë…¹ìŒ ì¤‘ì§€
                stopPracticeRecording();
            } else {
                // ë…¹ìŒ ì‹œì‘
                startPracticeRecording();
            }
        }

        function startPracticeRecording() {
            if (!practiceRecognition && !setupPracticeRecognition()) {
                showStatus("ìŒì„± ì¸ì‹ì„ ì§€ì›í•˜ì§€ ì•ŠëŠ” ë¸Œë¼ìš°ì €ì…ë‹ˆë‹¤", "error");
                return;
            }

            // ì–¸ì–´ ì„¤ì •
            const word = practiceState.currentWord.original;
            let langCode = 'en-US'; // ê¸°ë³¸ê°’

            if (/[ê°€-í£]/.test(word)) {
                langCode = 'ko-KR';
            } else if (/[Ã Ã¡áº¡áº£Ã£Ã¢áº§áº¥áº­áº©áº«Äƒáº±áº¯áº·áº³áºµÃ¨Ã©áº¹áº»áº½Ãªá»áº¿á»‡á»ƒá»…Ã¬Ã­á»‹á»‰Ä©Ã²Ã³á»á»ÃµÃ´á»“á»‘á»™á»•á»—Æ¡á»á»›á»£á»Ÿá»¡Ã¹Ãºá»¥á»§Å©Æ°á»«á»©á»±á»­á»¯á»³Ã½á»µá»·á»¹Ä‘Ä]/.test(word)) {
                langCode = 'vi-VN';
            }

            try {
                practiceState.isRecording = true;
                practiceState.recordingStartTime = Date.now();

                const recordBtn = document.getElementById('recordBtn');
                recordBtn.classList.add('recording');
                recordBtn.textContent = 'â¹ï¸';

                practiceRecognition.lang = langCode;

                // ë‹¨ì–´ì¥ ì „ìš© ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
                practiceRecognition.onresult = function (event) {
                    let transcript = '';
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        if (event.results[i].isFinal) {
                            transcript += event.results[i][0].transcript;
                        }
                    }

                    if (transcript.trim()) {
                        practiceState.lastRecording = transcript.trim();
                    }
                };

                practiceRecognition.onend = function () {
                    stopPracticeRecording();
                };

                practiceRecognition.onerror = function (event) {
                    console.error('ë‹¨ì–´ì¥ ìŒì„± ì¸ì‹ ì˜¤ë¥˜:', event.error);
                    showStatus(`ìŒì„± ì¸ì‹ ì˜¤ë¥˜: ${event.error}`, "error");
                    stopPracticeRecording();
                };

                practiceRecognition.start();
                showStatus("ğŸ¤ ë°œìŒì„ ì‹œì‘í•˜ì„¸ìš”...", "info");

            } catch (error) {
                console.error('ë‹¨ì–´ì¥ ë…¹ìŒ ì‹œì‘ ì˜¤ë¥˜:', error);
                showStatus("ë…¹ìŒ ì‹œì‘ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤", "error");
                stopPracticeRecording();
            }
        }

        function stopPracticeRecording() {
            practiceState.isRecording = false;

            const recordBtn = document.getElementById('recordBtn');
            recordBtn.classList.remove('recording');
            recordBtn.textContent = 'ğŸ¤';

            // âœ… ë‹¨ì–´ì¥ ì „ìš© recognition ì¤‘ë‹¨
            if (practiceRecognition && practiceRecognition.abort) {
                practiceRecognition.abort();
            }

            // ë…¹ìŒ ì‹œê°„ ê³„ì‚°
            if (practiceState.recordingStartTime) {
                const recordingTime = Math.floor((Date.now() - practiceState.recordingStartTime) / 1000);
                practiceState.currentWord.practiceTime += recordingTime;
            }

            // í”¼ë“œë°± í‘œì‹œ
            const feedback = document.getElementById('practiceFeedback');
            const feedbackText = document.getElementById('practiceFeedbackText');

            if (practiceState.lastRecording) {
                const originalWord = practiceState.currentWord.original.toLowerCase();
                const recordedWord = practiceState.lastRecording.toLowerCase();

                // ê°„ë‹¨í•œ ìœ ì‚¬ë„ ê²€ì‚¬
                const similarity = calculateSimilarity(originalWord, recordedWord);
                let feedbackMessage = '';

                if (similarity > 0.8) {
                    feedbackMessage = `âœ… í›Œë¥­í•©ë‹ˆë‹¤! "${practiceState.lastRecording}"ë¡œ ì •í™•í•˜ê²Œ ë°œìŒí–ˆìŠµë‹ˆë‹¤.`;
                } else if (similarity > 0.6) {
                    feedbackMessage = `ğŸ‘ ì¢‹ìŠµë‹ˆë‹¤! "${practiceState.lastRecording}"ë¡œ ë“¤ë ¸ìŠµë‹ˆë‹¤. ì¡°ê¸ˆ ë” ëª…í™•í•˜ê²Œ ë°œìŒí•´ë³´ì„¸ìš”.`;
                } else if (similarity > 0.3) {
                    feedbackMessage = `ğŸ“ "${practiceState.lastRecording}"ë¡œ ë“¤ë ¸ìŠµë‹ˆë‹¤. ì •í™•í•œ ë°œìŒì€ "${practiceState.currentWord.original}"ì…ë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ë³´ì„¸ìš”.`;
                } else {
                    feedbackMessage = `ğŸ”„ ëª…í™•í•˜ê²Œ ë“¤ë¦¬ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì²œì²œíˆ ë˜ë°•ë˜ë°• ë°œìŒí•´ë³´ì„¸ìš”.`;
                }

                feedbackText.textContent = feedbackMessage;
                feedback.style.display = 'block';

                // í†µê³„ ì—…ë°ì´íŠ¸
                if (similarity > 0.7) {
                    practiceState.currentWord.correctCount++;
                } else {
                    practiceState.currentWord.wrongCount++;
                }

            } else {
                feedbackText.textContent = "ìŒì„±ì´ ì¸ì‹ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ë§ˆì´í¬ ê¶Œí•œì„ í™•ì¸í•˜ê³  ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.";
                feedback.style.display = 'block';
            }

            practiceState.lastRecording = null;
            practiceState.recordingStartTime = null;

            // ë°ì´í„° ì €ì¥
            saveVocabularyData();
        }

        // í…ìŠ¤íŠ¸ ìœ ì‚¬ë„ ê³„ì‚° í•¨ìˆ˜
        function calculateSimilarity(str1, str2) {
            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;

            if (longer.length === 0) return 1.0;

            const distance = levenshteinDistance(longer, shorter);
            return (longer.length - distance) / longer.length;
        }

        // ë ˆë²¤ìŠˆíƒ€ì¸ ê±°ë¦¬ ê³„ì‚°
        function levenshteinDistance(str1, str2) {
            const matrix = [];

            for (let i = 0; i <= str2.length; i++) {
                matrix[i] = [i];
            }

            for (let j = 0; j <= str1.length; j++) {
                matrix[0][j] = j;
            }

            for (let i = 1; i <= str2.length; i++) {
                for (let j = 1; j <= str1.length; j++) {
                    if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }

            return matrix[str2.length][str1.length];
        }

        function nextPracticeWord() {
            const words = Array.from(vocabularyDict.values());
            if (words.length === 0) return;

            const randomWord = words[Math.floor(Math.random() * words.length)];
            practiceState.currentWord = randomWord;
            practiceState.isRecording = false;
            practiceState.practiceTime = Date.now();
            practiceState.lastRecording = null;
            practiceState.recordingStartTime = null;

            document.getElementById('practiceWord').textContent = randomWord.original;
            document.getElementById('practicePronunciation').textContent = `[${generatePronunciation(randomWord.original)}]`;
            document.getElementById('practiceTips').textContent = generatePronunciationTips(randomWord.original);
            document.getElementById('practiceFeedback').style.display = 'none';

            const recordBtn = document.getElementById('recordBtn');
            recordBtn.classList.remove('recording');
            recordBtn.textContent = 'ğŸ¤';
        }

        function closePractice() {
            // ë…¹ìŒ ì¤‘ì´ë©´ ì¤‘ì§€
            if (practiceState.isRecording) {
                stopPracticeRecording();
            }

            // ìŒì„±ì¸ì‹ ì •ë¦¬
            if (practiceRecognition) {
                try {
                    practiceRecognition.abort();
                } catch (e) {
                    console.log('practiceRecognition ì¤‘ë‹¨ ì¤‘ ì˜¤ë¥˜:', e);
                }
                practiceRecognition = null;
            }

            // ëª¨ë‹¬ ì™„ì „ ìˆ¨ê¹€
            const practiceModal = document.getElementById('practiceModal');
            practiceModal.classList.remove('active');
            practiceModal.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important;';

            practiceState = {
                active: false,
                currentWord: null,
                isRecording: false,
                practiceTime: 0,
                lastRecording: null,
                recordingStartTime: null
            };

            saveVocabularyData();
            updateVocabularyStats();
        }

        // âœ… ë³´ì¡° í•¨ìˆ˜ë“¤
        function switchVocabTab(tabName) {
            // íƒ­ í™œì„±í™”
            document.querySelectorAll('.vocab-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');

            // ì»¨í…ì¸  í‘œì‹œ
            document.querySelectorAll('.vocab-content').forEach(content => {
                content.style.display = 'none';
            });

            const targetContent = document.getElementById(`vocab${tabName.charAt(0).toUpperCase() + tabName.slice(1)}`);
            if (targetContent) {
                targetContent.style.display = 'block';
            }

            // ëª©ë¡ íƒ­ì¼ ë•Œ ì—…ë°ì´íŠ¸
            if (tabName === 'list') {
                updateVocabularyList();
            } else if (tabName === 'stats') {
                updateVocabularyStats();
            }
        }

        function updateVocabularyList() {
            if (!els.vocabularyList) return;

            const words = Array.from(vocabularyDict.values());

            if (words.length === 0) {
                els.vocabularyList.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">ë“±ë¡ëœ ë‹¨ì–´ê°€ ì—†ìŠµë‹ˆë‹¤</div>';
                return;
            }

            els.vocabularyList.innerHTML = words.map(word => {
                const accuracy = word.correctCount + word.wrongCount > 0
                    ? Math.round(word.correctCount / (word.correctCount + word.wrongCount) * 100)
                    : 0;

                return `
            <div class="vocabulary-item" onclick="showWordDetail('${word.original.replace(/'/g, "\\'")}')">
                <div class="vocabulary-word">
                    <div class="vocabulary-word-main">${word.original}</div>
                    <div class="vocabulary-word-sub">${word.translation} (ì •ë‹µë¥ : ${accuracy}%)</div>
                </div>
                <div class="vocabulary-actions">
                    <button class="vocabulary-btn listen" onclick="event.stopPropagation(); speakVocabularyWord('${word.original.replace(/'/g, "\\'")}');" title="ë“£ê¸°">ğŸ”Š</button>
                    <button class="vocabulary-btn practice" onclick="event.stopPropagation(); startWordPractice('${word.original.replace(/'/g, "\\'")}');" title="ì—°ìŠµ">ğŸ¤</button>
                    <button class="vocabulary-btn remove" onclick="event.stopPropagation(); removeVocabulary('${word.original.replace(/'/g, "\\'")}');" title="ì‚­ì œ">ğŸ—‘ï¸</button>
                </div>
            </div>
        `;
            }).join('');
        }

        function updateVocabularyStats() {
            const words = Array.from(vocabularyDict.values());
            const totalWords = words.length;

            let totalCorrect = 0;
            let totalAnswered = 0;
            let totalPracticeTime = 0;

            words.forEach(word => {
                totalCorrect += word.correctCount;
                totalAnswered += word.correctCount + word.wrongCount;
                totalPracticeTime += word.practiceTime || 0;
            });

            const accuracy = totalAnswered > 0 ? Math.round(totalCorrect / totalAnswered * 100) : 0;
            const practiceMinutes = Math.floor(totalPracticeTime / 60);
            const learningProgress = totalWords > 0 ? Math.min(Math.round(accuracy * totalWords / 100), 100) : 0;

            vocabularyStats = {
                totalWords: totalWords,
                quizAccuracy: accuracy,
                practiceTime: practiceMinutes,
                learningProgress: learningProgress
            };

            // UI ì—…ë°ì´íŠ¸
            const elements = {
                totalWords: document.getElementById('totalWords'),
                quizAccuracy: document.getElementById('quizAccuracy'),
                practiceTime: document.getElementById('practiceTime'),
                learningProgress: document.getElementById('learningProgress'),
                progressBar: document.getElementById('progressBar')
            };

            if (elements.totalWords) elements.totalWords.textContent = totalWords;
            if (elements.quizAccuracy) elements.quizAccuracy.textContent = `${accuracy}%`;
            if (elements.practiceTime) elements.practiceTime.textContent = `${practiceMinutes}ë¶„`;
            if (elements.learningProgress) elements.learningProgress.textContent = `${learningProgress}%`;
            if (elements.progressBar) elements.progressBar.style.width = `${learningProgress}%`;
        }

        function loadVocabularyData() {
            try {
                const savedVocab = localStorage.getItem('vocabularyData');
                if (savedVocab) {
                    const data = JSON.parse(savedVocab);
                    vocabularyDict = new Map(data.words || []);
                    vocabularyStats = data.stats || {
                        totalWords: 0,
                        quizAccuracy: 0,
                        practiceTime: 0,
                        learningProgress: 0
                    };
                }

                updateVocabularyList();
                updateVocabularyStats();
            } catch (error) {
                console.error('ë‹¨ì–´ì¥ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', error);
                vocabularyDict = new Map();
                vocabularyStats = {
                    totalWords: 0,
                    quizAccuracy: 0,
                    practiceTime: 0,
                    learningProgress: 0
                };
            }
        }

        function saveVocabularyData() {
            try {
                const data = {
                    words: Array.from(vocabularyDict.entries()),
                    stats: vocabularyStats,
                    lastSaved: new Date().toISOString()
                };
                localStorage.setItem('vocabularyData', JSON.stringify(data));
            } catch (error) {
                console.error('ë‹¨ì–´ì¥ ë°ì´í„° ì €ì¥ ì‹¤íŒ¨:', error);
            }
        }

        // í€´ì¦ˆ ê´€ë ¨ ë³´ì¡° í•¨ìˆ˜ë“¤
        function updateQuizDisplay() {
            if (!quizState.active || quizState.currentIndex >= quizState.words.length) return;

            const currentWord = quizState.words[quizState.currentIndex];
            const progress = (quizState.currentIndex / quizState.totalQuestions) * 100;

            document.getElementById('quizProgressBar').style.width = `${progress}%`;
            document.getElementById('quizCurrent').textContent = quizState.currentIndex + 1;
            document.getElementById('quizTotal').textContent = quizState.totalQuestions;
            document.getElementById('quizCorrect').textContent = quizState.correctAnswers;
            document.getElementById('quizWrong').textContent = quizState.wrongAnswers;

            document.getElementById('quizQuestionText').textContent = currentWord.original;
            document.getElementById('quizQuestionHint').textContent = `"${currentWord.original}"ì˜ ëœ»ì€?`;

            // ì„ íƒì§€ ìƒì„±
            generateQuizOptions(currentWord);

            document.getElementById('quizNextBtn').disabled = true;
            document.getElementById('quizResult').style.display = 'none';
        }

        function generateQuizOptions(correctWord) {
            const allWords = Array.from(vocabularyDict.values());
            const wrongWords = allWords.filter(word => word.original !== correctWord.original);

            // ëœë¤ ì˜¤ë‹µ 3ê°œ ì„ íƒ
            const wrongOptions = shuffleArray(wrongWords).slice(0, 3);
            const options = [correctWord, ...wrongOptions];
            const shuffledOptions = shuffleArray(options);

            const correctIndex = shuffledOptions.findIndex(word => word.original === correctWord.original);

            const optionsContainer = document.getElementById('quizOptions');
            optionsContainer.innerHTML = shuffledOptions.map((word, index) =>
                `<div class="quiz-option" data-correct="${correctIndex}" onclick="selectQuizOption(${index})">
            ${word.translation}
        </div>`
            ).join('');
        }

        function showQuizResult() {
            const accuracy = Math.round((quizState.correctAnswers / quizState.totalQuestions) * 100);

            document.getElementById('quizFinalScore').textContent = `${accuracy}%`;

            let message = '';
            if (accuracy >= 90) {
                message = 'ğŸ‰ ì™„ë²½í•©ë‹ˆë‹¤! í›Œë¥­í•œ ì‹¤ë ¥ì´ì—ìš”!';
            } else if (accuracy >= 70) {
                message = 'ğŸ‘ ì˜í–ˆìŠµë‹ˆë‹¤! ì¡°ê¸ˆë§Œ ë” ì—°ìŠµí•˜ë©´ ì™„ë²½í•´ì§ˆ ê±°ì˜ˆìš”!';
            } else if (accuracy >= 50) {
                message = 'ğŸ“š ë” ì—°ìŠµì´ í•„ìš”í•´ìš”. ë‹¨ì–´ì¥ì„ ë‹¤ì‹œ ì‚´í´ë³´ì„¸ìš”!';
            } else {
                message = 'ğŸ’ª í¬ê¸°í•˜ì§€ ë§ˆì„¸ìš”! ê¾¸ì¤€í•œ ì—°ìŠµì´ ì‹¤ë ¥ í–¥ìƒì˜ ë¹„ê²°ì…ë‹ˆë‹¤!';
            }

            document.getElementById('quizMessage').textContent = message;
            document.getElementById('quizResult').style.display = 'block';

            // ë‹¤ë¥¸ ìš”ì†Œë“¤ ìˆ¨ê¸°ê¸°
            document.querySelector('.quiz-question').style.display = 'none';
            document.querySelector('.quiz-options').style.display = 'none';
            document.querySelector('.quiz-controls').style.display = 'none';
        }

        function updateQuizStats() {
            document.getElementById('quizCorrect').textContent = quizState.correctAnswers;
            document.getElementById('quizWrong').textContent = quizState.wrongAnswers;
        }

        // ë³´ì¡° í•¨ìˆ˜ë“¤
        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function generatePronunciation(word) {
            // ê°„ë‹¨í•œ ë°œìŒ í‘œê¸° ìƒì„± (ì‹¤ì œë¡œëŠ” ë” ë³µì¡í•œ ë¡œì§ í•„ìš”)
            if (/^[a-zA-Z]+$/.test(word)) {
                // ì˜ì–´ ë‹¨ì–´ì¸ ê²½ìš° ê°„ë‹¨í•œ ë°œìŒ í‘œê¸°
                return word.toLowerCase().replace(/[aeiou]/g, match => {
                    const vowelMap = { 'a': 'ã…', 'e': 'ã…“', 'i': 'ã…£', 'o': 'ã…—', 'u': 'ã…œ' };
                    return vowelMap[match] || match;
                });
            } else if (/[ê°€-í£]/.test(word)) {
                // í•œêµ­ì–´ì¸ ê²½ìš° ê·¸ëŒ€ë¡œ ë°˜í™˜
                return word;
            } else {
                // ë² íŠ¸ë‚¨ì–´ë‚˜ ê¸°íƒ€ ì–¸ì–´ì¸ ê²½ìš°
                return word;
            }
        }

        function generatePronunciationTips(word) {
            // ë°œìŒ íŒ ìƒì„±
            if (/^[a-zA-Z]+$/.test(word)) {
                return "ì˜ì–´ ë°œìŒ ì‹œ ì… ëª¨ì–‘ê³¼ í˜€ì˜ ìœ„ì¹˜ì— ì£¼ì˜í•˜ì„¸ìš”. ì²œì²œíˆ ë”°ë¼í•´ë³´ì„¸ìš”.";
            } else if (/[ê°€-í£]/.test(word)) {
                return "í•œêµ­ì–´ ë°œìŒ ì‹œ ì •í™•í•œ ë°›ì¹¨ ë°œìŒì— ì£¼ì˜í•˜ì„¸ìš”.";
            } else {
                return "í•´ë‹¹ ì–¸ì–´ì˜ íŠ¹ì§•ì ì¸ ë°œìŒì— ì£¼ì˜í•˜ì—¬ ì—°ìŠµí•˜ì„¸ìš”.";
            }
        }

        // âœ… ë‹¨ì–´ì¥ ë“œë¡­ë‹¤ìš´ í† ê¸€ í•¨ìˆ˜
        function toggleVocabulary() {
            const vocabDropdown = document.getElementById('vocabularyDropdown');
            const vocabToggle = document.getElementById('vocabToggle');

            vocabDropdown.classList.toggle('active');
            vocabToggle.classList.toggle('active');

            if (vocabDropdown.classList.contains('active')) {
                updateVocabularyList();
                updateVocabularyStats();

                // ë‹¤ë¥¸ ëª¨ë‹¬ë“¤ ë‹«ê¸°
                const dashboardModal = document.getElementById('dashboardModal');
                const settingsPanel = document.getElementById('settingsPanel');
                if (dashboardModal) dashboardModal.classList.remove('active');
                if (settingsPanel) settingsPanel.classList.remove('active');

                // ì™¸ë¶€ í´ë¦­ ì‹œ ë‹«ê¸° ì´ë²¤íŠ¸ ì¶”ê°€
                setTimeout(() => {
                    document.addEventListener('click', closeVocabularyOnOutsideClick);
                }, 100);
            } else {
                document.removeEventListener('click', closeVocabularyOnOutsideClick);
            }
        }

        function closeVocabularyOnOutsideClick(event) {
            const vocabDropdown = document.getElementById('vocabularyDropdown');
            const vocabToggle = document.getElementById('vocabToggle');

            if (!vocabDropdown.contains(event.target) && !vocabToggle.contains(event.target)) {
                vocabDropdown.classList.remove('active');
                vocabToggle.classList.remove('active');
                document.removeEventListener('click', closeVocabularyOnOutsideClick);
            }
        }

        function toggleRecentPlays() {
            const recentPlayList = document.getElementById('recentPlayList');
            const toggleBtn = document.getElementById('recentPlaysToggleBtn');

            if (recentPlayList.style.display === 'none') {
                recentPlayList.style.display = 'block';
                toggleBtn.textContent = 'ì ‘ê¸°';
            } else {
                recentPlayList.style.display = 'none';
                toggleBtn.textContent = 'í¼ì¹˜ê¸°';
            }
        }

        // AI ë¬¸ë§¥ ë²ˆì—­ í•¨ìˆ˜ë“¤
        function toggleAIMode() {
            aiContextMode = !aiContextMode;
            els.aiToggle.classList.toggle('active', aiContextMode);
            els.aiContextBadge.classList.toggle('active', aiContextMode);
            els.translateBtn.classList.toggle('ai-enhanced', aiContextMode);
            els.translateBtnText.textContent = aiContextMode ? 'AI ë²ˆì—­' : 'ë²ˆì—­í•˜ê¸°';
            els.aiSettingsSection.style.display = aiContextMode ? 'block' : 'none';

            if (aiContextMode) {
                showStatus("ğŸ§  AI ë¬¸ë§¥ ë²ˆì—­ ëª¨ë“œ í™œì„±í™”", "success");
            } else {
                showStatus("ğŸ“ ì¼ë°˜ ë²ˆì—­ ëª¨ë“œë¡œ ì „í™˜", "info");
            }

            saveAISettings();
        }

        function buildContextualPrompt(inputText, targetLang) {
            const sourceLang = els.sourceLangSelect.value;
            let prompt = `ë²ˆì—­í•  í…ìŠ¤íŠ¸: "${inputText}"\në²ˆì—­ ë°©í–¥: ${sourceLang} â†’ ${targetLang}\n`;

            // ë²ˆì—­ ìŠ¤íƒ€ì¼ ì ìš©
            const styleInstructions = {
                balanced: "ìì—°ìŠ¤ëŸ½ê³  ê· í˜•ì¡íŒ ë²ˆì—­ì„ ì œê³µí•˜ì„¸ìš”.",
                formal: "ê²©ì‹ìˆê³  ê³µì†í•œ ì–´ì¡°ë¡œ ë²ˆì—­í•˜ì„¸ìš”.",
                casual: "ì¹œê·¼í•˜ê³  í¸ì•ˆí•œ ì–´ì¡°ë¡œ ë²ˆì—­í•˜ì„¸ìš”.",
                literal: "ì›ë¬¸ì˜ ì˜ë¯¸ë¥¼ ì •í™•íˆ ë³´ì¡´í•˜ì—¬ ì§ì—­í•˜ì„¸ìš”."
            };
            prompt += `ë²ˆì—­ ìŠ¤íƒ€ì¼: ${styleInstructions[currentTranslationStyle]}\n`;

            // í’ˆì§ˆ ë ˆë²¨ ì ìš©
            if (qualityLevel >= 4) {
                prompt += "ë§¤ìš° ì •í™•í•˜ê³  ìì—°ìŠ¤ëŸ¬ìš´ ê³ í’ˆì§ˆ ë²ˆì—­ì„ ì œê³µí•˜ì„¸ìš”. ë¬¸í™”ì  ë‰˜ì•™ìŠ¤ì™€ ê´€ìš©í‘œí˜„ì„ ì ì ˆíˆ ë°˜ì˜í•˜ì„¸ìš”.\n";
            } else if (qualityLevel >= 3) {
                prompt += "ì •í™•í•˜ê³  ìì—°ìŠ¤ëŸ¬ìš´ ë²ˆì—­ì„ ì œê³µí•˜ì„¸ìš”.\n";
            }

            // ì „ë¬¸ìš©ì–´ ì‚¬ì „ ì ìš©
            if (terminologyDict.size > 0) {
                prompt += "ë‹¤ìŒ ì „ë¬¸ìš©ì–´ë¥¼ ì¼ê´€ì„±ìˆê²Œ ì‚¬ìš©í•˜ì„¸ìš”:\n";
                terminologyDict.forEach((translation, original) => {
                    prompt += `- "${original}" â†’ "${translation}"\n`;
                });
            }

            // ë¬¸ë§¥ ì •ë³´ ì¶”ê°€ (ìµœê·¼ 5ê°œ ê³ ì •)
            if (translationContext.length > 0) {
                const recentContext = translationContext.slice(-5);
                prompt += "\nì´ì „ ë²ˆì—­ ë§¥ë½:\n";
                recentContext.forEach((ctx, index) => {
                    prompt += `${index + 1}. "${ctx.source}" â†’ "${ctx.translation}"\n`;
                });
                prompt += "\nìœ„ ë§¥ë½ì„ ê³ ë ¤í•˜ì—¬ ì¼ê´€ì„±ìˆê²Œ ë²ˆì—­í•˜ì„¸ìš”.\n";
            }

            return prompt;
        }

        async function handleTranslate() {
            const inputText = els.inputText.value.trim();
            if (!inputText) return;

            const targetLang = els.targetLangSelect.value;
            // ğŸ”§ AI ëª¨ë“œ ê¶Œí•œ ì²´í¬
            if (aiContextMode && !currentUser) {
                showPremiumAlert('AI ë¬¸ë§¥ ë²ˆì—­');
                return;
            }

            // ğŸ”§ ê²ŒìŠ¤íŠ¸ ëª¨ë“œ ì•Œë¦¼ (ì²« ë²ˆì—­ ì‹œì—ë§Œ)
            if (!currentUser && !sessionStorage.getItem('guestWarningShown')) {
                showStatus("ğŸ¯ ê²ŒìŠ¤íŠ¸ ëª¨ë“œë¡œ ì´ìš© ì¤‘ì…ë‹ˆë‹¤. ë¡œê·¸ì¸í•˜ì‹œë©´ ë” ë§ì€ ê¸°ëŠ¥ì„ ì´ìš©í•˜ì‹¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.", "info");
                sessionStorage.setItem('guestWarningShown', 'true');
            }
            const cacheKey = `${inputText}:${targetLang}:${aiContextMode}`;

            // ìºì‹œ í™•ì¸
            const cachedResult = isPronunciationEnabled ? cacheManager.getTranslation(cacheKey) : null;
            if (cachedResult) {
                displayTranslation(cachedResult.translation, cachedResult.pronunciation_hangul, inputText, true);
                showStatus("ğŸ“¦ ìºì‹œì—ì„œ ë¡œë“œë¨", "success");
                updateStats(true);
                return;
            }

            showStatus(aiContextMode ? "ğŸ§  AI ë¬¸ë§¥ ë²ˆì—­ ì¤‘..." : "ë²ˆì—­ ì¤‘...", "info");
            els.cacheIndicator.style.display = "none";
            els.aiIndicator.style.display = aiContextMode ? "inline-block" : "none";

            usageTracker.track("translation", inputText.length);

            try {
                let requestBody;

                if (aiContextMode) {
                    // AI ë¬¸ë§¥ ë²ˆì—­ ìš”ì²­
                    const contextualPrompt = buildContextualPrompt(inputText, targetLang);
                    requestBody = {
                        action: "translate",
                        inputText: inputText,
                        targetLang: targetLang,
                        getPronunciation: isPronunciationEnabled,
                        useAIContext: true,
                        contextualPrompt: contextualPrompt,
                        qualityLevel: qualityLevel,
                        model: getOptimalModel(inputText), // ğŸ¤– AI ëª¨ë¸ ì„ íƒ
                        domain: selectedDomain // ğŸ­ ì „ë¬¸ ë¶„ì•¼
                    };
                } else {
                    // ì¼ë°˜ ë²ˆì—­ ìš”ì²­
                    requestBody = {
                        action: "translate",
                        inputText: inputText,
                        targetLang: targetLang,
                        getPronunciation: isPronunciationEnabled,
                        model: getOptimalModel(inputText), // ğŸ¤– AI ëª¨ë¸ ì„ íƒ
                        domain: selectedDomain // ğŸ­ ì „ë¬¸ ë¶„ì•¼
                    };
                }

                const response = await fetchWithRetry(API_URL, {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        ...(authToken && { "Authorization": `Bearer ${authToken}` })
                    },
                    body: JSON.stringify(requestBody)
                });

                const result = await response.json();
                if (result.error) throw new Error(result.error);

                // ğŸ“ í”¼ë“œë°± í•™ìŠµìš© ë²ˆì—­ ì •ë³´ ì €ì¥
                lastOriginalText = inputText;
                lastOriginalTranslation = result.translation;
                lastTargetLang = targetLang;

                displayTranslation(result.translation, result.pronunciation_hangul, inputText, false);

                // ğŸ“ í”¼ë“œë°± ì ìš© í‘œì‹œ
                if (result.feedbackApplied) {
                    showStatus(`ğŸ“ ì‚¬ìš©ì í”¼ë“œë°± ì ìš©ë¨ (${result.feedbackMatchType === 'exact' ? 'ì •í™• ì¼ì¹˜' : 'ìœ ì‚¬ ì¼ì¹˜'})`, 'success');
                }

                // ë²ˆì—­ ì»¨í…ìŠ¤íŠ¸ì— ì¶”ê°€ (AI ëª¨ë“œì¼ ë•Œë§Œ)
                if (aiContextMode) {
                    translationContext.push({
                        source: inputText,
                        translation: result.translation,
                        timestamp: Date.now()
                    });

                    // ì»¨í…ìŠ¤íŠ¸ í¬ê¸° ì œí•œ
                    if (translationContext.length > 20) {
                        translationContext = translationContext.slice(-20);
                    }
                }

                if (isPronunciationEnabled) {
                    cacheManager.setTranslation(cacheKey, result);
                }

                saveToHistory(inputText, result.translation, els.sourceLangSelect.value, targetLang);
                updateStats(false);
                showStatus(aiContextMode ? "ğŸ§  AI ë²ˆì—­ ì™„ë£Œ" : "ë²ˆì—­ ì™„ë£Œ", "success");

            } catch (error) {
                showStatus(`ë²ˆì—­ ì‹¤íŒ¨: ${error.message}`, "error");
            }
        }

        // AI ì„¤ì • ì €ì¥/ë¡œë“œ
        function saveAISettings() {
            const aiSettings = {
                aiContextMode,
                translationContext: translationContext.slice(-20), // ìµœê·¼ 20ê°œë§Œ ì €ì¥
                currentTranslationStyle,
                qualityLevel,
                terminologyDict: Array.from(terminologyDict.entries()) // ì „ë¬¸ìš©ì–´ ì‚¬ì „ ì €ì¥
            };
            localStorage.setItem('aiSettings', JSON.stringify(aiSettings));
        }

        function loadAISettings() {
            const saved = localStorage.getItem('aiSettings');
            if (saved) {
                try {
                    const aiSettings = JSON.parse(saved);
                    aiContextMode = aiSettings.aiContextMode || false;
                    translationContext = aiSettings.translationContext || [];
                    currentTranslationStyle = aiSettings.currentTranslationStyle || 'balanced';
                    qualityLevel = aiSettings.qualityLevel || 3;

                    // ì „ë¬¸ìš©ì–´ ì‚¬ì „ ë³µì›
                    if (aiSettings.terminologyDict) {
                        terminologyDict = new Map(aiSettings.terminologyDict);
                    }

                    // UI ì—…ë°ì´íŠ¸
                    els.aiToggle.classList.toggle('active', aiContextMode);
                    els.aiContextBadge.classList.toggle('active', aiContextMode);
                    els.translateBtn.classList.toggle('ai-enhanced', aiContextMode);
                    els.translateBtnText.textContent = aiContextMode ? 'AI ë²ˆì—­' : 'ë²ˆì—­í•˜ê¸°';
                    els.aiSettingsSection.style.display = aiContextMode ? 'block' : 'none';
                    els.qualitySlider.value = qualityLevel;

                    // ëª¨ë¸ ì •ë³´ í‘œì‹œ ì´ˆê¸°í™”
                    updateModelInfo(qualityLevel);

                    // ìŠ¤íƒ€ì¼ ë²„íŠ¼ ì—…ë°ì´íŠ¸
                    document.querySelectorAll('.style-btn').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.style === currentTranslationStyle);
                    });

                    // ì „ë¬¸ìš©ì–´ ëª©ë¡ ì—…ë°ì´íŠ¸
                    updateTerminologyList();
                } catch (e) {
                    console.error('AI ì„¤ì • ë¡œë“œ ì‹¤íŒ¨:', e);
                }
            }
        }

        // ê¸°ì¡´ í•¨ìˆ˜ë“¤ (ê¸°ë³¸ ë²ˆì—­ê¸° ê¸°ëŠ¥)

        // ğŸ¤– AI ëª¨ë¸ ì„ íƒ ìƒíƒœ ë³€ìˆ˜
        let selectedAIModel = localStorage.getItem('selectedAIModel') || 'auto';

        // ğŸ­ ì „ë¬¸ ë¶„ì•¼ ì„ íƒ ìƒíƒœ ë³€ìˆ˜
        let selectedDomain = localStorage.getItem('selectedDomain') || 'general';

        // ğŸ­ ì „ë¬¸ ë¶„ì•¼ ì„ íƒ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updateDomainSelection() {
            const select = document.getElementById('domainSelect');
            if (!select) return;

            selectedDomain = select.value;
            localStorage.setItem('selectedDomain', selectedDomain);

            console.log('[Domain] ì„ íƒëœ ë¶„ì•¼:', selectedDomain);

            if (selectedDomain === 'manufacturing') {
                showStatus('ğŸ­ ì œì¡° ìë™í™” ëª¨ë“œ í™œì„±í™” - ì „ë¬¸ ìš©ì–´ ìë™ ì ìš©', 'success');
            }
        }

        // ğŸ“ ë²ˆì—­ í”¼ë“œë°± í•™ìŠµ ë³€ìˆ˜
        let lastOriginalText = '';
        let lastOriginalTranslation = '';
        let lastTargetLang = '';

        // ğŸ“ ë²ˆì—­ í”¼ë“œë°± ì €ì¥ í•¨ìˆ˜
        async function saveTranslationFeedback(correctedTranslation) {
            if (!currentUser || !lastOriginalText) {
                showStatus('âŒ í”¼ë“œë°± ì €ì¥: ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.', 'error');
                return;
            }

            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('authToken')}`
                    },
                    body: JSON.stringify({
                        action: 'save-feedback',
                        originalText: lastOriginalText,
                        originalTranslation: lastOriginalTranslation,
                        correctedTranslation: correctedTranslation,
                        feedbackTargetLang: lastTargetLang
                    })
                });

                const result = await response.json();
                if (result.success) {
                    showStatus('âœ… í”¼ë“œë°± ì €ì¥ ì™„ë£Œ! ë‹¤ìŒì— ë™ì¼í•œ ë¬¸ì¥ ë²ˆì—­ ì‹œ ì ìš©ë©ë‹ˆë‹¤.', 'success');
                } else {
                    showStatus('âŒ í”¼ë“œë°± ì €ì¥ ì‹¤íŒ¨: ' + result.error, 'error');
                }
            } catch (error) {
                console.error('[Feedback] ì €ì¥ ì˜¤ë¥˜:', error);
                showStatus('âŒ í”¼ë“œë°± ì €ì¥ ì¤‘ ì˜¤ë¥˜ ë°œìƒ', 'error');
            }
        }

        // ğŸ“ ë²ˆì—­ ìˆ˜ì • ëª¨ë‹¬ í‘œì‹œ (ë ˆê±°ì‹œ - prompt ë°©ì‹)
        function showEditTranslationModal() {
            if (!lastOriginalTranslation) {
                showStatus('ìˆ˜ì •í•  ë²ˆì—­ì´ ì—†ìŠµë‹ˆë‹¤.', 'error');
                return;
            }

            const corrected = prompt('ğŸ“ ë²ˆì—­ ìˆ˜ì •:\n\nì›ë¬¸: ' + lastOriginalText + '\n\ní˜„ì¬ ë²ˆì—­ì„ ìˆ˜ì •í•´ì£¼ì„¸ìš”:', lastOriginalTranslation);

            if (corrected && corrected !== lastOriginalTranslation) {
                saveTranslationFeedback(corrected);

                // UIì— ìˆ˜ì •ëœ ë²ˆì—­ ì¦‰ì‹œ ë°˜ì˜
                els.translation.textContent = corrected;
                currentTranslation = corrected;
            }
        }

        // ğŸ“ ì¸ë¼ì¸ ë²ˆì—­ ìˆ˜ì • í™œì„±í™”
        function enableTranslationEdit() {
            if (!currentTranslation) return;

            const translationEl = els.translation;
            translationEl.setAttribute('contenteditable', 'true');
            translationEl.focus();

            // ë²„íŠ¼ ìƒíƒœ ë³€ê²½
            document.getElementById('editFeedbackBtn').style.display = 'none';
            document.getElementById('saveFeedbackBtn').style.display = 'inline-flex';
            document.getElementById('cancelFeedbackBtn').style.display = 'inline-flex';

            showStatus('âœï¸ ë²ˆì—­ì„ ìˆ˜ì •í•œ í›„ ì €ì¥ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”', 'info');
        }

        // ğŸ“ ìˆ˜ì • ì·¨ì†Œ
        function cancelTranslationEdit() {
            const translationEl = els.translation;
            translationEl.setAttribute('contenteditable', 'false');
            translationEl.textContent = currentTranslation; // ì›ë˜ ë²ˆì—­ìœ¼ë¡œ ë³µì›

            // ë²„íŠ¼ ìƒíƒœ ë³€ê²½
            document.getElementById('editFeedbackBtn').style.display = 'inline-flex';
            document.getElementById('saveFeedbackBtn').style.display = 'none';
            document.getElementById('cancelFeedbackBtn').style.display = 'none';

            showStatus('ìˆ˜ì •ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤', 'info');
        }

        // ğŸ“ ì¸ë¼ì¸ ë²ˆì—­ í”¼ë“œë°± ì €ì¥ (ì¸ë¼ì¸ í¸ì§‘ ì „ìš©)
        async function saveInlineTranslationFeedback() {
            const translationEl = els.translation;
            const correctedTranslation = translationEl.textContent.trim();

            if (!correctedTranslation) {
                showStatus('ë²ˆì—­ ë‚´ìš©ì´ ë¹„ì–´ìˆìŠµë‹ˆë‹¤', 'error');
                return;
            }

            if (correctedTranslation === lastOriginalTranslation) {
                showStatus('ë³€ê²½ ì‚¬í•­ì´ ì—†ìŠµë‹ˆë‹¤', 'info');
                cancelTranslationEdit();
                return;
            }

            // í¸ì§‘ ëª¨ë“œ ì¢…ë£Œ
            translationEl.setAttribute('contenteditable', 'false');
            document.getElementById('editFeedbackBtn').style.display = 'inline-flex';
            document.getElementById('saveFeedbackBtn').style.display = 'none';
            document.getElementById('cancelFeedbackBtn').style.display = 'none';

            // í”¼ë“œë°± ì €ì¥ í˜¸ì¶œ
            await saveTranslationFeedback(correctedTranslation);

            // í˜„ì¬ ë²ˆì—­ ì—…ë°ì´íŠ¸
            currentTranslation = correctedTranslation;
        }

        // ğŸ”„ ì—­ë²ˆì—­ ê²€ì¦ í•¨ìˆ˜
        async function verifyTranslation() {
            if (!currentTranslation || !lastOriginalText) {
                showStatus('ê²€ì¦í•  ë²ˆì—­ì´ ì—†ìŠµë‹ˆë‹¤', 'error');
                return;
            }

            const verifyBtn = document.querySelector('.btn-verify');
            const resultEl = document.getElementById('verificationResult');

            verifyBtn.disabled = true;
            verifyBtn.textContent = 'ğŸ”„ ê²€ì¦ ì¤‘...';
            resultEl.style.display = 'none';

            try {
                // ì—­ë²ˆì—­ ìš”ì²­ (ë²ˆì—­ëœ ê²°ê³¼ë¥¼ ì›ë˜ ì–¸ì–´ë¡œ ë‹¤ì‹œ ë²ˆì—­)
                const sourceLang = els.sourceLangSelect.value;
                const targetLang = els.targetLangSelect.value;

                const response = await fetchWithRetry(API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...(authToken && { 'Authorization': `Bearer ${authToken}` })
                    },
                    body: JSON.stringify({
                        action: 'translate',
                        inputText: currentTranslation,
                        targetLang: sourceLang, // ì—­ë²ˆì—­: ëŒ€ìƒ ì–¸ì–´ â†’ ì›ë³¸ ì–¸ì–´
                        getPronunciation: false
                    })
                });

                const result = await response.json();
                if (result.error) throw new Error(result.error);

                const backTranslation = result.translation;

                // ìœ ì‚¬ë„ ê³„ì‚° (ê°„ë‹¨í•œ ë‹¨ì–´ ê¸°ë°˜)
                const accuracy = calculateSimilarity(lastOriginalText, backTranslation);

                // ê²°ê³¼ í‘œì‹œ
                showVerificationResult(accuracy, backTranslation);

            } catch (error) {
                showStatus(`ê²€ì¦ ì‹¤íŒ¨: ${error.message}`, 'error');
            } finally {
                verifyBtn.disabled = false;
                verifyBtn.textContent = 'ğŸ”„ ì—­ë²ˆì—­ ê²€ì¦';
            }
        }

        // ğŸ“Š í…ìŠ¤íŠ¸ ìœ ì‚¬ë„ ê³„ì‚°
        function calculateSimilarity(text1, text2) {
            const words1 = text1.toLowerCase().replace(/[^\w\sê°€-í£]/g, '').split(/\s+/);
            const words2 = text2.toLowerCase().replace(/[^\w\sê°€-í£]/g, '').split(/\s+/);

            const set1 = new Set(words1);
            const set2 = new Set(words2);

            const intersection = [...set1].filter(w => set2.has(w));
            const union = new Set([...set1, ...set2]);

            // Jaccard ìœ ì‚¬ë„
            if (union.size === 0) return 0;
            return (intersection.length / union.size) * 100;
        }

        // ğŸ“Š ê²€ì¦ ê²°ê³¼ í‘œì‹œ
        function showVerificationResult(accuracy, backTranslation) {
            const resultEl = document.getElementById('verificationResult');

            let level, emoji, message;
            if (accuracy >= 70) {
                level = 'high';
                emoji = 'âœ…';
                message = 'ë²ˆì—­ í’ˆì§ˆì´ ìš°ìˆ˜í•©ë‹ˆë‹¤!';
            } else if (accuracy >= 40) {
                level = 'medium';
                emoji = 'âš ï¸';
                message = 'ë²ˆì—­ì´ ëŒ€ì²´ë¡œ ì •í™•í•˜ë‚˜ ì¼ë¶€ ë‰˜ì•™ìŠ¤ê°€ ë‹¤ë¥¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.';
            } else {
                level = 'low';
                emoji = 'âŒ';
                message = 'ë²ˆì—­ ì •í™•ë„ê°€ ë‚®ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë¬¸ë§¥ì„ í™•ì¸í•´ì£¼ì„¸ìš”.';
            }

            resultEl.className = `verification-result ${level}`;
            resultEl.innerHTML = `
                <div><strong>${emoji} ì •í™•ë„: ${accuracy.toFixed(0)}%</strong></div>
                <div style="margin-top: 5px; font-size: 12px;">${message}</div>
                <div style="margin-top: 8px; font-size: 11px; color: var(--text-secondary);">
                    <strong>ì—­ë²ˆì—­ ê²°ê³¼:</strong> ${backTranslation}
                </div>
                <div class="accuracy-bar">
                    <div class="accuracy-fill" style="width: ${accuracy}%"></div>
                </div>
            `;
            resultEl.style.display = 'block';
        }

        // ğŸ¤– AI ëª¨ë¸ ì„ íƒ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updateAIModelSelection() {
            const select = document.getElementById('aiModelSelect');
            if (!select) return;

            selectedAIModel = select.value;
            localStorage.setItem('selectedAIModel', selectedAIModel);

            const indicator = document.getElementById('modelIndicator');
            const modelDescriptions = {
                'auto': 'ğŸ”„ <strong>ìë™ ìµœì í™”</strong> - í…ìŠ¤íŠ¸ ê¸¸ì´ì— ë”°ë¼ ìµœì  ëª¨ë¸ ì„ íƒ',
                'gpt-4.1': 'ğŸŸ¢ <strong>GPT-4.1</strong> - ìµœê³  í’ˆì§ˆì˜ ë²ˆì—­ (ë¹„ìš© ë†’ìŒ)',
                'gpt-4.1-mini': 'ğŸŸ¢ <strong>GPT-4.1 Mini</strong> - ë¹ ë¥¸ ë²ˆì—­ ì†ë„ (í’ˆì§ˆ ì–‘í˜¸)',
                'gemini-2.0-flash': 'ğŸ”µ <strong>Gemini 2.0 Flash</strong> - ë§¤ìš° ë¹ ë¦„, ë¹„ìš© ì €ë ´'
            };

            if (indicator) {
                indicator.innerHTML = `í˜„ì¬ ëª¨ë“œ: ${modelDescriptions[selectedAIModel] || modelDescriptions['auto']}`;
            }

            console.log('[AI Model] ì„ íƒëœ ëª¨ë¸:', selectedAIModel);
        }

        // ğŸ¤– í…ìŠ¤íŠ¸ ê¸¸ì´ì— ë”°ë¥¸ ìë™ ëª¨ë¸ ì„ íƒ (í•˜ì´ë¸Œë¦¬ë“œ ëª¨ë“œ)
        function getOptimalModel(text) {
            if (selectedAIModel !== 'auto') {
                return selectedAIModel;
            }

            const charCount = text.length;
            // ìë™ ëª¨ë“œ: ì§§ì€ í…ìŠ¤íŠ¸ â†’ Gemini (ë¹ ë¦„), ê¸´ í…ìŠ¤íŠ¸ â†’ GPT (ì •í™•)
            if (charCount < 100) {
                return 'gemini-2.0-flash';
            } else if (charCount < 500) {
                return 'gpt-4.1-mini';
            } else {
                return 'gpt-4.1';
            }
        }

        // ì˜µì…˜ 1: í’ˆì§ˆ ìŠ¬ë¼ì´ë”ì˜ ëª¨ë¸ ì •ë³´ë¥¼ ì‹¤ì‹œê°„ìœ¼ë¡œ ì—…ë°ì´íŠ¸í•˜ëŠ” í•¨ìˆ˜
        function updateModelInfo(level) {
            const modelConfig = {
                1: { model: 'gemini-2.0-flash', cost: 'ë§¤ìš° ë‚®ìŒ', tokens: '1000', provider: 'Google' },
                2: { model: 'gpt-4.1-mini', cost: 'ë‚®ìŒ', tokens: '1200', provider: 'OpenAI' },
                3: { model: 'gpt-4.1', cost: 'ì¤‘ê°„', tokens: '1500', provider: 'OpenAI' },
                4: { model: 'gpt-4.1', cost: 'ë†’ìŒ', tokens: '2000', provider: 'OpenAI' },
                5: { model: 'gpt-4.1', cost: 'ë§¤ìš° ë†’ìŒ', tokens: '2500', provider: 'OpenAI' }
            };

            const config = modelConfig[level];
            const modelInfoDisplay = document.getElementById('modelInfoDisplay');

            if (modelInfoDisplay && config) {
                const providerIcon = config.provider === 'Google' ? 'ğŸ”µ' : 'ğŸŸ¢';
                modelInfoDisplay.innerHTML = `
            <span class="model-name">${providerIcon} ${config.model}</span>
            <span class="model-cost">ë¹„ìš©: ${config.cost}</span>
            <span class="model-tokens">í† í°: ${config.tokens}</span>
        `;
            }
        }

        // ğŸ“± iOS ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ì ê¸ˆ í•´ì œ (ì „ì—­ ì„¤ì •)
        let audioContextUnlocked = false;
        function unlockAudio() {
            if (audioContextUnlocked) return;
            initAudioContext();
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    audioContextUnlocked = true;
                    // ë¹ˆ ì˜¤ë””ì˜¤ ë²„í¼ ì¬ìƒìœ¼ë¡œ í™•ì‹¤í•˜ê²Œ ì ê¸ˆ í•´ì œ
                    const buffer = audioContext.createBuffer(1, 1, 22050);
                    const source = audioContext.createBufferSource();
                    source.buffer = buffer;
                    source.connect(audioContext.destination);
                    source.start(0);
                });
            } else {
                audioContextUnlocked = true;
            }
            // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±° (í•œ ë²ˆë§Œ ì‹¤í–‰í•˜ë©´ ë¨)
            document.removeEventListener('touchstart', unlockAudio);
            document.removeEventListener('click', unlockAudio);
        }
        document.addEventListener('touchstart', unlockAudio, { passive: true });
        document.addEventListener('click', unlockAudio, { passive: true });

        async function handleSpeak() {
            // ğŸ“± iOS í˜¸í™˜ì„±: ë¹„ë™ê¸° í˜¸ì¶œ ì „ì— ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™” (í•„ìˆ˜)
            initAudioContext();

            if (!currentTranslation) return;
            window.budgetExceeded && (els.ttsEngineMode.value = "google", showStatus("â›” ì˜ˆì‚° ì´ˆê³¼. Google TTSë§Œ ì‚¬ìš© ê°€ëŠ¥", "error"));
            const e = els.targetLangSelect.value, t = els.ttsEngineMode.value;
            const threshold = parseInt(els.autoThreshold.value) || 50; // ì„ê³„ê°’ ì„¤ì •
            let a = "openai";
            if ("google" === t) {
                a = "google";
            } else if ("openai" === t) {
                a = "openai";
            } else if ("auto" === t) {
                // ìë™ ëª¨ë“œ: ë² íŠ¸ë‚¨ì–´ì´ê±°ë‚˜ ì§§ì€ í…ìŠ¤íŠ¸ë©´ Google
                a = ("Vietnamese" === e || currentTranslation.length < threshold) ? "google" : "openai";
            } else if ("smart" === t) {
                // ìŠ¤ë§ˆíŠ¸ ëª¨ë“œ: ì„ê³„ê°’ ê¸°ì¤€ìœ¼ë¡œ ì—”ì§„ ì„ íƒ
                // í…ìŠ¤íŠ¸ê°€ ì„ê³„ê°’ ì´í•˜ë©´ Google (ë¬´ë£Œ), ì´ˆê³¼í•˜ë©´ OpenAI (ê³ í’ˆì§ˆ)
                a = (currentTranslation.length <= threshold) ? "google" : "openai";
            } else {
                a = "openai";
            }
            const s = "google" === a ? els.googleVoiceSelect.value : els.voiceSelect.value, i = `${currentTranslation}:${e}:${a}:${s}`, o = cacheManager.getTTS(i);
            if (els.engineIndicator.textContent = a.charAt(0).toUpperCase(), els.engineIndicator.className = `engine-indicator ${a}`, els.engineIndicator.style.display = "inline-block", o) return queueAudioBlob(o), showStatus("ğŸ”Š ìºì‹œëœ ìŒì„± ì¬ìƒ", "success"), void cacheManager.addRecentPlay(currentSource, currentTranslation, e, a);
            showStatus("ìŒì„± ìƒì„± ì¤‘...", "info"), usageTracker.track("tts", currentTranslation.length, a);
            try {
                const t = await fetch(API_URL, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ action: "speak", inputText: currentTranslation, language: e, useGoogleTTS: "google" === a, voice: s, voiceName: s }) });
                if (!t.ok) throw new Error(`API ì˜¤ë¥˜: ${t.statusText}`);
                const o = await t.blob();
                cacheManager.setTTS(i, o), queueAudioBlob(o), cacheManager.addRecentPlay(currentSource, currentTranslation, e, a), showStatus(`ğŸ”Š ${a} TTS ì¬ìƒ`, "success")
            } catch (e) {
                showStatus(`ìŒì„± ìƒì„± ì‹¤íŒ¨: ${e.message}`, "error")
            }
        }

        function handleVoiceTranslate() { recognition || setupSpeechRecognition(), isRecording ? recognition.stop() : (recognition.lang = langCodeMap[els.sourceLangSelect.value], recognition.start()) }
        function displayTranslation(e, t, a, s) {
            currentTranslation = e;
            currentSource = a;
            els.translation.textContent = e;
            els.translation.setAttribute('contenteditable', 'false'); // í¸ì§‘ ëª¨ë“œ ì´ˆê¸°í™”
            els.pronunciationSection.style.display = isPronunciationEnabled ? "block" : "none";
            isPronunciationEnabled && (els.pronunciationContent.textContent = t || "");
            els.speakBtn.disabled = !1;
            els.copyBtn.disabled = !1;
            els.cacheIndicator.style.display = s ? "inline-block" : "none";

            // ğŸ“ í”¼ë“œë°± í¸ì§‘ ë²„íŠ¼ í‘œì‹œ (ë²ˆì—­ ê²°ê³¼ê°€ ìˆì„ ë•Œ)
            const editBtn = document.getElementById('editFeedbackBtn');
            const verifySection = document.getElementById('verificationSection');
            if (editBtn) editBtn.style.display = e ? 'inline-flex' : 'none';
            if (verifySection) verifySection.style.display = e ? 'block' : 'none';

            // ì €ì¥/ì·¨ì†Œ ë²„íŠ¼ ì´ˆê¸° ìƒíƒœ ìˆ¨ê¹€
            const saveBtn = document.getElementById('saveFeedbackBtn');
            const cancelBtn = document.getElementById('cancelFeedbackBtn');
            if (saveBtn) saveBtn.style.display = 'none';
            if (cancelBtn) cancelBtn.style.display = 'none';

            // ê²€ì¦ ê²°ê³¼ ì´ˆê¸°í™”
            const verifyResult = document.getElementById('verificationResult');
            if (verifyResult) verifyResult.style.display = 'none';
        }
        function setupSpeechRecognition() { const e = window.SpeechRecognition || window.webkitSpeechRecognition; if (!e) return void showStatus("ìŒì„± ì¸ì‹ ë¯¸ì§€ì› ë¸Œë¼ìš°ì €", "error"); recognition = new e, recognition.continuous = !1, recognition.interimResults = !0; let t = ""; recognition.onstart = () => { isRecording = !0, t = "", els.voiceBtn.classList.add("recording") }, recognition.onresult = e => { let a = ""; for (let s = e.resultIndex; s < e.results.length; ++s)e.results[s].isFinal ? t += e.results[s][0].transcript : a += e.results[s][0].transcript; conversationState.isActive || (els.inputText.value = t + a) }, recognition.onend = () => { isRecording = !1, els.voiceBtn.classList.remove("recording"); const e = t.trim(); conversationState.isActive ? e ? handleConversationTranslation(e) : startAutoRecognition() : e && (els.inputText.value = e, handleTranslate()) }, recognition.onerror = e => { showStatus(`ìŒì„± ì¸ì‹ ì˜¤ë¥˜: ${e.error}`, "error"), isRecording = !1, els.voiceBtn.classList.remove("recording") } }
        function toggleDashboard() { els.dashboardModal.classList.toggle("active"), els.dashboardModal.classList.contains("active") && usageTracker.updateDisplay() }
        function toggleSettings() { els.settingsPanel.classList.toggle("active") }
        function toggleTheme() { const e = "dark" === document.documentElement.getAttribute("data-theme") ? "light" : "dark"; document.documentElement.setAttribute("data-theme", e), localStorage.setItem("theme", e) }
        function swapLanguages() { const e = els.sourceLangSelect.value; els.sourceLangSelect.value = els.targetLangSelect.value, els.targetLangSelect.value = e, saveSettings() }
        function copyTranslation() { navigator.clipboard.writeText(currentTranslation).then(() => showStatus("ğŸ“‹ ë²ˆì—­ë¬¸ ë³µì‚¬ ì™„ë£Œ", "success")) }
        function copyInputText() { const e = els.inputText.value; e ? navigator.clipboard.writeText(e).then(() => showStatus("ğŸ“‹ ì›ë¬¸ ë³µì‚¬ ì™„ë£Œ", "success")) : showStatus("ë³µì‚¬í•  ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤", "warning") }
        async function pasteFromClipboard() { try { const e = await navigator.clipboard.readText(); e ? (els.inputText.value += e, showStatus("ğŸ“‹ ë¶™ì—¬ë„£ê¸° ì™„ë£Œ", "success")) : showStatus("í´ë¦½ë³´ë“œê°€ ë¹„ì–´ìˆìŠµë‹ˆë‹¤", "warning") } catch (e) { console.error("ë¶™ì—¬ë„£ê¸° ì‹¤íŒ¨:", e), showStatus("ë¶™ì—¬ë„£ê¸°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤", "error") } }
        function clearAll() { els.inputText.value = "", els.translation.textContent = "", els.pronunciationContent.textContent = "", els.speakBtn.disabled = !0, els.copyBtn.disabled = !0, els.cacheIndicator.style.display = "none", els.aiIndicator.style.display = "none" }
        function showStatus(e, t = "") { els.status.textContent = e, els.status.className = `status ${t}`, setTimeout(() => { els.status.textContent = "", els.status.className = "status" }, 3e3) }
        function clearAllCache() { confirm("ëª¨ë“  ìºì‹œ ë°ì´í„°ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?") && (cacheManager.clear(), updateRecentPlays(), displayStats(), showStatus("âœ¨ ìºì‹œê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.", "success")) }
        function switchToNormalMode() { conversationState.isActive && stopConversation(), els.normalModeBtn.classList.add("active"), els.conversationModeBtn.classList.remove("active"), els.normalMode.classList.remove("hidden"), els.conversationMode.classList.remove("active") }
        function switchToConversationMode() { els.conversationModeBtn.classList.add("active"), els.normalModeBtn.classList.remove("active"), els.normalMode.classList.add("hidden"), els.conversationMode.classList.add("active"), updateActiveSpeaker() }
        function updateSpeakerLanguages() { els.speakerLangA.textContent = els.sourceLangSelect.options[els.sourceLangSelect.selectedIndex].text, els.speakerLangB.textContent = els.targetLangSelect.options[els.targetLangSelect.selectedIndex].text }
        function startConversation() { conversationState.isActive = !0, conversationState.currentSpeaker = "A", conversationState.autoRecognition = !0, els.startConversationBtn.disabled = !0, els.stopConversationBtn.disabled = !1, updateActiveSpeaker(), startAutoRecognition() }
        function stopConversation() { conversationState.isActive = !1, conversationState.autoRecognition = !1, recognition && isRecording && recognition.stop(), els.startConversationBtn.disabled = !1, els.stopConversationBtn.disabled = !0, els.speakerCardA.classList.remove("active"), els.speakerCardB.classList.remove("active") }
        function clearConversation() { conversationState.messages = [], updateConversationHistory() }
        function updateActiveSpeaker() { "A" === conversationState.currentSpeaker ? (els.speakerCardA.classList.add("active"), els.speakerCardB.classList.remove("active")) : (els.speakerCardA.classList.remove("active"), els.speakerCardB.classList.add("active")) }
        async function startAutoRecognition() { if (!conversationState.autoRecognition) return; isRecording && (recognition.stop(), await new Promise(e => setTimeout(e, 100))); const e = "A" === conversationState.currentSpeaker ? els.sourceLangSelect.value : els.targetLangSelect.value; recognition.lang = langCodeMap[e], recognition.start() }
        async function handleConversationTranslation(e) { const t = conversationState.currentSpeaker, a = "B" === t, s = a ? els.targetLangSelect.value : els.sourceLangSelect.value, i = a ? els.sourceLangSelect.value : els.targetLangSelect.value; usageTracker.track("translation", e.length), updateStats(!1); const o = await fetch(API_URL, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ action: "translate", inputText: e, targetLang: i, getPronunciation: !1 }) }), r = await o.json(); conversationState.messages.push({ speaker: t, original: e, translation: r.translation }), updateConversationHistory(), playChunkedAudio(r.chunks || [r.translation], i), conversationState.currentSpeaker = "A" === t ? "B" : "A", updateActiveSpeaker(), setTimeout(startAutoRecognition, 500) }
        function updateConversationHistory() { 0 === conversationState.messages.length ? els.conversationHistory.innerHTML = '<div style="text-align:center; padding: 20px; color: var(--text-secondary);">ëŒ€í™”ë¥¼ ì‹œì‘í•˜ì„¸ìš”</div>' : (els.conversationHistory.innerHTML = conversationState.messages.map(e => `<div class="conversation-message"><div class="message-speaker speaker-${"A" === e.speaker ? "a" : "b"}">${e.speaker}</div><div class="message-content"><div class="message-original">${e.original}</div><div class="message-translation">${e.translation}</div></div></div>`).join(""), els.conversationHistory.scrollTop = els.conversationHistory.scrollHeight) }
        async function playChunkedAudio(e, t) { for (const a of e) { usageTracker.track("tts", a.length, "google"); const e = await fetch(API_URL, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ action: "speak", inputText: a, language: t, useGoogleTTS: !0, voiceName: els.googleVoiceSelect.value }) }); e.ok && queueAudioBlob(await e.blob()) } }
        function initAudioContext() { audioContext || (audioContext = new (window.AudioContext || window.webkitAudioContext)), "suspended" === audioContext?.state && audioContext.resume() }
        async function playAudioBlob(e) {
            try {
                initAudioContext();
                const audioBuffer = await audioContext.decodeAudioData(await e.arrayBuffer());
                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;

                // ğŸ¯ ë³¼ë¥¨ ì¡°ì ˆê¸°(GainNode) ìƒì„±
                const gainNode = audioContext.createGain();

                // ğŸ¯ ì¦í­ ì„¤ì • (1.0ì´ ê¸°ë³¸ê°’, ìˆ«ìë¥¼ í‚¤ìš¸ìˆ˜ë¡ ì†Œë¦¬ê°€ ì»¤ì§‘ë‹ˆë‹¤)
                gainNode.gain.value = 4.5; // ì˜ˆ: 2.5ë°° ì¦í­

                // ğŸ¯ ì˜¤ë””ì˜¤ ì—°ê²°: ì†ŒìŠ¤ -> ë³¼ë¥¨ ì¡°ì ˆê¸° -> ìŠ¤í”¼ì»¤
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);

                source.onended = playNextInQueue;
                source.start(0);
            } catch (t) {
                // Web Audio APIë¥¼ ì§€ì›í•˜ì§€ ì•ŠëŠ” ê²½ìš°ì˜ ëŒ€ì²´ ì½”ë“œ
                const audio = new Audio(URL.createObjectURL(e));
                audio.volume = 1.0; // HTML Audio ìš”ì†Œì˜ ë³¼ë¥¨ì€ 0.0 ~ 1.0
                audio.onended = playNextInQueue;
                audio.play();
            }
        }
        function queueAudioBlob(e) { audioQueue.push(e), isQueuePlaying || playNextInQueue() }
        function playNextInQueue() { if (0 === audioQueue.length) return void (isQueuePlaying = !1); isQueuePlaying = !0, playAudioBlob(audioQueue.shift()) }
        function getStats() { const e = localStorage.getItem("translationStats"); return e ? JSON.parse(e) : { totalTranslations: 0, todayTranslations: 0, lastDate: (new Date).toDateString() } }
        function updateStats(e) { const t = getStats(); (new Date).toDateString() !== t.lastDate && (t.todayTranslations = 0, t.lastDate = (new Date).toDateString()), e || (t.totalTranslations++, t.todayTranslations++), localStorage.setItem("translationStats", JSON.stringify(t)), displayStats() }
        function displayStats() { const e = getStats(); els.todayTranslations.textContent = e.todayTranslations, els.totalTranslations.textContent = e.totalTranslations; const t = cacheManager.stats.hits + cacheManager.stats.misses > 0 ? Math.round(cacheManager.stats.hits / (cacheManager.stats.hits + cacheManager.stats.misses) * 100) : 0; els.cacheHitRate.textContent = `${t}%` }
        function saveToHistory(e, t, a, s) { const i = JSON.parse(localStorage.getItem("translationHistory") || "[]"); i.unshift({ source: e, translation: t, sourceLang: a, targetLang: s, time: (new Date).toLocaleString("ko-KR") }), i.length > 50 && i.pop(), localStorage.setItem("translationHistory", JSON.stringify(i)) }
        function showHistory() { const e = JSON.parse(localStorage.getItem("translationHistory") || "[]"); els.historyList.innerHTML = e.length ? e.map((e, t) => `<div class="recent-play-item" onclick="loadFromHistory(${t})"><div><div class="recent-play-text" style="white-space: normal;"><b>${e.sourceLang}:</b> ${e.source}</div><div class="recent-play-text" style="white-space: normal; color: var(--primary);"><b>${e.targetLang}:</b> ${e.translation}</div></div><small style="color: var(--text-secondary);">${e.time}</small></div>`).join("") : `<p style="text-align:center;">ê¸°ë¡ ì—†ìŒ</p>`, els.historyModal.classList.add("active") }
        function hideHistory() { els.historyModal.classList.remove("active") }
        function loadFromHistory(e) { const t = JSON.parse(localStorage.getItem("translationHistory"))[e]; t && (els.inputText.value = t.source, els.sourceLangSelect.value = t.sourceLang, els.targetLangSelect.value = t.targetLang, hideHistory(), handleTranslate()) }
        function clearHistory() { confirm("ëª¨ë“  ê¸°ë¡ì„ ì‚­ì œí•©ë‹ˆê¹Œ?") && (localStorage.removeItem("translationHistory"), showHistory()) }

        function updateRecentPlays() {
            const recentPlaysEl = els.recentPlays;
            const recentPlayListEl = els.recentPlayList;

            // ìµœê·¼ ì¬ìƒ í•­ëª©ì´ ìˆì„ ë•Œë§Œ í‘œì‹œí•˜ë˜, ê¸°ë³¸ì€ ì ‘íŒ ìƒíƒœ
            if (cacheManager.recentPlays.length > 0) {
                recentPlaysEl.classList.add("active");
                recentPlayListEl.innerHTML = cacheManager.recentPlays.map((e, t) => `<div class="recent-play-item"><div class="recent-play-text">${e.text.substring(0, 25)}...</div><div class="recent-play-actions"><button class="recent-play-btn" onclick="replayRecent(${t})">ğŸ”Š</button><span class="engine-indicator ${e.engine}">${e.engine[0].toUpperCase()}</span></div></div>`).join("");

                // ê¸°ë³¸ ì ‘íŒ ìƒíƒœ ìœ ì§€
                if (!recentPlayListEl.style.display || recentPlayListEl.style.display === 'none') {
                    recentPlayListEl.style.display = 'none';
                    document.getElementById('recentPlaysToggleBtn').textContent = 'í¼ì¹˜ê¸°';
                }
            } else {
                recentPlaysEl.classList.remove("active");
            }
        }

        async function replayRecent(e) { const t = cacheManager.recentPlays[e], a = "google" === t.engine ? els.googleVoiceSelect.value : els.voiceSelect.value, s = `${t.translation}:${t.lang}:${t.engine}:${a}`, i = cacheManager.getTTS(s); if (i) return void queueAudioBlob(i); currentTranslation = t.translation, currentSource = t.text, await handleSpeak() }
        function saveSettings() { localStorage.setItem("ttsEngine", els.ttsEngineMode.value), localStorage.setItem("autoThreshold", els.autoThreshold.value), localStorage.setItem("voice", els.voiceSelect.value), localStorage.setItem("googleVoice", els.googleVoiceSelect.value), localStorage.setItem("volume", els.volumeControl.value), localStorage.setItem("sourceLang", els.sourceLangSelect.value), localStorage.setItem("targetLang", els.targetLangSelect.value), localStorage.setItem("pronunciationEnabled", isPronunciationEnabled) }
        function loadSettings() { document.documentElement.setAttribute("data-theme", localStorage.getItem("theme") || "light"), isPronunciationEnabled = "false" !== localStorage.getItem("pronunciationEnabled"), els.pronunciationToggle.classList.toggle("active", isPronunciationEnabled), els.pronunciationSection.style.display = isPronunciationEnabled ? "block" : "none", els.sourceLangSelect.value = localStorage.getItem("sourceLang") || "Korean", els.targetLangSelect.value = localStorage.getItem("targetLang") || "Vietnamese", els.ttsEngineMode.value = localStorage.getItem("ttsEngine") || "auto", els.autoThreshold.value = localStorage.getItem("autoThreshold") || "50", els.thresholdValue.textContent = `${els.autoThreshold.value}ì`, els.voiceSelect.value = localStorage.getItem("voice") || "nova", els.googleVoiceSelect.value = localStorage.getItem("googleVoice") || "vi-VN-Standard-A", els.volumeControl.value = localStorage.getItem("volume") || "0.8", els.volumeValue.textContent = `${Math.round(100 * els.volumeControl.value)}%`, updateAutoModeVisibility(), document.getElementById("dailyBudget").value = localStorage.getItem("dailyBudget") || "1.00", document.getElementById("monthlyBudget").value = localStorage.getItem("monthlyBudget") || "30.00" }
        function updateAutoModeVisibility() { const e = els.ttsEngineMode.value; els.autoModeSettings.style.display = "auto" === e || "smart" === e ? "grid" : "none" }
        function togglePronunciationView() { const e = els.pronunciationContent; e.style.display = "none" === e.style.display || "" === e.style.display ? "block" : "none", els.pronToggleIcon.textContent = "block" === e.style.display ? "â–¼" : "â–¶" }

        // âœ… ì „ì—­ í•¨ìˆ˜ë¡œ í• ë‹¹ (HTMLì—ì„œ í˜¸ì¶œ ê°€ëŠ¥í•˜ë„ë¡)
        window.addVocabulary = addVocabulary;
        window.showWordDetail = showWordDetail;
        window.closeWordDetail = closeWordDetail;
        window.speakCurrentWord = speakCurrentWord;
        window.removeVocabulary = removeVocabulary;
        window.startQuiz = startQuiz;
        window.startSingleWordQuiz = startSingleWordQuiz;
        window.selectQuizOption = selectQuizOption;
        window.nextQuestion = nextQuestion;
        window.closeQuiz = closeQuiz;
        window.startPronunciationPractice = startPronunciationPractice;
        window.startWordPractice = startWordPractice;
        window.listenPracticeWord = listenPracticeWord;
        window.toggleRecording = toggleRecording;
        window.nextPracticeWord = nextPracticeWord;
        window.closePractice = closePractice;
        window.showPreviousWord = showPreviousWord;
        window.showNextWord = showNextWord;
        window.speakVocabularyWord = speakVocabularyWord;
        // ğŸ”§ ì¶”ê°€: ì¸ì¦ ê´€ë ¨ ì „ì—­ í•¨ìˆ˜ë“¤
        window.toggleAuth = toggleAuth;
        window.toggleApiKeys = toggleApiKeys;
        window.handleLogin = handleLogin;
        window.handleRegister = handleRegister;
        window.continueAsGuest = continueAsGuest;
        window.showForgotPassword = showForgotPassword;
        window.showLoginForm = showLoginForm;
        window.handleForgotPassword = handleForgotPassword;
        window.switchAuthTab = switchAuthTab;
        window.saveOpenAIKey = saveOpenAIKey;
        window.saveGoogleKey = saveGoogleKey;
        window.testOpenAIKey = testOpenAIKey;
        window.testGoogleKey = testGoogleKey;
        window.speakCurrentWord = speakCurrentWord;

        // ğŸ”§ ê¶Œí•œ ì²´í¬ê°€ í¬í•¨ëœ ì „ì—­ í•¨ìˆ˜ë“¤
        window.toggleAIModeWithAuth = toggleAIModeWithAuth;
        window.toggleVocabularyWithAuth = toggleVocabularyWithAuth;
        window.switchVocabTab = switchVocabTab;
        window.addTerminology = addTerminology;
        window.removeTerminology = removeTerminology;

        // ğŸ“ í”¼ë“œë°± ë° ê²€ì¦ ì „ì—­ í•¨ìˆ˜ë“¤
        window.enableTranslationEdit = enableTranslationEdit;
        window.cancelTranslationEdit = cancelTranslationEdit;
        window.saveInlineTranslationFeedback = saveInlineTranslationFeedback;
        window.verifyTranslation = verifyTranslation;

        // ëª¨ë“  ëª¨ë‹¬ ë‹«ê¸° í•¨ìˆ˜
        function closeAllModals() {
            const modals = [
                'practiceModal',
                'wordDetailModal',
                'quizModal',
                'dashboardModal',
                'historyModal',
                'vocabularyDropdown'
            ];

            modals.forEach(modalId => {
                const modal = document.getElementById(modalId);
                if (modal) {
                    modal.classList.remove('active');
                    if (modalId === 'practiceModal') {
                        modal.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important;';
                    }
                }
            });
        }

        // ì´ì „ ë‹¨ì–´ ë³´ê¸°
        function showPreviousWord() {
            const words = Array.from(vocabularyDict.values());
            if (words.length <= 1) return;

            const currentIndex = words.findIndex(word => word.original === currentVocabWord.original);
            const previousIndex = currentIndex > 0 ? currentIndex - 1 : words.length - 1;
            const previousWord = words[previousIndex];

            showWordDetail(previousWord.original);
        }

        // ë‹¤ìŒ ë‹¨ì–´ ë³´ê¸°
        function showNextWord() {
            const words = Array.from(vocabularyDict.values());
            if (words.length <= 1) return;

            const currentIndex = words.findIndex(word => word.original === currentVocabWord.original);
            const nextIndex = currentIndex < words.length - 1 ? currentIndex + 1 : 0;
            const nextWord = words[nextIndex];

            showWordDetail(nextWord.original);
        }

        // âœ… ì´ˆê¸°í™”
        document.addEventListener("DOMContentLoaded", function () {
            try {
                // ì‹œìŠ¤í…œ ì´ˆê¸°í™”
                usageTracker.initialize();
                cacheManager.load();
                loadSettings();
                loadAISettings();
                loadVocabularyData();
                setupSpeechRecognition();
                updateRecentPlays();
                updateSpeakerLanguages();
                displayStats();
                // ğŸ”§ ì¸ì¦ ì‹œìŠ¤í…œ ì´ˆê¸°í™”
                initAuthSystem();

                // ğŸ¤– AI ëª¨ë¸ ì„ íƒ ì´ˆê¸°í™”
                const savedModel = localStorage.getItem('selectedAIModel') || 'auto';
                const aiModelSelect = document.getElementById('aiModelSelect');
                if (aiModelSelect) {
                    aiModelSelect.value = savedModel;
                    updateAIModelSelection();
                }

                // ğŸ­ ì „ë¬¸ ë¶„ì•¼ ì„ íƒ ì´ˆê¸°í™”
                const savedDomain = localStorage.getItem('selectedDomain') || 'general';
                const domainSelect = document.getElementById('domainSelect');
                if (domainSelect) {
                    domainSelect.value = savedDomain;
                }

                // ğŸ”§ UI ìƒíƒœ ì´ˆê¸° ì„¤ì •
                updateAuthUI(!!currentUser);

                // ê¸°ì¡´ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë“¤
                if (els.ttsEngineMode) {
                    els.ttsEngineMode.addEventListener("change", function () {
                        updateAutoModeVisibility();
                        saveSettings();
                    });
                }

                if (els.autoThreshold) {
                    els.autoThreshold.addEventListener("input", function (e) {
                        if (els.thresholdValue) els.thresholdValue.textContent = `${e.target.value}ì`;
                        saveSettings();
                    });
                }

                if (els.volumeControl) {
                    els.volumeControl.addEventListener("input", function (e) {
                        if (els.volumeValue) els.volumeValue.textContent = `${Math.round(100 * e.target.value)}%`;
                        saveSettings();
                    });
                }

                if (els.voiceSelect) {
                    els.voiceSelect.addEventListener("change", saveSettings);
                }

                if (els.googleVoiceSelect) {
                    els.googleVoiceSelect.addEventListener("change", saveSettings);
                }

                if (els.pronunciationToggle) {
                    els.pronunciationToggle.addEventListener("click", function () {
                        isPronunciationEnabled = !isPronunciationEnabled;
                        els.pronunciationToggle.classList.toggle("active", isPronunciationEnabled);
                        if (els.pronunciationSection) {
                            els.pronunciationSection.style.display = isPronunciationEnabled ? "block" : "none";
                        }
                        saveSettings();
                        showStatus(`ë°œìŒ ë„ìš°ë¯¸ ${isPronunciationEnabled ? "ON" : "OFF"}`, "success");
                    });
                }

                const dailyBudgetEl = document.getElementById("dailyBudget");
                const monthlyBudgetEl = document.getElementById("monthlyBudget");

                if (dailyBudgetEl) {
                    dailyBudgetEl.addEventListener("change", function (e) {
                        localStorage.setItem("dailyBudget", e.target.value);
                    });
                }

                if (monthlyBudgetEl) {
                    monthlyBudgetEl.addEventListener("change", function (e) {
                        localStorage.setItem("monthlyBudget", e.target.value);
                    });
                }

                if (els.sourceLangSelect) {
                    els.sourceLangSelect.addEventListener("change", function () {
                        saveSettings();
                        updateSpeakerLanguages();
                    });
                }

                if (els.targetLangSelect) {
                    els.targetLangSelect.addEventListener("change", function () {
                        saveSettings();
                        updateSpeakerLanguages();
                    });
                }

                // AI ê¸°ëŠ¥ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë“¤
                if (els.qualitySlider) {
                    els.qualitySlider.addEventListener("input", function (e) {
                        qualityLevel = parseInt(e.target.value);
                        updateModelInfo(qualityLevel); // ì˜µì…˜ 1: ìŠ¬ë¼ì´ë” ë³€ê²½ ì‹œ ëª¨ë¸ ì •ë³´ ì—…ë°ì´íŠ¸
                        saveAISettings();
                    });
                    // ì´ˆê¸° ëª¨ë¸ ì •ë³´ í‘œì‹œ
                    updateModelInfo(qualityLevel);
                }

                // ë²ˆì—­ ìŠ¤íƒ€ì¼ ë²„íŠ¼ ì´ë²¤íŠ¸
                document.querySelectorAll('.style-btn').forEach(function (btn) {
                    btn.addEventListener('click', function () {
                        document.querySelectorAll('.style-btn').forEach(function (b) {
                            b.classList.remove('active');
                        });
                        btn.classList.add('active');
                        currentTranslationStyle = btn.dataset.style;
                        saveAISettings();
                    });
                });

                // ë‹¨ì–´ì¥ íƒ­ ì´ë²¤íŠ¸
                document.querySelectorAll('.vocab-tab').forEach(function (tab) {
                    tab.addEventListener('click', function () {
                        switchVocabTab(tab.dataset.tab);
                    });
                });

                // ì „ë¬¸ìš©ì–´ ì…ë ¥ í•„ë“œ ì—”í„°í‚¤ ì´ë²¤íŠ¸ (ê°„ì†Œí™”)
                const terminologyInputEl = document.getElementById('terminologyInput');

                if (terminologyInputEl) {
                    terminologyInputEl.addEventListener('keypress', function (e) {
                        if (e.key === 'Enter') {
                            addTerminology();
                        }
                    });
                }

                // ë‹¨ì–´ì¥ ì…ë ¥ í•„ë“œ ì—”í„°í‚¤ ì´ë²¤íŠ¸
                if (els.vocabularyOriginal) {
                    els.vocabularyOriginal.addEventListener('keypress', function (e) {
                        if (e.key === 'Enter' && els.vocabularyTranslation) {
                            els.vocabularyTranslation.focus();
                        }
                    });
                }

                if (els.vocabularyTranslation) {
                    els.vocabularyTranslation.addEventListener('keypress', function (e) {
                        if (e.key === 'Enter' && els.vocabularyDescription) {
                            els.vocabularyDescription.focus();
                        }
                    });
                }

                if (els.vocabularyDescription) {
                    els.vocabularyDescription.addEventListener('keypress', function (e) {
                        if (e.key === 'Enter') {
                            addVocabulary();
                        }
                    });
                }

                // ëª¨ë‹¬ ì™¸ë¶€ í´ë¦­ ì‹œ ë‹«ê¸°
                if (els.wordDetailModal) {
                    els.wordDetailModal.addEventListener('click', function (e) {
                        if (e.target === els.wordDetailModal) {
                            closeWordDetail();
                        }
                    });
                }

                if (els.quizModal) {
                    els.quizModal.addEventListener('click', function (e) {
                        if (e.target === els.quizModal) {
                            closeQuiz();
                        }
                    });
                }

                if (els.practiceModal) {
                    els.practiceModal.addEventListener('click', function (e) {
                        if (e.target === els.practiceModal) {
                            closePractice();
                        }
                    });
                }

                // ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
                ["touchstart", "click"].forEach(function (event) {
                    document.addEventListener(event, initAudioContext, { once: true });
                });

                console.log("âœ… ë²ˆì—­ê¸° v6.0 ì´ˆê¸°í™” ì™„ë£Œ");

                // ğŸš€ ìŠ¤íŠ¸ë¦¬ë° ì„¤ì • ë¡œë“œ
                loadStreamingSettings();

                // ğŸ”§ ëª¨ë“  ëª¨ë‹¬ ê°•ì œ ìˆ¨ê¹€ ì²˜ë¦¬
                // ğŸ”§ ëª¨ë“  ëª¨ë‹¬ ê°•ì œ ìˆ¨ê¹€ ì²˜ë¦¬ (ë¡œê·¸ì¸ ëª¨ë‹¬ ì œì™¸)
                setTimeout(() => {
                    const modals = [
                        'practiceModal',
                        'wordDetailModal',
                        'quizModal',
                        // 'authModal' ì œê±° - ë¡œê·¸ì¸ ëª¨ë‹¬ì€ ìˆ¨ê¸°ì§€ ì•ŠìŒ
                        'dashboardModal',
                        'historyModal',
                        'vocabularyDropdown'
                    ];

                    modals.forEach(modalId => {
                        const modal = document.getElementById(modalId);
                        if (modal) {
                            modal.classList.remove('active');
                            // practiceModalë§Œ íŠ¹ë³„ ì²˜ë¦¬
                            if (modalId === 'practiceModal') {
                                modal.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important; position: fixed !important; top: -9999px !important; left: -9999px !important;';
                                modal.classList.remove('active');
                            }
                            console.log(`[Debug] ${modalId} ê°•ì œ ìˆ¨ê¹€ ì²˜ë¦¬`);
                        }
                    });

                    console.log("[Debug] ëª¨ë‹¬ ìˆ¨ê¹€ ì²˜ë¦¬ ì™„ë£Œ (authModal ì œì™¸)");
                }, 100);

            } catch (error) {
                console.error('ì´ˆê¸°í™” ì˜¤ë¥˜:', error);
                showStatus("âš ï¸ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ ë°œìƒ", "error");
            }
        });
    </script>
</body>

</html>