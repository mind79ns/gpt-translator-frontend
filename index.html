<<<<<<< HEAD
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GPT 양방향 음성 번역기 Pro v6.0 - AI 문맥 번역 고도화</title>
    <link rel="stylesheet" href="css/styles.css">
    <!-- 성능 최적화: CSS 외부 파일로 분리하여 캐싱 가능 -->
</head>
<body>
    <div class="container">
        <div class="header">
            <!-- 제목을 별도 줄로 -->
            <div class="header-title">
                <h1>GPT 번역기 Pro v6.0</h1>
            </div>
            <!-- 아이콘들을 별도 줄로 -->
            <div class="header-controls">
                <button class="ai-toggle" id="aiToggle" onclick="toggleAIModeWithAuth()" title="AI 문맥 번역">🧠</button>
                <button class="vocab-toggle" id="vocabToggle" onclick="toggleVocabularyWithAuth()" title="고급 단어장">📚</button>
                <button class="dashboard-toggle" onclick="toggleDashboard()">📊</button>
                <button class="settings-toggle" onclick="toggleSettings()">⚙️</button>
                <button class="theme-toggle" onclick="toggleTheme()">🌙</button>
                <button class="login-toggle" id="loginToggle" onclick="handleLoginClick()" title="로그인/회원가입">👤</button>
            </div>
            <div class="language-selector">
                <select id="sourceLangSelect"><option value="Korean">한국어</option><option value="Vietnamese">베트남어</option><option value="English">영어</option></select>
                <button onclick="swapLanguages()">⇄</button>
                <select id="targetLangSelect"><option value="Vietnamese">베트남어</option><option value="Korean">한국어</option><option value="English">영어</option></select>
            </div>
            <span class="auto-detect-badge" id="autoDetectBadge"></span>
            <span class="ai-context-badge" id="aiContextBadge">🧠 AI 문맥 번역</span>
        </div>
        
        <div class="content">
            <div class="settings-panel" id="settingsPanel">
                <div class="settings-title"><span>⚙️ 설정</span><button class="settings-close" onclick="toggleSettings()">×</button></div>
                
                <!-- AI 문맥 번역 설정 섹션 -->
                <div class="ai-settings-section" id="aiSettingsSection">
                    <div class="ai-settings-title">🧠 AI 문맥 번역 고도화</div>

                    <div class="setting-item quality-setting-wrapper">
                        <div class="quality-setting-grid">
                            <label class="setting-label">번역 품질 vs 속도<small>높을수록 정확하지만 느림</small></label>
                            <div class="setting-control">
                                <input type="range" class="quality-slider" id="qualitySlider" min="1" max="5" value="3" step="1">
                            </div>
                        </div>
                        <div class="quality-labels">
                            <span>빠름</span><span>균형</span><span>정확</span>
                        </div>
                        <!-- 옵션 1: 실시간 모델 정보 표시 -->
                        <div class="model-info-display" id="modelInfoDisplay">
                            <span class="model-name">모델: gpt-4o</span>
                            <span class="model-cost">비용: 중간</span>
                            <span class="model-tokens">토큰: 1500</span>
                        </div>
                    </div>

                    <div class="setting-item">
                        <label class="setting-label">번역 스타일</label>
                        <div class="style-buttons">
                            <div class="style-btn active" data-style="balanced">균형잡힌</div>
                            <div class="style-btn" data-style="formal">격식체</div>
                            <div class="style-btn" data-style="casual">친근체</div>
                            <div class="style-btn" data-style="literal">직역체</div>
                        </div>
                    </div>

                    <div class="setting-item">
                        <label class="setting-label">🔧 전문용어 사전<small>일관된 번역을 위한 용어집 관리</small></label>
                        <div class="terminology-section">
                            <div class="terminology-input-group">
                                <input type="text" class="terminology-input-single" id="terminologyInput" placeholder="용어 등록: AI | 인공지능">
                                <button onclick="addTerminology()" class="terminology-add-btn">➕</button>
                            </div>
                            <div class="terminology-list" id="terminologyList"></div>
                        </div>
                    </div>
                </div>

                <div class="settings-grid">
                    <div class="setting-item">
                        <label class="setting-label" for="ttsEngineMode">🔊 TTS 엔진 선택<small>Google: 무료/일반 | OpenAI: 유료/고품질</small></label>
                        <div class="setting-control"><select id="ttsEngineMode"><option value="auto">🤖 자동 선택 (추천)</option><option value="google">🔵 Google TTS</option><option value="openai">🟢 OpenAI TTS</option><option value="smart">💡 스마트 모드</option></select></div>
                    </div>
                    <div class="setting-item" id="autoModeSettings">
                        <label class="setting-label" for="autoThreshold">자동 모드 임계값<small>이 글자 수 이하는 Google TTS 사용</small></label>
                        <div class="setting-control"><input type="range" id="autoThreshold" min="10" max="200" value="50" step="10"><span class="setting-value" id="thresholdValue">50자</span></div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label" for="voiceSelect">음성 선택 (OpenAI)</label>
                        <div class="setting-control"><select id="voiceSelect"><option value="nova">Nova (여성/선명)</option><option value="shimmer">Shimmer (여성/부드러움)</option><option value="alloy">Alloy (남성/차분)</option><option value="echo">Echo (남성/깊음)</option><option value="fable">Fable (남성/표현력)</option><option value="onyx">Onyx (남성/저음)</option></select></div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label" for="googleVoiceSelect">음성 선택 (Google)</label>
                        <div class="setting-control"><select id="googleVoiceSelect"><option value="vi-VN-Standard-A">🇻🇳 Standard-A (여)</option><option value="vi-VN-Standard-B">🇻🇳 Standard-B (남)</option><option value="vi-VN-Standard-C">🇻🇳 Standard-C (여)</option><option value="vi-VN-Standard-D">🇻🇳 Standard-D (남)</option><option value="ko-KR-Standard-A">🇰🇷 Standard-A (여)</option><option value="ko-KR-Standard-B">🇰🇷 Standard-B (여)</option><option value="ko-KR-Standard-C">🇰🇷 Standard-C (남)</option><option value="ko-KR-Standard-D">🇰🇷 Standard-D (남)</option></select></div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label" for="volumeControl">볼륨</label>
                        <div class="setting-control"><input type="range" id="volumeControl" min="0.1" max="1" value="0.8" step="0.1"><span class="setting-value" id="volumeValue">80%</span></div>
                    </div>
                    <div class="setting-item">
                         <label class="setting-label">발음 도우미<small>OFF 시 API 요청 비용이 절감됩니다.</small></label>
                         <div class="setting-control"><div class="toggle-switch" id="pronunciationToggle"></div></div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">💾 캐시 설정<small>반복 요청 시 비용 절감 및 속도 향상</small></label>
                        <div class="setting-control"><button onclick="clearAllCache()" style="padding: 6px 12px; font-size: 11px; background-color: var(--error); border: none; border-radius: 5px; color: white;">🗑️ 캐시 초기화</button></div>
                    </div>
                </div>
            </div>

            <div class="recent-plays collapsed" id="recentPlays">
                <div class="recent-plays-title"><span>🔄 최근 재생</span><button class="recent-plays-toggle" onclick="toggleRecentPlays()" id="recentPlaysToggleBtn">펼치기</button></div>
                <div class="recent-play-list" id="recentPlayList" style="display: none;"></div>
            </div>
            
            <div class="mode-selector">
                <div class="mode-btn active" id="normalModeBtn" onclick="switchToNormalMode()">📝 일반 번역</div>
                <div class="mode-btn" id="conversationModeBtn" onclick="switchToConversationMode()">💬 대화 모드</div>
            </div>
            
            <div class="conversation-mode" id="conversationMode">
                <div class="speaker-info">
                    <div class="speaker-card speaker-a" id="speakerCardA"><div class="speaker-title">🙋‍♂️ 화자 A</div><div class="speaker-lang" id="speakerLangA"></div></div>
                    <div class="speaker-card speaker-b" id="speakerCardB"><div class="speaker-title">🙋‍♀️ 화자 B</div><div class="speaker-lang" id="speakerLangB"></div></div>
                </div>
                <div class="conversation-controls">
                    <button class="conv-btn conv-btn-start" id="startConversationBtn" onclick="startConversation()">🎤 시작</button>
                    <button class="conv-btn conv-btn-stop" id="stopConversationBtn" onclick="stopConversation()" disabled>⏹️ 종료</button>
                    <button class="conv-btn conv-btn-clear" onclick="clearConversation()">🗑️ 지우기</button>
                </div>
                <div class="conversation-history" id="conversationHistory"></div>
            </div>
            
            <div class="normal-mode" id="normalMode">
                <div class="input-wrapper">
                    <textarea id="inputText" placeholder="번역할 텍스트를 입력하세요..."></textarea>
                    <div class="input-actions">
                        <button class="input-action-btn" onclick="copyInputText()">복사</button>
                        <button class="input-action-btn" onclick="pasteFromClipboard()">붙여넣기</button>
                    </div>
                </div>
                <div class="controls">
                    <button class="btn-translate" id="translateBtn" onclick="handleTranslate()"><span>📝</span> <span id="translateBtnText">번역하기</span></button>
                    <button class="btn-voice" id="voiceBtn" onclick="handleVoiceTranslate()"><span>🎤</span> 음성 번역</button>
                    <button class="btn-clear" onclick="clearAll()"><span>🗑️</span> 모두 지우기</button>
                    <button class="btn-history" onclick="showHistory()"><span>📜</span> 기록 보기</button>
                </div>
                <div class="result-section">
                    <div class="result-header">
                        <span class="result-label">번역 결과<span id="cacheIndicator" class="cache-indicator" style="display: none;">캐시됨</span><span id="aiIndicator" class="engine-indicator ai" style="display: none;">AI</span></span>
                        <div class="result-actions">
                            <button class="btn-action" onclick="copyTranslation()" id="copyBtn" disabled>📋 복사</button>
                            <button class="btn-action" id="speakBtn" onclick="handleSpeak()" disabled>🔊 듣기<span id="engineIndicator" class="engine-indicator" style="display: none;"></span></button>
                        </div>
                    </div>
                    <div id="translation"></div>
                </div>
                <div class="pronunciation-section" id="pronunciationSection">
                    <div class="pronunciation-label" onclick="togglePronunciationView()">발음 도우미 <span id="pronToggleIcon">▼</span></div>
                    <div id="pronunciation-content"></div>
                </div>
                <div class="translation-stats">
                    <div class="stat-item"><strong id="todayTranslations">0</strong><span>오늘 번역</span></div>
                    <div class="stat-item"><strong id="totalTranslations">0</strong><span>총 번역</span></div>
                    <div class="stat-item"><strong id="cacheHitRate">0%</strong><span>캐시 적중률</span></div>
                </div>
            </div>
            
            <div class="status" id="status"></div>
        </div>
    </div>
    
    <!-- 단어장 드롭다운 모달 -->
<div class="vocabulary-dropdown" id="vocabularyDropdown">
    <div class="vocabulary-dropdown-wrapper">
        <div class="vocabulary-dropdown-header">
            <span>📚 고급 단어장</span>
            <button class="vocabulary-close-btn" onclick="toggleVocabulary()">×</button>
        </div>
        <div class="vocabulary-dropdown-content">
            <div class="vocabulary-tabs">
                <div class="vocab-tab active" data-tab="add">📝 추가</div>
                <div class="vocab-tab" data-tab="list">📖 목록</div>
                <div class="vocab-tab" data-tab="quiz">🎯 퀴즈</div>
                <div class="vocab-tab" data-tab="stats">📊 통계</div>
            </div>
            
            <div class="vocab-content" id="vocabAdd">
                <div class="vocabulary-input-group">
                    <input type="text" class="vocabulary-input" id="vocabularyOriginal" placeholder="원어 (예: Apple)">
                    <input type="text" class="vocabulary-input" id="vocabularyTranslation" placeholder="번역어 (예: 사과)">
                </div>
                <input type="text" class="vocabulary-input description" id="vocabularyDescription" placeholder="상세 설명 (예: 빨갛고 달콤한 과일)">
                <button onclick="addVocabulary()" style="width: 100%; padding: 8px; background: var(--success); color: white; border: none; border-radius: 6px; font-size: 11px; margin-top: 8px;">📚 단어 추가</button>
            </div>
            
            <div class="vocab-content" id="vocabList" style="display: none;">
                <div class="vocabulary-list" id="vocabularyList"></div>
                <div class="vocabulary-stats" id="vocabularyStats">
                    <span>총 단어: <strong id="totalWords">0</strong></span>
                    <span>퀴즈 정답률: <strong id="quizAccuracy">0%</strong></span>
                    <span>연습 시간: <strong id="practiceTime">0분</strong></span>
                </div>
            </div>
            
            <div class="vocab-content" id="vocabQuiz" style="display: none;">
                <button onclick="startQuiz()" style="width: 100%; padding: 12px; background: var(--success); color: white; border: none; border-radius: 8px; font-weight: bold; margin-bottom: 10px;">🎯 랜덤 퀴즈 시작</button>
                <button onclick="startQuiz('difficult')" style="width: 100%; padding: 12px; background: var(--warning); color: white; border: none; border-radius: 8px; font-weight: bold;">💪 어려운 단어 도전</button>
            </div>
            
            <div class="vocab-content" id="vocabStats" style="display: none;">
                <div style="text-align: center; padding: 20px; color: var(--text-secondary);">
                    <div style="font-size: 24px; font-weight: bold; color: var(--success); margin-bottom: 10px;" id="learningProgress">0%</div>
                    <div style="margin-bottom: 15px;">학습 진도</div>
                    <div style="background: var(--border); height: 8px; border-radius: 4px; overflow: hidden; margin-bottom: 15px;">
                        <div id="progressBar" style="background: var(--success); height: 100%; width: 0%; transition: width 0.3s;"></div>
                    </div>
                    <div style="font-size: 12px; color: var(--text-secondary);">꾸준한 학습이 실력 향상의 비결입니다!</div>
                </div>
            </div>
        </div>
    </div>
</div>
    

    <!-- 🔧 수정: 대시보드 모달에 월 비용 카드 추가 -->
    <div class="modal" id="dashboardModal">
        <div class="modal-content-wrapper">
            <div class="modal-header">
                <span class="modal-title">📊 대시보드</span>
                <button class="modal-close" onclick="toggleDashboard()">×</button>
            </div>
            <div class="usage-cards">
                <div class="usage-card">
                    <div class="usage-card-value" id="todayUsage">0</div>
                    <div class="usage-card-label">오늘 번역</div>
                </div>
                <div class="usage-card">
                    <div class="usage-card-value" id="monthUsage">0</div>
                    <div class="usage-card-label">이번 달</div>
                </div>
                <div class="usage-card">
                    <div class="usage-card-value" id="todayCost">$0.00</div>
                    <div class="usage-card-label">오늘 비용</div>
                </div>
                <!-- ➕ 새로 추가: 해당 월 비용 카드 -->
                <div class="usage-card">
                    <div class="usage-card-value" id="monthCost">$0.00</div>
                    <div class="usage-card-label">이번 달 비용</div>
                </div>
                <div class="usage-card">
                    <div class="usage-card-value" id="savedCost">$0.00</div>
                    <div class="usage-card-label">절감 비용</div>
                </div>
            </div>
            <div class="chart-container">
                <div class="chart-title">📈 7일 사용량</div>
                <div class="simple-bar-chart" id="weeklyChart"></div>
            </div>
            <!-- ➕ 새로 추가: 월별 비용 차트 -->
            <div class="chart-container">
                <div class="chart-title">💰 월별 비용 추이 (최근 6개월)</div>
                <div class="simple-bar-chart" id="monthlyChart"></div>
            </div>
            <div class="limit-settings">
                <div class="limit-title">⚠️ API 한도 관리</div>
                <div class="limit-item">
                    <span class="limit-label">일일 예산 ($)</span>
                    <input type="number" class="limit-input" id="dailyBudget" value="1.00" step="0.10">
                </div>
                <div class="limit-item">
                    <span class="limit-label">월간 예산 ($)</span>
                    <input type="number" class="limit-input" id="monthlyBudget" value="30.00" step="1.00">
                </div>
                <div class="limit-progress">
                    <div class="limit-progress-bar" id="budgetProgress"></div>
                </div>
                <div class="limit-percentage" id="budgetPercentage">0% 사용</div>
                <div class="limit-item" style="margin-top: 15px;">
                    <span class="limit-label">한도 도달 시</span>
                    <select id="limitAction" style="width: 150px; padding: 5px; border-radius: 5px; font-size: 12px;">
                        <option value="switch">Google로 전환</option>
                        <option value="warn">경고만</option>
                        <option value="block">차단</option>
                    </select>
                </div>
            </div>
        </div>
    </div>
    
    <div class="modal" id="historyModal"><div class="modal-content-wrapper"><div class="modal-header"><span class="modal-title">📜 번역 기록</span><button class="modal-close" onclick="hideHistory()">×</button></div><div id="historyList" style="max-height: 400px; overflow-y: auto;"></div><button onclick="clearHistory()" style="width: 100%; margin-top: 15px; background: var(--error); color: white; border: none; border-radius: 5px; padding: 8px;">기록 모두 삭제</button></div></div>
    
    <!-- 단어 상세 모달 -->
    <div class="word-detail-modal" id="wordDetailModal">
        <div class="word-detail-content">
            <div class="word-detail-header">
                <span class="word-detail-title">📚 단어 상세</span>
                <button class="word-detail-close" onclick="closeWordDetail()">×</button>
            </div>
            <div class="word-detail-main">
                <div class="word-detail-original" id="wordDetailOriginal"></div>
                <div class="word-detail-translation" id="wordDetailTranslation"></div>
                <div class="word-detail-pronunciation" id="wordDetailPronunciation"></div>
            </div>
            <div class="word-detail-description">
                <div class="word-detail-description-title">📝 상세 설명</div>
                <div class="word-detail-description-text" id="wordDetailDescription"></div>
            </div>
           <div class="word-detail-actions">
    <button class="word-detail-btn speak" onclick="speakCurrentWord()">🔊 발음</button>
    <button class="word-detail-btn quiz" onclick="startSingleWordQuiz()">🎯 퀴즈</button>
    <button class="word-detail-btn practice" onclick="startPronunciationPractice()">🎤 연습</button>
</div>
<div style="display: flex; gap: 10px; justify-content: center; margin-top: 15px;">
    <button class="word-detail-btn" style="background: var(--text-secondary);" onclick="showPreviousWord()">⬅️ 이전</button>
    <button class="word-detail-btn" style="background: var(--text-secondary);" onclick="showNextWord()">다음 ➡️</button>
</div>
        </div>
    </div>
    
    <!-- 퀴즈 모달 -->
    <div class="quiz-modal" id="quizModal">
        <div class="quiz-content">
            <div class="quiz-header">
                <div class="quiz-title">🎯 단어 퀴즈</div>
                <div class="quiz-progress">
                    <div class="quiz-progress-bar" id="quizProgressBar"></div>
                </div>
                <div class="quiz-stats">
                    <span>문제: <strong id="quizCurrent">1</strong>/<strong id="quizTotal">10</strong></span>
                    <span>정답: <strong id="quizCorrect">0</strong></span>
                    <span>오답: <strong id="quizWrong">0</strong></span>
                </div>
            </div>
            <div class="quiz-question">
                <div class="quiz-question-text" id="quizQuestionText"></div>
                <div class="quiz-question-hint" id="quizQuestionHint"></div>
            </div>
            <div class="quiz-options" id="quizOptions"></div>
            <div class="quiz-controls">
                <button class="quiz-btn secondary" onclick="closeQuiz()">나가기</button>
                <button class="quiz-btn primary" id="quizNextBtn" onclick="nextQuestion()" disabled>다음</button>
            </div>
            <div class="quiz-result" id="quizResult" style="display: none;">
                <div class="quiz-score" id="quizFinalScore"></div>
                <div class="quiz-message" id="quizMessage"></div>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="quiz-btn primary" onclick="startQuiz()">다시 시작</button>
                    <button class="quiz-btn secondary" onclick="closeQuiz()">완료</button>
                </div>
            </div>
        </div>
    </div>
</div>
<!-- 발음 연습 모달 -->
    <div class="practice-modal" id="practiceModal">
        <div class="practice-content">
            <div class="practice-title">🎤 발음 연습</div>
            <div class="practice-word" id="practiceWord"></div>
            <div class="practice-pronunciation" id="practicePronunciation"></div>
            <div class="practice-controls">
                <button class="practice-btn listen" onclick="listenPracticeWord()" title="듣기">🔊</button>
                <button class="practice-btn record" id="recordBtn" onclick="toggleRecording()" title="녹음">🎤</button>
            </div>
            <div class="practice-feedback" id="practiceFeedback" style="display: none;">
                <div class="practice-feedback-title">🔊 발음 피드백</div>
                <div class="practice-feedback-text" id="practiceFeedbackText"></div>
            </div>
            <div class="practice-tips">
                <div class="practice-tips-title">💡 발음 팁</div>
                <div class="practice-tips-text" id="practiceTips"></div>
            </div>
            <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                <button class="quiz-btn primary" onclick="nextPracticeWord()">다음 단어</button>
                <button class="quiz-btn secondary" onclick="closePractice()">완료</button>
            </div>
        </div>
    </div>
        <!-- 🔐 로그인/회원가입 모달 -->
 <div class="auth-modal" id="authModal">
    <div class="auth-content">
        <div class="auth-header">
            <div class="auth-tabs">
                <button class="auth-tab active" data-tab="login">🔑 로그인</button>
                <button class="auth-tab" data-tab="register">📝 회원가입</button>
            </div>
            <button class="auth-close" onclick="toggleAuth()">×</button>
        </div>

        <div class="auth-form active" id="loginForm">
            <div class="auth-form-title">GPT 번역기 Pro 로그인</div>
            <div class="auth-input-group">
                <input type="email" id="loginEmail" placeholder="이메일 주소" required>
                <input type="password" id="loginPassword" placeholder="비밀번호" required>
            </div>
            <button class="auth-btn primary" onclick="handleLogin()">🔑 로그인</button>
            <div class="auth-divider">또는</div>
            <button class="auth-btn guest" onclick="continueAsGuest()">🎯 게스트로 계속하기</button>
             <div class="auth-links">
                <a href="#" onclick="event.preventDefault(); switchAuthTab('forgot');">비밀번호를 잊으셨나요?</a>
            </div>
        </div>

        <div class="auth-form" id="registerForm">
            <div class="auth-form-title">새 계정 만들기</div>
            <div class="auth-input-group">
                <input type="text" id="registerName" placeholder="이름 (선택사항)">
                <input type="email" id="registerEmail" placeholder="이메일 주소" required>
                <input type="password" id="registerPassword" placeholder="비밀번호 (8자 이상)" required>
                <input type="password" id="registerPasswordConfirm" placeholder="비밀번호 확인" required>
            </div>
            <div class="auth-agreement">
                <label class="auth-checkbox">
                    <input type="checkbox" id="agreeTerms" required>
                    <span>서비스 이용약관 및 개인정보처리방침에 동의합니다</span>
                </label>
            </div>
            <button class="auth-btn primary" onclick="handleRegister()">📝 회원가입</button>
            <div class="auth-links">
                <a href="#" onclick="event.preventDefault(); switchAuthTab('login');">← 로그인으로 돌아가기</a>
            </div>
        </div>

        <div class="auth-form" id="forgotForm">
            <div class="auth-form-title">비밀번호 재설정</div>
            <div class="auth-input-group">
                <input type="email" id="forgotEmail" placeholder="가입한 이메일 주소" required>
            </div>
            <button class="auth-btn primary" onclick="handleForgotPassword()">📧 재설정 링크 보내기</button>
            <div class="auth-links">
                <a href="#" onclick="event.preventDefault(); switchAuthTab('login');">← 로그인으로 돌아가기</a>
            </div>
        </div>
    </div>
</div>

    <div class="auth-info">
        </div>
</div>
                <div class="auth-info">
                    <small>• 개인 API 키 등록으로 무제한 번역</small>
                    <small>• 사용량 추적 및 분석</small>
                    <small>• 고급 단어장 및 학습 기록 저장</small>
                </div>
            </div>
            
            <!-- 비밀번호 찾기 폼 -->
            <div class="auth-form" id="forgotForm" style="display: none;">
                <div class="auth-form-title">비밀번호 재설정</div>
                <div class="auth-input-group">
                    <input type="email" id="forgotEmail" placeholder="가입한 이메일 주소" required>
                </div>
                <button class="auth-btn primary" onclick="handleForgotPassword()">📧 재설정 링크 보내기</button>
                <div class="auth-links">
                    <a href="#" onclick="showLoginForm()">← 로그인으로 돌아가기</a>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 🔧 API 키 관리 모달 -->
    <div class="api-keys-modal" id="apiKeysModal">
        <div class="api-keys-content">
            <div class="api-keys-header">
                <span class="api-keys-title">🔑 API 키 관리</span>
                <button class="api-keys-close" onclick="toggleApiKeys()">×</button>
            </div>
            <div class="api-keys-body">
                <div class="api-key-section">
                    <div class="api-key-title">🤖 OpenAI API 키</div>
                    <div class="api-key-description">번역 및 TTS 기능을 위한 OpenAI API 키를 등록하세요</div>
                    <div class="api-key-input-group">
                        <input type="password" id="openaiApiKey" placeholder="sk-..." maxlength="200">
                        <button class="api-key-btn test" onclick="testOpenAIKey()">테스트</button>
                        <button class="api-key-btn save" onclick="saveOpenAIKey()">저장</button>
                    </div>
                    <div class="api-key-status" id="openaiKeyStatus"></div>
                </div>
                
                <div class="api-key-section">
                    <div class="api-key-title">🎤 Google TTS API 키</div>
                    <div class="api-key-description">고품질 음성 합성을 위한 Google Cloud API 키 (선택사항)</div>
                    <div class="api-key-input-group">
                        <input type="password" id="googleApiKey" placeholder="AIza..." maxlength="200">
                        <button class="api-key-btn test" onclick="testGoogleKey()">테스트</button>
                        <button class="api-key-btn save" onclick="saveGoogleKey()">저장</button>
                    </div>
                    <div class="api-key-status" id="googleKeyStatus"></div>
                </div>
                
                <div class="api-key-info">
                    <div class="api-key-info-title">💡 API 키 사용 혜택</div>
                    <ul>
                        <li>✅ 무제한 번역 및 TTS 사용</li>
                        <li>✅ 개인 사용량 및 비용 추적</li>
                        <li>✅ 더 빠른 응답 속도</li>
                        <li>✅ 프리미엄 기능 이용</li>
                    </ul>
                    <div class="api-key-help">
                        <a href="https://platform.openai.com/api-keys" target="_blank">OpenAI API 키 발급받기 →</a>
                        <br>
                        <a href="https://console.cloud.google.com/" target="_blank">Google Cloud API 키 발급받기 →</a>
                    </div>
                </div>
            </div>
        </div>
    </div>
        
<script>
// ========== localStorage 비동기 래퍼 (성능 최적화) ==========
// UI 블로킹 방지를 위한 비동기 스토리지 유틸리티

const AsyncStorage = {
    // 읽기 (Promise 기반)
    async getItem(key) {
        return new Promise((resolve) => {
            // requestIdleCallback으로 유휴 시간에 실행
            if ('requestIdleCallback' in window) {
                requestIdleCallback(() => {
                    resolve(localStorage.getItem(key));
                });
            } else {
                // Fallback: setTimeout으로 마이크로태스크 큐에 추가
                setTimeout(() => {
                    resolve(localStorage.getItem(key));
                }, 0);
            }
        });
    },

    // 쓰기 (Promise 기반)
    async setItem(key, value) {
        return new Promise((resolve) => {
            if ('requestIdleCallback' in window) {
                requestIdleCallback(() => {
                    localStorage.setItem(key, value);
                    resolve();
                });
            } else {
                setTimeout(() => {
                    localStorage.setItem(key, value);
                    resolve();
                }, 0);
            }
        });
    },

    // 삭제 (Promise 기반)
    async removeItem(key) {
        return new Promise((resolve) => {
            if ('requestIdleCallback' in window) {
                requestIdleCallback(() => {
                    localStorage.removeItem(key);
                    resolve();
                });
            } else {
                setTimeout(() => {
                    localStorage.removeItem(key);
                    resolve();
                }, 0);
            }
        });
    },

    // 동기식 읽기 (즉시 필요한 경우만 사용)
    getItemSync(key) {
        return localStorage.getItem(key);
    },

    // 동기식 쓰기 (즉시 필요한 경우만 사용)
    setItemSync(key, value) {
        localStorage.setItem(key, value);
    }
};

// 디바운스 유틸리티 (빈번한 저장 방지)
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// ===================================================
// GPT 양방향 음성 번역기 Pro v6.0 - AI 문맥 번역 고도화
// ===================================================
const API_URL = 'https://knstranslator.netlify.app/.netlify/functions/translate';
const AUTH_API_URL = 'https://knstranslator.netlify.app/.netlify/functions/auth'; // 🔧 추가: 인증 API URL

// 🔐 사용자 인증 시스템
let currentUser = null;
let authToken = null;

// 🔐 인증 상태 관리 (개선)
async function initAuthSystem() {
    console.log('[Auth] 시스템 초기화 시작');
    
    // 저장된 토큰 확인
    const savedToken = localStorage.getItem('authToken');
    const savedUser = localStorage.getItem('currentUser');
    
    if (savedToken && savedUser) {
        try {
            // 🔧 개선: 실제 토큰 검증
            const isValidToken = await verifyStoredToken(savedToken);
            
            if (isValidToken) {
                authToken = savedToken;
                currentUser = JSON.parse(savedUser);
                updateAuthUI(true);
                
                console.log('[Auth] 사용자 세션 복원 성공:', currentUser.email);
                
                // 🔧 추가: 사용자 데이터 새로고침
                await refreshUserData();
                
                showStatus(`👋 ${currentUser.displayName || currentUser.email}님 환영합니다!`, "success");
            } else {
                console.log('[Auth] 저장된 토큰이 만료되었습니다');
                clearAuthData();
                updateAuthUI(false);
                showStatus("세션이 만료되었습니다. 다시 로그인해주세요", "warning");
            }
        } catch (error) {
            console.error('[Auth] 세션 복원 실패:', error);
            clearAuthData();
            updateAuthUI(false);
        }
    } else {
        console.log('[Auth] 저장된 인증 정보 없음 - 게스트 모드');
        updateAuthUI(false);
    }
    
    // 🔧 추가: 인증 관련 이벤트 리스너 설정
    setupAuthEventListeners();
}

// 🔐 저장된 토큰 검증
async function verifyStoredToken(token) {
    try {
        const response = await fetch(AUTH_API_URL, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({
                action: 'verify-token'
            })
        });
        
        const result = await response.json();
        return result.success || false;
        
    } catch (error) {
        console.error('[Auth] 토큰 검증 오류:', error);
        return false;
    }
}

// 🔐 사용자 데이터 새로고침
async function refreshUserData() {
    if (!currentUser || !authToken) return;
    
    try {
        console.log('[Auth] 사용자 데이터 새로고침 중...');
        
        // 🔧 API 키 상태 확인
        const apiKeysResponse = await fetch(AUTH_API_URL, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({
                action: 'get-api-keys'
            })
        });
        
        if (apiKeysResponse.ok) {
            const apiKeysData = await apiKeysResponse.json();
            if (apiKeysData.success) {
                // 🔧 사용자 객체에 API 키 정보 추가
                currentUser.hasOpenAIKey = apiKeysData.openaiKey;
                currentUser.hasGoogleKey = apiKeysData.googleKey;
                
                console.log('[Auth] API 키 상태 업데이트:', {
                    openai: currentUser.hasOpenAIKey,
                    google: currentUser.hasGoogleKey
                });
            }
        }
        
        // 🔧 사용량 데이터 새로고침
        await refreshUsageData();
        
        // 🔧 업데이트된 사용자 정보 저장
        localStorage.setItem('currentUser', JSON.stringify(currentUser));
        
    } catch (error) {
        console.error('[Auth] 사용자 데이터 새로고침 실패:', error);
    }
}

// 🔐 사용량 데이터 새로고침
async function refreshUsageData() {
    if (!authToken) return;
    
    try {
        const response = await fetch(AUTH_API_URL, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({
                action: 'get-usage'
            })
        });
        
        if (response.ok) {
            const usageData = await response.json();
            if (usageData.success) {
                // 🔧 실제 사용량 데이터로 UI 업데이트
                updateUsageUI(usageData.usage);
                
                console.log('[Auth] 사용량 데이터 업데이트 완료');
            }
        }
        
    } catch (error) {
        console.error('[Auth] 사용량 데이터 새로고침 실패:', error);
    }
}

// 🔐 사용량 UI 업데이트
function updateUsageUI(usageData) {
    if (!usageData) return;
    
    // 대시보드 카드 업데이트
    const todayUsageEl = document.getElementById('todayUsage');
    const monthUsageEl = document.getElementById('monthUsage');
    const todayCostEl = document.getElementById('todayCost');
    const monthCostEl = document.getElementById('monthCost');
    
    if (todayUsageEl) todayUsageEl.textContent = usageData.today?.translations || 0;
    if (monthUsageEl) monthUsageEl.textContent = usageData.thisMonth?.translations || 0;
    if (todayCostEl) todayCostEl.textContent = `$${(usageData.today?.cost || 0).toFixed(4)}`;
    if (monthCostEl) monthCostEl.textContent = `$${(usageData.thisMonth?.cost || 0).toFixed(4)}`;
    
    // 통계 정보 업데이트
    const todayTranslationsEl = document.getElementById('todayTranslations');
    if (todayTranslationsEl) todayTranslationsEl.textContent = usageData.today?.translations || 0;
    
    // 주간 차트 업데이트
    if (usageData.weekly && usageData.weekly.length > 0) {
        updateWeeklyChart(usageData.weekly);
    }
}

// 🔐 주간 차트 업데이트
function updateWeeklyChart(weeklyData) {
    const chartEl = document.getElementById('weeklyChart');
    if (!chartEl) return;
    
    const maxTranslations = Math.max(...weeklyData.map(d => d.translation_count || 0), 1);
    
    chartEl.innerHTML = weeklyData.map(dayData => {
        const count = dayData.translation_count || 0;
        const height = (count / maxTranslations) * 100;
        const date = new Date(dayData.date);
        const dayLabel = date.toLocaleDateString('ko-KR', { weekday: 'short' });
        
        return `
            <div class="bar" style="height: ${height}%">
                <span class="bar-value">${count}</span>
                <span class="bar-label">${dayLabel}</span>
            </div>
        `;
    }).join('');
}

// 🔐 인증 이벤트 리스너 설정
function setupAuthEventListeners() {
    // 🔧 인증 탭 전환 이벤트
    document.querySelectorAll('.auth-tab').forEach(tab => {
        tab.addEventListener('click', function() {
            switchAuthTab(this.dataset.tab);
        });
    });
    
    // 🔧 API 키 관리 이벤트는 이미 setupApiKeyEvents()에서 처리
    setupApiKeyEvents();
    
    // 🔧 로그인 폼 엔터키 처리
    const loginEmail = document.getElementById('loginEmail');
    const loginPassword = document.getElementById('loginPassword');
    
    if (loginEmail) {
        loginEmail.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                loginPassword?.focus();
            }
        });
    }
    
    if (loginPassword) {
        loginPassword.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                handleLogin();
            }
        });
    }
    
    // 🔧 회원가입 폼 엔터키 처리
    const registerPassword = document.getElementById('registerPassword');
    const registerPasswordConfirm = document.getElementById('registerPasswordConfirm');
    
    if (registerPassword) {
        registerPassword.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                registerPasswordConfirm?.focus();
            }
        });
    }
    
    if (registerPasswordConfirm) {
        registerPasswordConfirm.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                handleRegister();
            }
        });
    }
}

// 🔧 로그인 클릭 핸들러 (디버그용)
function handleLoginClick() {
    if (currentUser) {
        // 로그인된 상태: 사용자에게 로그아웃할지 API 키를 관리할지 선택권을 줍니다.
        if (confirm('로그아웃하시겠습니까?\n\n취소를 누르면 API 키 관리 화면으로 이동합니다.')) {
            handleLogout(); // "확인" 클릭 시 로그아웃 함수 호출
        } else {
            toggleApiKeys(); // "취소" 클릭 시 API 키 관리 창 열기
        }
    } else {
        // 로그인 안된 상태: 로그인 모달 열기
        toggleAuth();
    }
}

// 참고: handleLogout 함수는 이미 아래와 같이 구현되어 있습니다.
function handleLogout() {
    if (confirm('로그아웃 하시겠습니까?')) {
        clearAuthData();
        updateAuthUI(false);
        showStatus("로그아웃되었습니다", "info");
    }
}

// 🔐 인증 모달 토글 (강화된 디버그)
function toggleAuth() {
    console.log('[Debug] toggleAuth 시작');
    
    const authModal = document.getElementById('authModal');
    
    if (!authModal) {
        console.error('[Debug] authModal 요소를 찾을 수 없습니다');
        return;
    }
    
    // 이미 로그인된 경우
    if (currentUser) {
        console.log('[Debug] 로그인된 사용자 - API 키 관리로 전환');
        toggleApiKeys();
        return;
    }
    
    // 모달 토글
    const isActive = authModal.classList.contains('active');
    console.log('[Debug] 현재 모달 상태:', isActive ? '열림' : '닫힘');
    
    if (isActive) {
        authModal.classList.remove('active');
        console.log('[Debug] 모달 닫기 완료');
    } else {
        authModal.classList.add('active');
        console.log('[Debug] 모달 열기 완료');
        
        // 다른 모달들 닫기
        document.getElementById('dashboardModal')?.classList.remove('active');
        document.getElementById('settingsPanel')?.classList.remove('active');
        document.getElementById('vocabularyDropdown')?.classList.remove('active');
        document.getElementById('practiceModal')?.classList.remove('active');
        document.getElementById('wordDetailModal')?.classList.remove('active');
        document.getElementById('quizModal')?.classList.remove('active');
        console.log('[Debug] 다른 모달들 닫기 완료');
    }
}

// 🔐 API 키 관리 모달 토글
function toggleApiKeys() {
    const apiKeysModal = document.getElementById('apiKeysModal');
    
    if (!currentUser) {
        showStatus("API 키 관리는 로그인 후 이용 가능합니다", "warning");
        toggleAuth();
        return;
    }
    
    apiKeysModal.classList.toggle('active');
    
    if (apiKeysModal.classList.contains('active')) {
        loadUserApiKeys();
        // 다른 모달들 닫기
        document.getElementById('authModal')?.classList.remove('active');
        document.getElementById('dashboardModal')?.classList.remove('active');
    }
}

// 🔐 인증 탭 전환
function switchAuthTab(tabName) {
    // 탭 활성화
    document.querySelectorAll('.auth-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    const activeTab = document.querySelector(`[data-tab="${tabName}"]`);
    if (activeTab) {
        activeTab.classList.add('active');
    }

    // 모든 폼 숨기기
    document.querySelectorAll('.auth-form').forEach(form => {
        form.classList.remove('active');
    });

    // 목표 폼 표시
    const targetFormId = tabName === 'login' ? 'loginForm' : 'registerForm';
    const targetForm = document.getElementById(targetFormId);
    if (targetForm) {
        targetForm.classList.add('active');
    }
}

// 🔐 로그인 처리
async function handleLogin() {
    const email = document.getElementById('loginEmail').value.trim();
    const password = document.getElementById('loginPassword').value;
    
    if (!email || !password) {
        showStatus("이메일과 비밀번호를 입력해주세요", "warning");
        return;
    }
    
    showStatus("로그인 중...", "info");
    
    try {
        const response = await fetch(AUTH_API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                action: 'login',
                email: email,
                password: password
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            currentUser = result.user;
            authToken = result.token;
            
            // 로컬 스토리지에 저장
            localStorage.setItem('authToken', authToken);
            localStorage.setItem('currentUser', JSON.stringify(currentUser));
            
            updateAuthUI(true);
            toggleAuth(); // 모달 닫기
            
            showStatus(`✅ ${currentUser.displayName || currentUser.email}님 환영합니다!`, "success");
            
            // 폼 초기화
            document.getElementById('loginEmail').value = '';
            document.getElementById('loginPassword').value = '';
            
        } else {
            showStatus(`로그인 실패: ${result.error}`, "error");
        }
        
    } catch (error) {
        console.error('[Auth] 로그인 오류:', error);
        showStatus("로그인 중 오류가 발생했습니다", "error");
    }
}

// 🔐 회원가입 처리
async function handleRegister() {
    const name = document.getElementById('registerName').value.trim();
    const email = document.getElementById('registerEmail').value.trim();
    const password = document.getElementById('registerPassword').value;
    const passwordConfirm = document.getElementById('registerPasswordConfirm').value;
    const agreeTerms = document.getElementById('agreeTerms').checked;
    
    // 유효성 검사
    if (!email || !password) {
        showStatus("이메일과 비밀번호를 입력해주세요", "warning");
        return;
    }
    
    if (password.length < 8) {
        showStatus("비밀번호는 8자 이상이어야 합니다", "warning");
        return;
    }
    
    if (password !== passwordConfirm) {
        showStatus("비밀번호가 일치하지 않습니다", "warning");
        return;
    }
    
    if (!agreeTerms) {
        showStatus("서비스 이용약관에 동의해주세요", "warning");
        return;
    }
    
    showStatus("회원가입 중...", "info");
    
    try {
        const response = await fetch(AUTH_API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                action: 'register',
                email: email,
                password: password,
                displayName: name || null
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            showStatus("✅ 회원가입이 완료되었습니다. 로그인해주세요", "success");
            
            // 폼 초기화
            document.getElementById('registerName').value = '';
            document.getElementById('registerEmail').value = '';
            document.getElementById('registerPassword').value = '';
            document.getElementById('registerPasswordConfirm').value = '';
            document.getElementById('agreeTerms').checked = false;
            
            // 로그인 탭으로 전환
            switchAuthTab('login');
            
            // 이메일 자동 입력
            document.getElementById('loginEmail').value = email;
            
        } else {
            showStatus(`회원가입 실패: ${result.error}`, "error");
        }
        
    } catch (error) {
        console.error('[Auth] 회원가입 오류:', error);
        showStatus("회원가입 중 오류가 발생했습니다", "error");
    }
}

// 🔐 로그아웃 처리
function handleLogout() {
    if (confirm('로그아웃 하시겠습니까?')) {
        clearAuthData();
        updateAuthUI(false);
        showStatus("로그아웃되었습니다", "info");
    }
}

// 🔐 게스트 모드 계속
function continueAsGuest() {
    toggleAuth(); // 모달 닫기
    showStatus("🎯 게스트 모드로 이용 중입니다", "info");
}

// 🔐 비밀번호 찾기 표시
function showForgotPassword() {
    document.querySelectorAll('.auth-form').forEach(form => {
        form.style.display = 'none';
    });
    document.getElementById('forgotForm').style.display = 'block';
}

// 🔐 로그인 폼으로 돌아가기
function showLoginForm() {
    document.querySelectorAll('.auth-form').forEach(form => {
        form.style.display = 'none';
    });
    document.getElementById('loginForm').style.display = 'block';
}

// 🔐 비밀번호 재설정 처리
async function handleForgotPassword() {
    const email = document.getElementById('forgotEmail').value.trim();
    
    if (!email) {
        showStatus("이메일을 입력해주세요", "warning");
        return;
    }
    
    showStatus("재설정 링크 발송 중...", "info");
    
    try {
        const response = await fetch(AUTH_API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                action: 'forgot-password',
                email: email
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            showStatus("📧 재설정 링크가 이메일로 발송되었습니다", "success");
            showLoginForm();
        } else {
            showStatus(`발송 실패: ${result.error}`, "error");
        }
        
    } catch (error) {
        console.error('[Auth] 비밀번호 재설정 오류:', error);
        showStatus("재설정 링크 발송 중 오류가 발생했습니다", "error");
    }
}

// 🔐 인증 데이터 삭제
function clearAuthData() {
    currentUser = null;
    authToken = null;
    localStorage.removeItem('authToken');
    localStorage.removeItem('currentUser');
}

// 🔐 인증 UI 업데이트 (완전 개선)
function updateAuthUI(isLoggedIn) {
    const loginToggle = document.getElementById('loginToggle');
    
    if (isLoggedIn && currentUser) {
        // 🔧 로그인 상태 UI
        loginToggle.classList.add('logged-in');
        loginToggle.title = `${currentUser.displayName || currentUser.email} - API 키 관리`;
        loginToggle.innerHTML = '👤✓';
        
        // 🔧 프리미엄 기능 표시
        updatePremiumFeatures(true);
        
        // 🔧 대시보드 데이터 표시
        updateDashboardAccess(true);
        
        // 🔧 설정 패널 고급 기능 표시
        updateAdvancedSettings(true);
        
        console.log('[UI] 로그인 상태 UI 적용:', currentUser.email);
        
    } else {
        // 🔧 게스트 상태 UI
        loginToggle.classList.remove('logged-in');
        loginToggle.title = '로그인/회원가입';
        loginToggle.innerHTML = '👤';
        
        // 🔧 기능 제한 적용
        updatePremiumFeatures(false);
        updateDashboardAccess(false);
        updateAdvancedSettings(false);
        
        console.log('[UI] 게스트 상태 UI 적용');
    }
    
    // 🔧 번역/TTS 버튼 상태 업데이트
    updateTranslationButtonStates();
}

// 🔧 프리미엄 기능 UI 업데이트
function updatePremiumFeatures(hasAccess) {
    // AI 번역 토글 버튼
    const aiToggle = document.getElementById('aiToggle');
    if (aiToggle) {
        if (hasAccess) {
            aiToggle.style.opacity = '1';
            aiToggle.style.pointerEvents = 'auto';
            aiToggle.title = 'AI 문맥 번역 (프리미엄)';
        } else {
            if (aiContextMode) {
                toggleAIMode(); // AI 모드 비활성화
            }
            aiToggle.style.opacity = '0.5';
            aiToggle.style.pointerEvents = 'auto'; // 클릭은 가능하게 (경고 표시용)
            aiToggle.title = 'AI 문맥 번역 (로그인 필요)';
        }
    }
    
    // 고급 단어장 토글 버튼
    const vocabToggle = document.getElementById('vocabToggle');
    if (vocabToggle) {
        if (hasAccess) {
            vocabToggle.style.opacity = '1';
            vocabToggle.style.pointerEvents = 'auto';
            vocabToggle.title = '고급 단어장 (프리미엄)';
        } else {
            vocabToggle.style.opacity = '0.5';
            vocabToggle.style.pointerEvents = 'auto';
            vocabToggle.title = '고급 단어장 (로그인 필요)';
        }
    }
    
    // 설정 패널의 AI 섹션
    const aiSettingsSection = document.getElementById('aiSettingsSection');
    if (aiSettingsSection) {
        if (!hasAccess) {
            aiSettingsSection.style.opacity = '0.5';
            // 비활성화 오버레이 추가
            if (!aiSettingsSection.querySelector('.premium-overlay')) {
                const overlay = document.createElement('div');
                overlay.className = 'premium-overlay';
                overlay.style.cssText = `
                    position: absolute; top: 0; left: 0; right: 0; bottom: 0;
                    background: rgba(0,0,0,0.1); z-index: 10; cursor: pointer;
                    display: flex; align-items: center; justify-content: center;
                    font-size: 12px; color: var(--primary); font-weight: bold;
                `;
                overlay.innerHTML = '🔒 로그인 필요';
                overlay.onclick = () => showPremiumAlert('AI 문맥 번역 설정');
                aiSettingsSection.style.position = 'relative';
                aiSettingsSection.appendChild(overlay);
            }
        } else {
            aiSettingsSection.style.opacity = '1';
            const overlay = aiSettingsSection.querySelector('.premium-overlay');
            if (overlay) overlay.remove();
        }
    }
}

// 🔧 대시보드 접근 제어
function updateDashboardAccess(hasAccess) {
    // 대시보드 버튼 상태는 항상 활성화 (게스트도 로컬 데이터 볼 수 있음)
    // 하지만 내용이 다르게 표시됨
}

// 🔧 고급 설정 표시/숨김
function updateAdvancedSettings(hasAccess) {
    // 현재는 모든 설정이 게스트도 사용 가능하므로 특별한 제한 없음
    // 추후 프리미엄 전용 설정 추가 시 여기서 제어
}

// 🔧 번역/TTS 버튼 상태 업데이트
function updateTranslationButtonStates() {
    const translateBtn = document.getElementById('translateBtn');
    const speakBtn = document.getElementById('speakBtn');
    
    if (!currentUser) {
        // 게스트 모드 표시
        if (translateBtn) {
            const originalText = translateBtn.textContent;
            if (!originalText.includes('(게스트)')) {
                translateBtn.innerHTML = translateBtn.innerHTML.replace('번역하기', '번역하기 (게스트)');
            }
        }
    } else {
        // 로그인 모드 표시
        if (translateBtn) {
            translateBtn.innerHTML = translateBtn.innerHTML.replace(' (게스트)', '');
        }
    }
}

// 🔧 프리미엄 기능 접근 시 알림
function showPremiumAlert(featureName) {
    if (currentUser) {
        showStatus(`${featureName} 기능은 이미 사용 가능합니다`, "info");
        return;
    }
    
    // 중복 팝업 방지를 위한 플래그 체크
    if (window.alertShowing) {
        console.log('[Debug] 이미 팝업이 표시 중입니다');
        return;
    }
    
    window.alertShowing = true;
    
    const shouldLogin = confirm(
        `🔒 ${featureName} 기능은 로그인 후 이용 가능합니다.\n\n` +
        `• 무제한 번역 및 TTS\n` +
        `• 개인 API 키 등록\n` +
        `• 사용량 추적 및 분석\n` +
        `• 고급 단어장 및 학습 기록\n\n` +
        `지금 로그인하시겠습니까?`
    );
    
    window.alertShowing = false;
    
    if (shouldLogin) {
        // 직접 모달 열기 (toggleAuth 대신)
        const authModal = document.getElementById('authModal');
        if (authModal) {
            authModal.classList.add('active');
            console.log('[Debug] 로그인 모달 열기');
        } else {
            console.error('[Debug] authModal을 찾을 수 없습니다');
        }
    }
}

// 🔧 AI 모드 토글 시 권한 체크
function toggleAIModeWithAuth() {
    if (!currentUser) {
        showPremiumAlert('AI 문맥 번역');
        return;
    }
    
    toggleAIMode();
}

// 🔧 단어장 토글 시 권한 체크  
function toggleVocabularyWithAuth() {
    if (!currentUser) {
        showPremiumAlert('고급 단어장');
        return;
    }
    
    toggleVocabulary();
}

// 🔑 API 키 관리 시스템 (개선)
async function loadUserApiKeys() {
    if (!currentUser || !authToken) {
        console.log('[API Keys] 사용자 미인증');
        // 비인증 상태 UI 표시
        updateApiKeyStatus('openai', 'error', '❌ 로그인이 필요합니다');
        updateApiKeyStatus('google', 'error', '❌ 로그인이 필요합니다');
        return;
    }
    
    console.log('[API Keys] 사용자 API 키 로드 시작');
    
    // 로딩 상태 표시
    updateApiKeyStatus('openai', 'info', '🔄 API 키 정보 로드 중...');
    updateApiKeyStatus('google', 'info', '🔄 API 키 정보 로드 중...');
    
    try {
        const response = await fetch(AUTH_API_URL, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({
                action: 'get-api-keys'
            })
        });
        
        if (!response.ok) {
            throw new Error(`API 요청 실패: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (result.success) {
            console.log('[API Keys] 키 정보 로드 성공:', result);
            
            // 🔧 OpenAI 키 상태 업데이트
            if (result.openaiKey) {
                document.getElementById('openaiApiKey').value = '••••••••••••••••••••';
                document.getElementById('openaiApiKey').placeholder = 'API 키가 등록되어 있습니다';
                updateApiKeyStatus('openai', 'success', '✅ OpenAI API 키가 등록되어 있습니다');
                
                // 글로벌 상태 업데이트
                if (currentUser) currentUser.hasOpenAIKey = true;
            } else {
                document.getElementById('openaiApiKey').value = '';
                document.getElementById('openaiApiKey').placeholder = 'sk-...';
                updateApiKeyStatus('openai', 'error', '❌ OpenAI API 키가 등록되지 않았습니다');
                
                if (currentUser) currentUser.hasOpenAIKey = false;
            }
            
            // 🔧 Google 키 상태 업데이트
            if (result.googleKey) {
                document.getElementById('googleApiKey').value = '••••••••••••••••••••';
                document.getElementById('googleApiKey').placeholder = 'API 키가 등록되어 있습니다';
                updateApiKeyStatus('google', 'success', '✅ Google API 키가 등록되어 있습니다');
                
                if (currentUser) currentUser.hasGoogleKey = true;
            } else {
                document.getElementById('googleApiKey').value = '';
                document.getElementById('googleApiKey').placeholder = 'AIza...';
                updateApiKeyStatus('google', 'error', '❌ Google API 키가 등록되지 않았습니다');
                
                if (currentUser) currentUser.hasGoogleKey = false;
            }
            
            // 🔧 사용자 정보 업데이트 및 저장
            if (currentUser) {
                localStorage.setItem('currentUser', JSON.stringify(currentUser));
            }
            
        } else {
            console.error('[API Keys] 로드 실패:', result.error);
            updateApiKeyStatus('openai', 'error', `❌ 로드 실패: ${result.error}`);
            updateApiKeyStatus('google', 'error', `❌ 로드 실패: ${result.error}`);
        }
        
    } catch (error) {
        console.error('[API Keys] 로드 오류:', error);
        updateApiKeyStatus('openai', 'error', '❌ 로드 중 오류 발생');
        updateApiKeyStatus('google', 'error', '❌ 로드 중 오류 발생');
    }
}

// 🔑 OpenAI API 키 저장 (개선)
async function saveOpenAIKey() {
    const apiKey = document.getElementById('openaiApiKey').value.trim();
    
    if (!currentUser || !authToken) {
        showStatus("로그인이 필요합니다", "warning");
        updateApiKeyStatus('openai', 'error', '❌ 로그인이 필요합니다');
        return;
    }
    
    if (!apiKey || apiKey === '••••••••••••••••••••') {
        showStatus("유효한 OpenAI API 키를 입력해주세요", "warning");
        updateApiKeyStatus('openai', 'error', '❌ API 키를 입력해주세요');
        return;
    }
    
    if (!apiKey.startsWith('sk-')) {
        showStatus("OpenAI API 키는 'sk-'로 시작해야 합니다", "warning");
        updateApiKeyStatus('openai', 'error', '❌ 올바른 형식이 아닙니다');
        return;
    }
    
    if (apiKey.length < 20) {
        showStatus("API 키가 너무 짧습니다", "warning");
        updateApiKeyStatus('openai', 'error', '❌ API 키가 너무 짧습니다');
        return;
    }
    
    updateApiKeyStatus('openai', 'info', '🔄 API 키 저장 중...');
    
    try {
        const response = await fetch(AUTH_API_URL, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({
                action: 'save-api-key',
                provider: 'openai',
                apiKey: apiKey,
                keyName: 'OpenAI API Key'
            })
        });
        
        if (!response.ok) {
            throw new Error(`API 요청 실패: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (result.success) {
            console.log('[API Keys] OpenAI 키 저장 성공');
            
            // UI 업데이트
            document.getElementById('openaiApiKey').value = '••••••••••••••••••••';
            document.getElementById('openaiApiKey').placeholder = 'API 키가 등록되어 있습니다';
            updateApiKeyStatus('openai', 'success', '✅ OpenAI API 키가 저장되었습니다');
            showStatus("🔑 OpenAI API 키 저장 완료", "success");
            
            // 🔧 사용자 상태 업데이트
            if (currentUser) {
                currentUser.hasOpenAIKey = true;
                localStorage.setItem('currentUser', JSON.stringify(currentUser));
            }
            
        } else {
            console.error('[API Keys] OpenAI 키 저장 실패:', result.error);
            updateApiKeyStatus('openai', 'error', `❌ 저장 실패: ${result.error}`);
            showStatus(`API 키 저장 실패: ${result.error}`, "error");
        }
        
    } catch (error) {
        console.error('[API Keys] OpenAI 키 저장 오류:', error);
        updateApiKeyStatus('openai', 'error', '❌ 저장 중 오류 발생');
        showStatus("API 키 저장 중 오류가 발생했습니다", "error");
    }
}

// 🔑 Google API 키 저장 (개선)
async function saveGoogleKey() {
    const apiKey = document.getElementById('googleApiKey').value.trim();
    
    if (!currentUser || !authToken) {
        showStatus("로그인이 필요합니다", "warning");
        updateApiKeyStatus('google', 'error', '❌ 로그인이 필요합니다');
        return;
    }
    
    if (!apiKey || apiKey === '••••••••••••••••••••') {
        showStatus("유효한 Google API 키를 입력해주세요", "warning");
        updateApiKeyStatus('google', 'error', '❌ API 키를 입력해주세요');
        return;
    }
    
    if (!apiKey.startsWith('AIza')) {
        showStatus("Google API 키는 'AIza'로 시작해야 합니다", "warning");
        updateApiKeyStatus('google', 'error', '❌ 올바른 형식이 아닙니다');
        return;
    }
    
    if (apiKey.length < 20) {
        showStatus("API 키가 너무 짧습니다", "warning");
        updateApiKeyStatus('google', 'error', '❌ API 키가 너무 짧습니다');
        return;
    }
    
    updateApiKeyStatus('google', 'info', '🔄 API 키 저장 중...');
    
    try {
        const response = await fetch(AUTH_API_URL, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({
                action: 'save-api-key',
                provider: 'google',
                apiKey: apiKey,
                keyName: 'Google API Key'
            })
        });
        
        if (!response.ok) {
            throw new Error(`API 요청 실패: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (result.success) {
            console.log('[API Keys] Google 키 저장 성공');
            
            // UI 업데이트
            document.getElementById('googleApiKey').value = '••••••••••••••••••••';
            document.getElementById('googleApiKey').placeholder = 'API 키가 등록되어 있습니다';
            updateApiKeyStatus('google', 'success', '✅ Google API 키가 저장되었습니다');
            showStatus("🔑 Google API 키 저장 완료", "success");
            
            // 🔧 사용자 상태 업데이트
            if (currentUser) {
                currentUser.hasGoogleKey = true;
                localStorage.setItem('currentUser', JSON.stringify(currentUser));
            }
            
        } else {
            console.error('[API Keys] Google 키 저장 실패:', result.error);
            updateApiKeyStatus('google', 'error', `❌ 저장 실패: ${result.error}`);
            showStatus(`API 키 저장 실패: ${result.error}`, "error");
        }
        
    } catch (error) {
        console.error('[API Keys] Google 키 저장 오류:', error);
        updateApiKeyStatus('google', 'error', '❌ 저장 중 오류 발생');
        showStatus("API 키 저장 중 오류가 발생했습니다", "error");
    }
}

// 🔑 OpenAI API 키 테스트
async function testOpenAIKey() {
    const apiKey = document.getElementById('openaiApiKey').value.trim();
    
    if (!apiKey || apiKey === '••••••••••••••••••••') {
        showStatus("테스트할 API 키를 입력해주세요", "warning");
        return;
    }
    
    updateApiKeyStatus('openai', 'info', '🔄 API 키 테스트 중...');
    
    try {
        // OpenAI API 간단한 테스트 요청
        const response = await fetch('https://api.openai.com/v1/models', {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${apiKey}`,
                'Content-Type': 'application/json'
            }
        });
        
        if (response.ok) {
            updateApiKeyStatus('openai', 'success', '✅ OpenAI API 키가 유효합니다');
            showStatus("🔑 OpenAI API 키 테스트 성공", "success");
        } else {
            const errorText = await response.text();
            updateApiKeyStatus('openai', 'error', `❌ 유효하지 않은 API 키: ${response.status}`);
            showStatus(`API 키 테스트 실패: ${response.status}`, "error");
        }
        
    } catch (error) {
        console.error('[API Keys] OpenAI 키 테스트 오류:', error);
        updateApiKeyStatus('openai', 'error', '❌ 테스트 중 오류 발생');
        showStatus("API 키 테스트 중 오류가 발생했습니다", "error");
    }
}

// 🔑 Google API 키 테스트
async function testGoogleKey() {
    const apiKey = document.getElementById('googleApiKey').value.trim();
    
    if (!apiKey || apiKey === '••••••••••••••••••••') {
        showStatus("테스트할 API 키를 입력해주세요", "warning");
        return;
    }
    
    updateApiKeyStatus('google', 'info', '🔄 API 키 테스트 중...');
    
    try {
        // Google TTS API 간단한 테스트 요청 (목소리 리스트 조회)
        const response = await fetch(`https://texttospeech.googleapis.com/v1/voices?key=${apiKey}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        });
        
        if (response.ok) {
            updateApiKeyStatus('google', 'success', '✅ Google API 키가 유효합니다');
            showStatus("🔑 Google API 키 테스트 성공", "success");
        } else {
            const errorText = await response.text();
            updateApiKeyStatus('google', 'error', `❌ 유효하지 않은 API 키: ${response.status}`);
            showStatus(`API 키 테스트 실패: ${response.status}`, "error");
        }
        
    } catch (error) {
        console.error('[API Keys] Google 키 테스트 오류:', error);
        updateApiKeyStatus('google', 'error', '❌ 테스트 중 오류 발생');
        showStatus("API 키 테스트 중 오류가 발생했습니다", "error");
    }
}

// 🔑 API 키 상태 업데이트
function updateApiKeyStatus(provider, status, message) {
    const statusEl = document.getElementById(`${provider}KeyStatus`);
    if (!statusEl) return;
    
    statusEl.className = `api-key-status ${status}`;
    statusEl.textContent = message;
    statusEl.style.display = 'block';
}

// 🔑 인증된 API 요청에 토큰 추가
function getAuthHeaders() {
    const headers = {
        'Content-Type': 'application/json'
    };
    
    if (authToken) {
        headers['Authorization'] = `Bearer ${authToken}`;
    }
    
    return headers;
}

// 🔑 API 키 입력 필드 이벤트 처리
function setupApiKeyEvents() {
    // OpenAI 키 입력 시 상태 초기화
    const openaiInput = document.getElementById('openaiApiKey');
    if (openaiInput) {
        openaiInput.addEventListener('input', function() {
            if (this.value && this.value !== '••••••••••••••••••••') {
                updateApiKeyStatus('openai', '', '');
            }
        });
        
        // 엔터키로 저장
        openaiInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                saveOpenAIKey();
            }
        });
    }
    
    // Google 키 입력 시 상태 초기화
    const googleInput = document.getElementById('googleApiKey');
    if (googleInput) {
        googleInput.addEventListener('input', function() {
            if (this.value && this.value !== '••••••••••••••••••••') {
                updateApiKeyStatus('google', '', '');
            }
        });
        
        // 엔터키로 저장
        googleInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                saveGoogleKey();
            }
        });
    }
}

// AI 문맥 번역 설정
let aiContextMode = false;
let translationContext = [];
let currentTranslationStyle = 'balanced';
let qualityLevel = 3;

// 고급 단어장 시스템 - 초기화
let vocabularyDict = new Map();
let terminologyDict = new Map(); // 전문용어 사전 추가
let currentVocabWord = null;
let quizState = {
    active: false,
    words: [],
    currentIndex: 0,
    correctAnswers: 0,
    wrongAnswers: 0,
    totalQuestions: 10,
    selectedAnswer: null
}; // 🔧 수정: 닫는 괄호 추가

let practiceState = {
    active: false,
    currentWord: null,
    isRecording: false,
    practiceTime: 0,
    lastRecording: null,
    recordingStartTime: null
}; // 🔧 수정: 정의를 먼저 하고

let vocabularyStats = {
    totalWords: 0,
    quizAccuracy: 0,
    practiceTime: 0,
    learningProgress: 0
}; // 🔧 수정: 닫는 괄호 추가

// 🔧 강제 비활성화 (정의 후에 실행)
practiceState.active = false;
quizState.active = false;

// DOM 요소들
// DOM 요소 캐싱 (성능 최적화)
const els = {
    // 입력 및 결과 요소
    inputText: document.getElementById("inputText"),
    translation: document.getElementById("translation"),
    pronunciationContent: document.getElementById("pronunciation-content"),
    pronunciationSection: document.getElementById("pronunciationSection"),
    pronToggleIcon: document.getElementById("pronToggleIcon"),
    status: document.getElementById("status"),
    
    // 버튼 요소
    voiceBtn: document.getElementById("voiceBtn"),
    speakBtn: document.getElementById("speakBtn"),
    copyBtn: document.getElementById("copyBtn"),
    translateBtn: document.getElementById("translateBtn"),
    translateBtnText: document.getElementById("translateBtnText"),
    
    // 언어 선택
    sourceLangSelect: document.getElementById("sourceLangSelect"),
    targetLangSelect: document.getElementById("targetLangSelect"),
    voiceSelect: document.getElementById("voiceSelect"),
    googleVoiceSelect: document.getElementById("googleVoiceSelect"),
    autoDetectBadge: document.getElementById("autoDetectBadge"),
    
    // 패널 및 모드
    settingsPanel: document.getElementById("settingsPanel"),
    normalMode: document.getElementById("normalMode"),
    conversationMode: document.getElementById("conversationMode"),
    normalModeBtn: document.getElementById("normalModeBtn"),
    conversationModeBtn: document.getElementById("conversationModeBtn"),
    
    // 대화 모드 관련
    speakerCardA: document.getElementById("speakerCardA"),
    speakerCardB: document.getElementById("speakerCardB"),
    speakerLangA: document.getElementById("speakerLangA"),
    speakerLangB: document.getElementById("speakerLangB"),
    startConversationBtn: document.getElementById("startConversationBtn"),
    stopConversationBtn: document.getElementById("stopConversationBtn"),
    conversationHistory: document.getElementById("conversationHistory"),
    
    // TTS 및 재생
    ttsEngineMode: document.getElementById("ttsEngineMode"),
    cacheIndicator: document.getElementById("cacheIndicator"),
    engineIndicator: document.getElementById("engineIndicator"),
    recentPlays: document.getElementById("recentPlays"),
    recentPlayList: document.getElementById("recentPlayList"),
    
    // 모달
    dashboardModal: document.getElementById("dashboardModal"),
    historyModal: document.getElementById("historyModal"),
    historyList: document.getElementById("historyList"),
    
    // 대시보드
    todayTranslations: document.getElementById("todayTranslations"),
    totalTranslations: document.getElementById("totalTranslations"),
    cacheHitRate: document.getElementById("cacheHitRate"),
    
    // 설정
    autoModeSettings: document.getElementById("autoModeSettings"),
    autoThreshold: document.getElementById("autoThreshold"),
    thresholdValue: document.getElementById("thresholdValue"),
    volumeControl: document.getElementById("volumeControl"),
    volumeValue: document.getElementById("volumeValue"),
    pronunciationToggle: document.getElementById("pronunciationToggle"),
    
    // AI 기능
    aiToggle: document.getElementById("aiToggle"),
    aiContextBadge: document.getElementById("aiContextBadge"),
    aiIndicator: document.getElementById("aiIndicator"),
    qualitySlider: document.getElementById("qualitySlider"),
    aiSettingsSection: document.getElementById("aiSettingsSection"),
    
    // 단어장
    vocabularyOriginal: document.getElementById("vocabularyOriginal"),
    vocabularyTranslation: document.getElementById("vocabularyTranslation"),
    vocabularyDescription: document.getElementById("vocabularyDescription"),
    vocabularyList: document.getElementById("vocabularyList"),
    vocabularyStats: document.getElementById("vocabularyStats"),
    wordDetailModal: document.getElementById("wordDetailModal"),
    quizModal: document.getElementById("quizModal"),
    practiceModal: document.getElementById("practiceModal")
};

// 📊 개선: 실제 API 연동 사용량 추적기
const usageTracker = {
    // 로컬 캐시 (성능 최적화용)
    localCache: {
        daily: {},
        monthly: {},
        lastRefresh: null
    },
    
    costs: {
        translation: 0.000015,
        openaiTTS: 0.000015,
        googleTTS: 0
    },
    
    // 🔧 초기화 - 실제 API에서 데이터 로드
    async initialize() {
        console.log('[UsageTracker] 초기화 시작');
        
        if (authToken) {
            await this.refreshFromAPI();
        } else {
            // 게스트 모드: 로컬 데이터 로드
            this.loadLocalData();
        }
        
        this.updateDisplay();
    },
    
    // 🔧 API에서 데이터 새로고침
    async refreshFromAPI() {
        if (!authToken) {
            console.log('[UsageTracker] 인증 토큰 없음 - 로컬 모드');
            return;
        }
        
        try {
            console.log('[UsageTracker] API에서 사용량 데이터 로드 중...');
            
            const response = await fetch(AUTH_API_URL, {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${authToken}`
                },
                body: JSON.stringify({
                    action: 'get-dashboard-data'
                })
            });
            
            if (response.ok) {
                const result = await response.json();
                if (result.success) {
                    this.updateLocalCacheFromAPI(result.dashboard);
                    console.log('[UsageTracker] API 데이터 로드 완료');
                }
            }
            
        } catch (error) {
            console.error('[UsageTracker] API 데이터 로드 실패:', error);
            // 실패 시 로컬 데이터 사용
            this.loadLocalData();
        }
        
        this.localCache.lastRefresh = Date.now();
    },
    
    // 🔧 API 데이터로 로컬 캐시 업데이트
    updateLocalCacheFromAPI(dashboardData) {
        const today = new Date().toISOString().split('T')[0];
        const thisMonth = today.substring(0, 7);
        
        // 오늘 데이터
        this.localCache.daily[today] = {
            translations: dashboardData.usage.today.translations || 0,
            characters: dashboardData.usage.today.translations * 50, // 평균 추정
            cost: dashboardData.usage.today.cost || 0,
            saved: 0
        };
        
        // 이번 달 데이터
        this.localCache.monthly[thisMonth] = {
            translations: dashboardData.usage.thisMonth.translations || 0,
            characters: dashboardData.usage.thisMonth.translations * 50,
            cost: dashboardData.usage.thisMonth.cost || 0,
            saved: 0
        };
        
        // 주간 데이터 (차트용)
        this.localCache.weekly = dashboardData.usage.weekly || [];
        
        // 월별 데이터 (차트용)
        this.localCache.monthlyChart = dashboardData.monthlyData || [];
    },
    
    // 🔧 로컬 데이터 로드 (게스트 모드)
    loadLocalData() {
        try {
            const saved = localStorage.getItem('usageData');
            if (saved) {
                const data = JSON.parse(saved);
                this.localCache.daily = data.daily || {};
                this.localCache.monthly = data.monthly || {};
            }
        } catch (error) {
            console.error('[UsageTracker] 로컬 데이터 로드 실패:', error);
        }
    },
    
    // 🔧 사용량 추적 - API 전송 + 로컬 업데이트
    async track(type, count, provider = 'openai') {
        const today = new Date().toISOString().split('T')[0];
        const thisMonth = today.substring(0, 7);
        
        // 로컬 캐시 업데이트
        if (!this.localCache.daily[today]) {
            this.localCache.daily[today] = { translations: 0, characters: 0, cost: 0, saved: 0 };
        }
        if (!this.localCache.monthly[thisMonth]) {
            this.localCache.monthly[thisMonth] = { translations: 0, characters: 0, cost: 0, saved: 0 };
        }
        
        const dailyData = this.localCache.daily[today];
        const monthlyData = this.localCache.monthly[thisMonth];
        
        if (type === 'translation') {
            dailyData.translations++;
            monthlyData.translations++;
            dailyData.characters += count;
            monthlyData.characters += count;
            const cost = count * this.costs.translation;
            dailyData.cost += cost;
            monthlyData.cost += cost;
        } else if (type === 'tts') {
            const cost = provider === 'openai' ? count * this.costs.openaiTTS : 0;
            const saved = provider === 'google' ? count * this.costs.openaiTTS : 0;
            
            dailyData.cost += cost;
            monthlyData.cost += cost;
            dailyData.saved += saved;
            monthlyData.saved += saved;
        }
        
        // 로컬 저장 (게스트 모드용)
        this.saveLocalData();
        
        // UI 업데이트
        this.updateDisplay();
        this.checkLimits();
        
        // 🔧 API에 사용량 전송 (인증된 사용자만)
        if (authToken && currentUser) {
            try {
                // 실제 trackUsage는 translate.js에서 호출되므로 여기서는 로그만
                console.log(`[UsageTracker] ${type} 사용량 추적: ${count} (${provider})`);
            } catch (error) {
                console.error('[UsageTracker] API 전송 실패:', error);
            }
        }
    },
    
    // 로컬 데이터 저장
    saveLocalData() {
        try {
            const data = {
                daily: this.localCache.daily,
                monthly: this.localCache.monthly,
                lastSaved: new Date().toISOString()
            };
            localStorage.setItem('usageData', JSON.stringify(data));
        } catch (error) {
            console.error('[UsageTracker] 로컬 데이터 저장 실패:', error);
        }
    },
    
    // 🔧 개선: 실제 데이터로 디스플레이 업데이트
    updateDisplay() {
        const today = new Date().toISOString().split('T')[0];
        const thisMonth = today.substring(0, 7);
        
        const todayData = this.localCache.daily[today] || { translations: 0, cost: 0, saved: 0 };
        const monthData = this.localCache.monthly[thisMonth] || { translations: 0, cost: 0, saved: 0 };
        
        // 대시보드 카드 업데이트
        const todayUsageEl = document.getElementById('todayUsage');
        const monthUsageEl = document.getElementById('monthUsage');
        const todayCostEl = document.getElementById('todayCost');
        const monthCostEl = document.getElementById('monthCost');
        const savedCostEl = document.getElementById('savedCost');
        
        if (todayUsageEl) todayUsageEl.textContent = todayData.translations;
        if (monthUsageEl) monthUsageEl.textContent = monthData.translations;
        if (todayCostEl) todayCostEl.textContent = `$${todayData.cost.toFixed(4)}`;
        if (monthCostEl) monthCostEl.textContent = `$${monthData.cost.toFixed(4)}`;
        if (savedCostEl) savedCostEl.textContent = `$${monthData.saved.toFixed(4)}`;
        
        this.updateChart();
        this.updateMonthlyChart();
        this.updateBudgetProgress();
    },
    
    // 🔧 주간 차트 업데이트 (실제 데이터)
    updateChart() {
        const chartEl = document.getElementById('weeklyChart');
        if (!chartEl) return;
        
        // 실제 API 데이터가 있으면 사용, 없으면 로컬 데이터
        const weeklyData = this.localCache.weekly || this.generateLocalWeeklyData();
        
        if (weeklyData.length === 0) return;
        
        const maxCount = Math.max(...weeklyData.map(d => d.translation_count || 0), 1);
        
        chartEl.innerHTML = weeklyData.map(dayData => {
            const count = dayData.translation_count || 0;
            const height = (count / maxCount) * 100;
            const date = new Date(dayData.date);
            const dayLabel = date.toLocaleDateString('ko-KR', { weekday: 'short' });
            
            return `<div class="bar" style="height: ${height}%">
                <span class="bar-value">${count}</span>
                <span class="bar-label">${dayLabel}</span>
            </div>`;
        }).join('');
    },
    
    // 로컬 데이터로 주간 차트 생성
    generateLocalWeeklyData() {
        const weekData = [];
        for (let i = 6; i >= 0; i--) {
            const date = new Date();
            date.setDate(date.getDate() - i);
            const dateStr = date.toISOString().split('T')[0];
            const dayData = this.localCache.daily[dateStr] || { translations: 0 };
            
            weekData.push({
                date: dateStr,
                translation_count: dayData.translations
            });
        }
        return weekData;
    },
    
    // 🔧 월별 차트 업데이트 (실제 데이터)
    updateMonthlyChart() {
        const chartEl = document.getElementById('monthlyChart');
        if (!chartEl) return;
        
        // 실제 API 데이터가 있으면 사용, 없으면 로컬 데이터
        const monthlyData = this.localCache.monthlyChart || this.generateLocalMonthlyData();
        
        if (monthlyData.length === 0) return;
        
        const maxCost = Math.max(...monthlyData.map(m => m.cost || 0), 0.01);
        
        chartEl.innerHTML = monthlyData.map(monthData => {
            const cost = monthData.cost || 0;
            const height = maxCost > 0 ? (cost / maxCost * 100) : 0;
            const monthLabel = monthData.monthLabel || 
                new Date(monthData.month + '-01').toLocaleDateString('ko-KR', { month: 'short' });
            
            return `<div class="bar" style="height: ${height}%; background: linear-gradient(135deg, #10A37F, #059669);">
                <span class="bar-value">${cost.toFixed(3)}</span>
                <span class="bar-label">${monthLabel}</span>
            </div>`;
        }).join('');
    },
    
    // 로컬 데이터로 월별 차트 생성
    generateLocalMonthlyData() {
        const monthData = [];
        const currentDate = new Date();
        
        for (let i = 5; i >= 0; i--) {
            const date = new Date(currentDate.getFullYear(), currentDate.getMonth() - i, 1);
            const monthStr = date.toISOString().substring(0, 7);
            const data = this.localCache.monthly[monthStr] || { cost: 0 };
            
            monthData.push({
                month: monthStr,
                cost: data.cost,
                monthLabel: date.toLocaleDateString('ko-KR', { month: 'short' })
            });
        }
        return monthData;
    },
    
    updateBudgetProgress() {
        const today = new Date().toISOString().split('T')[0];
        const todayCost = this.localCache.daily[today]?.cost || 0;
        const dailyBudget = parseFloat(document.getElementById('dailyBudget')?.value) || 1.00;
        const percentage = Math.min((todayCost / dailyBudget) * 100, 100);
        
        const progressEl = document.getElementById('budgetProgress');
        const percentageEl = document.getElementById('budgetPercentage');
        
        if (progressEl) progressEl.style.width = `${percentage}%`;
        if (percentageEl) percentageEl.textContent = `${percentage.toFixed(1)}% 사용`;
        
        this.checkLimits();
    },
    
    checkLimits() {
        const today = new Date().toISOString().split('T')[0];
        const todayCost = this.localCache.daily[today]?.cost || 0;
        const dailyBudget = parseFloat(document.getElementById('dailyBudget')?.value) || 1.00;
        
        if (todayCost >= dailyBudget) {
            const limitAction = document.getElementById('limitAction')?.value;
            if (limitAction === 'switch') {
                els.ttsEngineMode.value = 'google';
                showStatus("⚠️ 예산 도달 - Google TTS로 전환", "warning");
            } else if (limitAction === 'warn') {
                showStatus("⚠️ 일일 예산을 초과했습니다", "warning");
            } else if (limitAction === 'block') {
                window.budgetExceeded = true;
                showStatus("⛔ 예산 초과 - 유료 기능 제한", "error");
            }
        } else {
            window.budgetExceeded = false;
        }
    }
};

// 캐시 관리자
const cacheManager={translation:new Map,tts:new Map,recentPlays:[],stats:{hits:0,misses:0},getTranslation(e){const t=this.translation.get(e);return t&&Date.now()-t.ts<36e5?(this.stats.hits++,t.data):(this.stats.misses++,null)},setTranslation(e,t){this.translation.set(e,{ts:Date.now(),data:t}),this.translation.size>100&&this.translation.delete(this.translation.keys().next().value)},getTTS(e){const t=this.tts.get(e);return t&&Date.now()-t.ts<72e5?t.blob:null},setTTS(e,t){this.tts.set(e,{ts:Date.now(),blob:t}),this.tts.size>50&&this.tts.delete(this.tts.keys().next().value)},addRecentPlay(e,t,s,a){this.recentPlays.unshift({text:e,translation:t,lang:s,engine:a}),this.recentPlays.length>10&&this.recentPlays.pop(),this.save(),updateRecentPlays()},save(){localStorage.setItem("cacheData",JSON.stringify({recentPlays:this.recentPlays,stats:this.stats}))},load(){const e=localStorage.getItem("cacheData");if(e){const{recentPlays:t,stats:a}=JSON.parse(e);this.recentPlays=t||[],this.stats=a||{hits:0,misses:0}}},clear(){this.translation.clear(),this.tts.clear(),this.recentPlays=[],this.stats={hits:0,misses:0},this.save()}};

let currentTranslation="",currentSource="",recognition=null,isRecording=!1,isPronunciationEnabled=!0;
// ✅ 단어장 전용 음성인식 객체 (충돌 방지)
let practiceRecognition=null;
const conversationState={isActive:!1,currentSpeaker:"A",messages:[],autoRecognition:!1},langCodeMap={Korean:"ko-KR",Vietnamese:"vi-VN",English:"en-US"};
let audioContext=null;const audioQueue=[];let isQueuePlaying=!1;

// ✅ 전문용어 관리 함수들 (간소화된 UI)
function addTerminology() {
    const input = document.getElementById('terminologyInput').value.trim();
    
    if (!input) {
        showStatus("용어를 입력해주세요 (예: AI | 인공지능)", "warning");
        return;
    }
    
    // 파이프(|)로 분리
    const parts = input.split('|').map(part => part.trim());
    
    if (parts.length !== 2) {
        showStatus("올바른 형식으로 입력하세요: 원어 | 번역어", "warning");
        return;
    }
    
    const [original, translation] = parts;
    
    if (!original || !translation) {
        showStatus("원어와 번역어를 모두 입력해주세요", "warning");
        return;
    }
    
    if (terminologyDict.has(original)) {
        showStatus("이미 등록된 용어입니다", "warning");
        return;
    }
    
    terminologyDict.set(original, translation);
    
    // 입력 필드 초기화
    document.getElementById('terminologyInput').value = '';
    
    updateTerminologyList();
    saveAISettings();
    showStatus(`🔧 용어 추가: ${original} → ${translation}`, "success");
}

function removeTerminology(original) {
    if (confirm(`"${original}" 용어를 삭제하시겠습니까?`)) {
        terminologyDict.delete(original);
        updateTerminologyList();
        saveAISettings();
        showStatus(`🗑️ 용어 삭제: ${original}`, "success");
    }
}

function updateTerminologyList() {
    const terminologyListEl = document.getElementById('terminologyList');
    if (!terminologyListEl) return;
    
    if (terminologyDict.size === 0) {
        terminologyListEl.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 10px; font-size: 12px;">등록된 전문용어가 없습니다</div>';
        return;
    }
    
    terminologyListEl.innerHTML = Array.from(terminologyDict.entries()).map(([original, translation]) => 
        `<div class="terminology-item">
            <div class="terminology-text">
                <span class="terminology-original">${original}</span>
                <span class="terminology-arrow">→</span>
                <span class="terminology-translated">${translation}</span>
            </div>
            <button class="terminology-remove" onclick="removeTerminology('${original.replace(/'/g, "\\'")}')">삭제</button>
        </div>`
    ).join('');
}

function addVocabulary() {
    const original = els.vocabularyOriginal.value.trim();
    const translation = els.vocabularyTranslation.value.trim();
    const description = els.vocabularyDescription.value.trim();
    
    if (!original || !translation) {
        showStatus("원어와 번역어를 모두 입력해주세요", "warning");
        return;
    }
    
    if (vocabularyDict.has(original)) {
        showStatus("이미 등록된 단어입니다", "warning");
        return;
    }
    
    const wordData = {
        original: original,
        translation: translation,
        description: description || "설명 없음",
        addedDate: new Date().toISOString(),
        correctCount: 0,
        wrongCount: 0,
        practiceTime: 0,
        lastStudied: null
    };
    
    vocabularyDict.set(original, wordData);
    
    // 입력 필드 초기화
    els.vocabularyOriginal.value = '';
    els.vocabularyTranslation.value = '';
    els.vocabularyDescription.value = '';
    
    updateVocabularyList();
    updateVocabularyStats();
    saveVocabularyData();
    showStatus(`📚 단어 추가: ${original} → ${translation}`, "success");
}

function showWordDetail(original) {
    const word = vocabularyDict.get(original);
    if (!word) {
        showStatus("단어를 찾을 수 없습니다", "error");
        return;
    }
    
    // currentVocabWord 설정 (중요!)
    currentVocabWord = word;
    
    // DOM 요소 존재 확인
    const wordDetailOriginalEl = document.getElementById('wordDetailOriginal');
    const wordDetailTranslationEl = document.getElementById('wordDetailTranslation');
    const wordDetailPronunciationEl = document.getElementById('wordDetailPronunciation');
    const wordDetailDescriptionEl = document.getElementById('wordDetailDescription');
    const wordDetailModal = document.getElementById('wordDetailModal');
    
    if (!wordDetailOriginalEl || !wordDetailTranslationEl || !wordDetailPronunciationEl || !wordDetailDescriptionEl || !wordDetailModal) {
        showStatus("단어 상세 UI 요소를 찾을 수 없습니다", "error");
        return;
    }
    
    wordDetailOriginalEl.textContent = word.original;
    wordDetailTranslationEl.textContent = word.translation;
    wordDetailPronunciationEl.textContent = `[${generatePronunciation(word.original)}]`;
    wordDetailDescriptionEl.textContent = word.description;
    
    wordDetailModal.classList.add('active');
}

function closeWordDetail() {
    els.wordDetailModal.classList.remove('active');
    currentVocabWord = null;
}

async function speakCurrentWord() {
    if (!currentVocabWord) return;
    
    // 단어장 전용 TTS 함수
    await speakVocabularyWord(currentVocabWord.original, currentVocabWord.translation);
}

function removeVocabulary(original) {
    if (confirm(`"${original}" 단어를 삭제하시겠습니까?`)) {
        vocabularyDict.delete(original);
        updateVocabularyList();
        updateVocabularyStats();
        saveVocabularyData();
        showStatus(`🗑️ 단어 삭제: ${original}`, "success");
    }
}

function startQuiz(difficulty = 'normal') {
    const words = Array.from(vocabularyDict.values());
    if (words.length < 3) {
        showStatus("퀴즈를 위해서는 최소 3개의 단어가 필요합니다", "warning");
        return;
    }
    
    let quizWords = words;
    if (difficulty === 'difficult') {
        // 정답률이 낮은 단어들을 우선적으로 선택
        quizWords = words.filter(word => {
            const total = word.correctCount + word.wrongCount;
            const accuracy = total > 0 ? word.correctCount / total : 0;
            return accuracy < 0.7; // 정답률 70% 미만
        });
        
        if (quizWords.length < 3) {
            quizWords = words; // 어려운 단어가 부족하면 전체에서 선택
        }
    }
    
    // 랜덤으로 섞기
    quizWords = shuffleArray([...quizWords]);
    
    quizState = {
        active: true,
        words: quizWords.slice(0, Math.min(10, quizWords.length)),
        currentIndex: 0,
        correctAnswers: 0,
        wrongAnswers: 0,
        totalQuestions: Math.min(10, quizWords.length),
        selectedAnswer: null
    };
    
    updateQuizDisplay();
    els.quizModal.classList.add('active');
}

function startSingleWordQuiz(wordKey = null) {
    const allWords = Array.from(vocabularyDict.values());
    if (allWords.length < 3) {
        showStatus("퀴즈를 위해서는 최소 3개의 단어가 필요합니다", "warning");
        return;
    }
    
    let targetWord;
    if (wordKey && vocabularyDict.has(wordKey)) {
        targetWord = vocabularyDict.get(wordKey);
    } else if (currentVocabWord) {
        targetWord = currentVocabWord;
    } else {
        showStatus("퀴즈할 단어를 찾을 수 없습니다", "error");
        return;
    }
    
    quizState = {
        active: true,
        words: [targetWord],
        currentIndex: 0,
        correctAnswers: 0,
        wrongAnswers: 0,
        totalQuestions: 1,
        selectedAnswer: null
    };
    
    closeWordDetail();
    updateQuizDisplay();
    els.quizModal.classList.add('active');
}

function selectQuizOption(optionIndex) {
    if (quizState.selectedAnswer !== null) return; // 이미 선택됨
    
    quizState.selectedAnswer = optionIndex;
    
    const options = document.querySelectorAll('.quiz-option');
    const currentWord = quizState.words[quizState.currentIndex];
    const correctIndex = parseInt(options[0].dataset.correct || '0');
    
    options.forEach((option, index) => {
        option.classList.remove('selected');
        if (index === optionIndex) {
            option.classList.add('selected');
        }
        if (index === correctIndex) {
            option.classList.add('correct');
        } else if (index === optionIndex) {
            option.classList.add('wrong');
        }
    });
    
    // 정답 체크
    if (optionIndex === correctIndex) {
        quizState.correctAnswers++;
        currentWord.correctCount++;
        showStatus("✅ 정답!", "success");
    } else {
        quizState.wrongAnswers++;
        currentWord.wrongCount++;
        showStatus("❌ 오답!", "error");
    }
    
    currentWord.lastStudied = new Date().toISOString();
    
    document.getElementById('quizNextBtn').disabled = false;
    updateQuizStats();
}

function nextQuestion() {
    quizState.currentIndex++;
    quizState.selectedAnswer = null;
    
    if (quizState.currentIndex >= quizState.totalQuestions) {
        showQuizResult();
    } else {
        updateQuizDisplay();
    }
    
    document.getElementById('quizNextBtn').disabled = true;
}

function closeQuiz() {
    els.quizModal.classList.remove('active');
    quizState.active = false;
    saveVocabularyData();
    updateVocabularyStats();
}

function startPronunciationPractice() {
    console.log('startPronunciationPractice 시작');
    console.log('currentVocabWord:', currentVocabWord);

    if (!currentVocabWord) {
        showStatus("선택된 단어가 없습니다", "warning");
        return;
    }
    
    // 단어 상세 모달만 닫기 (단어장은 유지)
    closeWordDetail();
    
    practiceState = {
        active: true,
        currentWord: currentVocabWord,
        isRecording: false,
        practiceTime: Date.now(),
        lastRecording: null,
        recordingStartTime: null
    };
    
    // DOM 요소 존재 확인 후 업데이트
    const practiceWordEl = document.getElementById('practiceWord');
    const practicePronunciationEl = document.getElementById('practicePronunciation');
    const practiceTipsEl = document.getElementById('practiceTips');
    const practiceFeedbackEl = document.getElementById('practiceFeedback');
    const recordBtn = document.getElementById('recordBtn');
    
    console.log('DOM 요소 확인:');
    console.log('practiceWord:', practiceWordEl);
    console.log('practicePronunciation:', practicePronunciationEl);
    console.log('practiceTips:', practiceTipsEl);
    console.log('recordBtn:', recordBtn);

    if (!practiceWordEl || !practicePronunciationEl || !practiceTipsEl || !recordBtn) {
        showStatus("발음 연습 UI 요소를 찾을 수 없습니다", "error");
        return;
    }
    
    practiceWordEl.textContent = practiceState.currentWord.original;
    practicePronunciationEl.textContent = `[${generatePronunciation(practiceState.currentWord.original)}]`;
    practiceTipsEl.textContent = generatePronunciationTips(practiceState.currentWord.original);
    
    if (practiceFeedbackEl) {
        practiceFeedbackEl.style.display = 'none';
    }
    
    recordBtn.classList.remove('recording');
    recordBtn.textContent = '🎤';
    
    // 모달 표시 - 강제 스타일 적용
    const practiceModal = document.getElementById('practiceModal');
    if (practiceModal) {
        practiceModal.style.cssText = 'display: flex !important; visibility: visible !important; opacity: 1 !important; position: fixed !important; top: 0 !important; left: 0 !important; right: 0 !important; bottom: 0 !important; z-index: 3000 !important; padding: 20px !important; align-items: center !important; justify-content: center !important;';
        practiceModal.classList.add('active');
    } else {
        showStatus("발음 연습 모달을 찾을 수 없습니다", "error");
    }
}

function startWordPractice(wordKey = null) {
    const words = Array.from(vocabularyDict.values());
    if (words.length === 0) {
        showStatus("연습할 단어가 없습니다", "warning");
        return;
    }
    
    let selectedWord;
    if (wordKey && vocabularyDict.has(wordKey)) {
        selectedWord = vocabularyDict.get(wordKey);
    } else {
        selectedWord = words[Math.floor(Math.random() * words.length)];
    }
    
    // currentVocabWord 설정
    currentVocabWord = selectedWord;
    
    practiceState = {
        active: true,
        currentWord: selectedWord,
        isRecording: false,
        practiceTime: Date.now(),
        lastRecording: null,
        recordingStartTime: null
    };
    
    // DOM 요소 존재 확인 후 업데이트
    const practiceWordEl = document.getElementById('practiceWord');
    const practicePronunciationEl = document.getElementById('practicePronunciation');
    const practiceTipsEl = document.getElementById('practiceTips');
    const practiceFeedbackEl = document.getElementById('practiceFeedback');
    const recordBtn = document.getElementById('recordBtn');
    
    if (!practiceWordEl || !practicePronunciationEl || !practiceTipsEl || !recordBtn) {
        showStatus("발음 연습 UI 요소를 찾을 수 없습니다", "error");
        return;
    }
    
    practiceWordEl.textContent = selectedWord.original;
    practicePronunciationEl.textContent = `[${generatePronunciation(selectedWord.original)}]`;
    practiceTipsEl.textContent = generatePronunciationTips(selectedWord.original);
    
    if (practiceFeedbackEl) {
        practiceFeedbackEl.style.display = 'none';
    }
    
    recordBtn.classList.remove('recording');
    recordBtn.textContent = '🎤';
    
    // 모달 표시 - 단어장은 유지
    const practiceModal = document.getElementById('practiceModal');
    if (practiceModal) {
        practiceModal.style.cssText = 'display: flex !important; visibility: visible !important; opacity: 1 !important; position: fixed !important; top: 0 !important; left: 0 !important; right: 0 !important; bottom: 0 !important; z-index: 3000 !important; padding: 20px !important; align-items: center !important; justify-content: center !important;';
        practiceModal.classList.add('active');
    } else {
        showStatus("발음 연습 모달을 찾을 수 없습니다", "error");
    }
}

// ✅ 단어장 전용 TTS 함수 추가
async function speakVocabularyWord(word, translation = null) {
    try {
        // 언어 자동 감지 - 간단한 방식
        let language = 'English'; // 기본값
        let useGoogleTTS = true;
        
        if (/[가-힣]/.test(word)) {
            language = 'Korean';
        } else if (/[àáạảãâầấậẩẫăằắặẳẵèéẹẻẽêềếệểễìíịỉĩòóọỏõôồốộổỗơờớợởỡùúụủũưừứựửữỳýỵỷỹđĐ]/.test(word)) {
            language = 'Vietnamese';
        }
        
        // TTS 엔진 선택
        const engineMode = els.ttsEngineMode.value;
        if (engineMode === 'openai') {
            useGoogleTTS = false;
        } else if (engineMode === 'google') {
            useGoogleTTS = true;
        } else {
            // auto 모드: 짧은 단어는 Google, 긴 단어는 OpenAI
            useGoogleTTS = word.length < 50;
        }
        
        const voiceName = useGoogleTTS ? els.googleVoiceSelect.value : els.voiceSelect.value;
        const cacheKey = `vocab:${word}:${language}:${useGoogleTTS}:${voiceName}`;
        
        // 캐시 확인
        const cachedAudio = cacheManager.getTTS(cacheKey);
        if (cachedAudio) {
            queueAudioBlob(cachedAudio);
            showStatus("🔊 단어 재생 (캐시)", "success");
            return;
        }
        
        showStatus("🔊 단어 음성 생성 중...", "info");
        
        const response = await fetch(API_URL, {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({
                action: "speak",
                inputText: word,
                language: language,
                useGoogleTTS: useGoogleTTS,
                voice: voiceName,
                voiceName: voiceName
            })
        });
        
        if (!response.ok) {
            throw new Error(`TTS API 오류: ${response.statusText}`);
        }
        
        const audioBlob = await response.blob();
        cacheManager.setTTS(cacheKey, audioBlob);
        queueAudioBlob(audioBlob);
        
        showStatus(`🔊 ${word} 재생 완료`, "success");
        
    } catch (error) {
        console.error('단어 TTS 오류:', error);
        showStatus(`음성 재생 실패: ${error.message}`, "error");
    }
}

// ✅ 발음 연습 전용 TTS 함수
async function listenPracticeWord() {
    if (!practiceState.currentWord) return;
    
    await speakVocabularyWord(practiceState.currentWord.original);
}

// ✅ 단어장 전용 음성인식 설정 (충돌 방지)
function setupPracticeRecognition() {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
        console.error('음성 인식을 지원하지 않는 브라우저입니다');
        return false;
    }
    
    practiceRecognition = new SpeechRecognition();
    practiceRecognition.continuous = false;
    practiceRecognition.interimResults = true;
    
    return true;
}

// ✅ 마이크/녹음 기능 완전 수정
function toggleRecording() {
    if (!practiceState.currentWord) return;
    
    const recordBtn = document.getElementById('recordBtn');
    
    if (practiceState.isRecording) {
        // 녹음 중지
        stopPracticeRecording();
    } else {
        // 녹음 시작
        startPracticeRecording();
    }
}

function startPracticeRecording() {
    if (!practiceRecognition && !setupPracticeRecognition()) {
        showStatus("음성 인식을 지원하지 않는 브라우저입니다", "error");
        return;
    }
    
    // 언어 설정
    const word = practiceState.currentWord.original;
    let langCode = 'en-US'; // 기본값
    
    if (/[가-힣]/.test(word)) {
        langCode = 'ko-KR';
    } else if (/[àáạảãâầấậẩẫăằắặẳẵèéẹẻẽêềếệểễìíịỉĩòóọỏõôồốộổỗơờớợởỡùúụủũưừứựửữỳýỵỷỹđĐ]/.test(word)) {
        langCode = 'vi-VN';
    }
    
    try {
        practiceState.isRecording = true;
        practiceState.recordingStartTime = Date.now();
        
        const recordBtn = document.getElementById('recordBtn');
        recordBtn.classList.add('recording');
        recordBtn.textContent = '⏹️';
        
        practiceRecognition.lang = langCode;
        
        // 단어장 전용 이벤트 핸들러
        practiceRecognition.onresult = function(event) {
            let transcript = '';
            for (let i = event.resultIndex; i < event.results.length; i++) {
                if (event.results[i].isFinal) {
                    transcript += event.results[i][0].transcript;
                }
            }
            
            if (transcript.trim()) {
                practiceState.lastRecording = transcript.trim();
            }
        };
        
        practiceRecognition.onend = function() {
            stopPracticeRecording();
        };
        
        practiceRecognition.onerror = function(event) {
            console.error('단어장 음성 인식 오류:', event.error);
            showStatus(`음성 인식 오류: ${event.error}`, "error");
            stopPracticeRecording();
        };
        
        practiceRecognition.start();
        showStatus("🎤 발음을 시작하세요...", "info");
        
    } catch (error) {
        console.error('단어장 녹음 시작 오류:', error);
        showStatus("녹음 시작에 실패했습니다", "error");
        stopPracticeRecording();
    }
}

function stopPracticeRecording() {
    practiceState.isRecording = false;
    
    const recordBtn = document.getElementById('recordBtn');
    recordBtn.classList.remove('recording');
    recordBtn.textContent = '🎤';
    
    // ✅ 단어장 전용 recognition 중단
    if (practiceRecognition && practiceRecognition.abort) {
        practiceRecognition.abort();
    }
    
    // 녹음 시간 계산
    if (practiceState.recordingStartTime) {
        const recordingTime = Math.floor((Date.now() - practiceState.recordingStartTime) / 1000);
        practiceState.currentWord.practiceTime += recordingTime;
    }
    
    // 피드백 표시
    const feedback = document.getElementById('practiceFeedback');
    const feedbackText = document.getElementById('practiceFeedbackText');
    
    if (practiceState.lastRecording) {
        const originalWord = practiceState.currentWord.original.toLowerCase();
        const recordedWord = practiceState.lastRecording.toLowerCase();
        
        // 간단한 유사도 검사
        const similarity = calculateSimilarity(originalWord, recordedWord);
        let feedbackMessage = '';
        
        if (similarity > 0.8) {
            feedbackMessage = `✅ 훌륭합니다! "${practiceState.lastRecording}"로 정확하게 발음했습니다.`;
        } else if (similarity > 0.6) {
            feedbackMessage = `👍 좋습니다! "${practiceState.lastRecording}"로 들렸습니다. 조금 더 명확하게 발음해보세요.`;
        } else if (similarity > 0.3) {
            feedbackMessage = `📝 "${practiceState.lastRecording}"로 들렸습니다. 정확한 발음은 "${practiceState.currentWord.original}"입니다. 다시 시도해보세요.`;
        } else {
            feedbackMessage = `🔄 명확하게 들리지 않았습니다. 천천히 또박또박 발음해보세요.`;
        }
        
        feedbackText.textContent = feedbackMessage;
        feedback.style.display = 'block';
        
        // 통계 업데이트
        if (similarity > 0.7) {
            practiceState.currentWord.correctCount++;
        } else {
            practiceState.currentWord.wrongCount++;
        }
        
    } else {
        feedbackText.textContent = "음성이 인식되지 않았습니다. 마이크 권한을 확인하고 다시 시도해주세요.";
        feedback.style.display = 'block';
    }
    
    practiceState.lastRecording = null;
    practiceState.recordingStartTime = null;
    
    // 데이터 저장
    saveVocabularyData();
}

// 텍스트 유사도 계산 함수
function calculateSimilarity(str1, str2) {
    const longer = str1.length > str2.length ? str1 : str2;
    const shorter = str1.length > str2.length ? str2 : str1;
    
    if (longer.length === 0) return 1.0;
    
    const distance = levenshteinDistance(longer, shorter);
    return (longer.length - distance) / longer.length;
}

// 레벤슈타인 거리 계산
function levenshteinDistance(str1, str2) {
    const matrix = [];
    
    for (let i = 0; i <= str2.length; i++) {
        matrix[i] = [i];
    }
    
    for (let j = 0; j <= str1.length; j++) {
        matrix[0][j] = j;
    }
    
    for (let i = 1; i <= str2.length; i++) {
        for (let j = 1; j <= str1.length; j++) {
            if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
            } else {
                matrix[i][j] = Math.min(
                    matrix[i - 1][j - 1] + 1,
                    matrix[i][j - 1] + 1,
                    matrix[i - 1][j] + 1
                );
            }
        }
    }
    
    return matrix[str2.length][str1.length];
}

function nextPracticeWord() {
    const words = Array.from(vocabularyDict.values());
    if (words.length === 0) return;
    
    const randomWord = words[Math.floor(Math.random() * words.length)];
    practiceState.currentWord = randomWord;
    practiceState.isRecording = false;
    practiceState.practiceTime = Date.now();
    practiceState.lastRecording = null;
    practiceState.recordingStartTime = null;
    
    document.getElementById('practiceWord').textContent = randomWord.original;
    document.getElementById('practicePronunciation').textContent = `[${generatePronunciation(randomWord.original)}]`;
    document.getElementById('practiceTips').textContent = generatePronunciationTips(randomWord.original);
    document.getElementById('practiceFeedback').style.display = 'none';
    
    const recordBtn = document.getElementById('recordBtn');
    recordBtn.classList.remove('recording');
    recordBtn.textContent = '🎤';
}

function closePractice() {
    // 녹음 중이면 중지
    if (practiceState.isRecording) {
        stopPracticeRecording();
    }
    
    // 음성인식 정리
    if (practiceRecognition) {
        try {
            practiceRecognition.abort();
        } catch(e) {
            console.log('practiceRecognition 중단 중 오류:', e);
        }
        practiceRecognition = null;
    }
    
    // 모달 완전 숨김
    const practiceModal = document.getElementById('practiceModal');
    practiceModal.classList.remove('active');
    practiceModal.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important;';
    
    practiceState = {
        active: false,
        currentWord: null,
        isRecording: false,
        practiceTime: 0,
        lastRecording: null,
        recordingStartTime: null
    };
    
    saveVocabularyData();
    updateVocabularyStats();
}

// ✅ 보조 함수들
function switchVocabTab(tabName) {
    // 탭 활성화
    document.querySelectorAll('.vocab-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
    
    // 컨텐츠 표시
    document.querySelectorAll('.vocab-content').forEach(content => {
        content.style.display = 'none';
    });
    
    const targetContent = document.getElementById(`vocab${tabName.charAt(0).toUpperCase() + tabName.slice(1)}`);
    if (targetContent) {
        targetContent.style.display = 'block';
    }
    
    // 목록 탭일 때 업데이트
    if (tabName === 'list') {
        updateVocabularyList();
    } else if (tabName === 'stats') {
        updateVocabularyStats();
    }
}

function updateVocabularyList() {
    if (!els.vocabularyList) return;
    
    const words = Array.from(vocabularyDict.values());
    
    if (words.length === 0) {
        els.vocabularyList.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">등록된 단어가 없습니다</div>';
        return;
    }
    
    els.vocabularyList.innerHTML = words.map(word => {
        const accuracy = word.correctCount + word.wrongCount > 0 
            ? Math.round(word.correctCount / (word.correctCount + word.wrongCount) * 100) 
            : 0;
        
        return `
            <div class="vocabulary-item" onclick="showWordDetail('${word.original.replace(/'/g, "\\'")}')">
                <div class="vocabulary-word">
                    <div class="vocabulary-word-main">${word.original}</div>
                    <div class="vocabulary-word-sub">${word.translation} (정답률: ${accuracy}%)</div>
                </div>
                <div class="vocabulary-actions">
                    <button class="vocabulary-btn listen" onclick="event.stopPropagation(); speakVocabularyWord('${word.original.replace(/'/g, "\\'")}');" title="듣기">🔊</button>
                    <button class="vocabulary-btn practice" onclick="event.stopPropagation(); startWordPractice('${word.original.replace(/'/g, "\\'")}');" title="연습">🎤</button>
                    <button class="vocabulary-btn remove" onclick="event.stopPropagation(); removeVocabulary('${word.original.replace(/'/g, "\\'")}');" title="삭제">🗑️</button>
                </div>
            </div>
        `;
    }).join('');
}

function updateVocabularyStats() {
    const words = Array.from(vocabularyDict.values());
    const totalWords = words.length;
    
    let totalCorrect = 0;
    let totalAnswered = 0;
    let totalPracticeTime = 0;
    
    words.forEach(word => {
        totalCorrect += word.correctCount;
        totalAnswered += word.correctCount + word.wrongCount;
        totalPracticeTime += word.practiceTime || 0;
    });
    
    const accuracy = totalAnswered > 0 ? Math.round(totalCorrect / totalAnswered * 100) : 0;
    const practiceMinutes = Math.floor(totalPracticeTime / 60);
    const learningProgress = totalWords > 0 ? Math.min(Math.round(accuracy * totalWords / 100), 100) : 0;
    
    vocabularyStats = {
        totalWords: totalWords,
        quizAccuracy: accuracy,
        practiceTime: practiceMinutes,
        learningProgress: learningProgress
    };
    
    // UI 업데이트
    const elements = {
        totalWords: document.getElementById('totalWords'),
        quizAccuracy: document.getElementById('quizAccuracy'),
        practiceTime: document.getElementById('practiceTime'),
        learningProgress: document.getElementById('learningProgress'),
        progressBar: document.getElementById('progressBar')
    };
    
    if (elements.totalWords) elements.totalWords.textContent = totalWords;
    if (elements.quizAccuracy) elements.quizAccuracy.textContent = `${accuracy}%`;
    if (elements.practiceTime) elements.practiceTime.textContent = `${practiceMinutes}분`;
    if (elements.learningProgress) elements.learningProgress.textContent = `${learningProgress}%`;
    if (elements.progressBar) elements.progressBar.style.width = `${learningProgress}%`;
}

function loadVocabularyData() {
    try {
        const savedVocab = localStorage.getItem('vocabularyData');
        if (savedVocab) {
            const data = JSON.parse(savedVocab);
            vocabularyDict = new Map(data.words || []);
            vocabularyStats = data.stats || {
                totalWords: 0,
                quizAccuracy: 0,
                practiceTime: 0,
                learningProgress: 0
            };
        }
        
        updateVocabularyList();
        updateVocabularyStats();
    } catch (error) {
        console.error('단어장 데이터 로드 실패:', error);
        vocabularyDict = new Map();
        vocabularyStats = {
            totalWords: 0,
            quizAccuracy: 0,
            practiceTime: 0,
            learningProgress: 0
        };
    }
}

function saveVocabularyData() {
    try {
        const data = {
            words: Array.from(vocabularyDict.entries()),
            stats: vocabularyStats,
            lastSaved: new Date().toISOString()
        };
        localStorage.setItem('vocabularyData', JSON.stringify(data));
    } catch (error) {
        console.error('단어장 데이터 저장 실패:', error);
    }
}

// 퀴즈 관련 보조 함수들
function updateQuizDisplay() {
    if (!quizState.active || quizState.currentIndex >= quizState.words.length) return;
    
    const currentWord = quizState.words[quizState.currentIndex];
    const progress = (quizState.currentIndex / quizState.totalQuestions) * 100;
    
    document.getElementById('quizProgressBar').style.width = `${progress}%`;
    document.getElementById('quizCurrent').textContent = quizState.currentIndex + 1;
    document.getElementById('quizTotal').textContent = quizState.totalQuestions;
    document.getElementById('quizCorrect').textContent = quizState.correctAnswers;
    document.getElementById('quizWrong').textContent = quizState.wrongAnswers;
    
    document.getElementById('quizQuestionText').textContent = currentWord.original;
    document.getElementById('quizQuestionHint').textContent = `"${currentWord.original}"의 뜻은?`;
    
    // 선택지 생성
    generateQuizOptions(currentWord);
    
    document.getElementById('quizNextBtn').disabled = true;
    document.getElementById('quizResult').style.display = 'none';
}

function generateQuizOptions(correctWord) {
    const allWords = Array.from(vocabularyDict.values());
    const wrongWords = allWords.filter(word => word.original !== correctWord.original);
    
    // 랜덤 오답 3개 선택
    const wrongOptions = shuffleArray(wrongWords).slice(0, 3);
    const options = [correctWord, ...wrongOptions];
    const shuffledOptions = shuffleArray(options);
    
    const correctIndex = shuffledOptions.findIndex(word => word.original === correctWord.original);
    
    const optionsContainer = document.getElementById('quizOptions');
    optionsContainer.innerHTML = shuffledOptions.map((word, index) => 
        `<div class="quiz-option" data-correct="${correctIndex}" onclick="selectQuizOption(${index})">
            ${word.translation}
        </div>`
    ).join('');
}

function showQuizResult() {
    const accuracy = Math.round((quizState.correctAnswers / quizState.totalQuestions) * 100);
    
    document.getElementById('quizFinalScore').textContent = `${accuracy}%`;
    
    let message = '';
    if (accuracy >= 90) {
        message = '🎉 완벽합니다! 훌륭한 실력이에요!';
    } else if (accuracy >= 70) {
        message = '👍 잘했습니다! 조금만 더 연습하면 완벽해질 거예요!';
    } else if (accuracy >= 50) {
        message = '📚 더 연습이 필요해요. 단어장을 다시 살펴보세요!';
    } else {
        message = '💪 포기하지 마세요! 꾸준한 연습이 실력 향상의 비결입니다!';
    }
    
    document.getElementById('quizMessage').textContent = message;
    document.getElementById('quizResult').style.display = 'block';
    
    // 다른 요소들 숨기기
    document.querySelector('.quiz-question').style.display = 'none';
    document.querySelector('.quiz-options').style.display = 'none';
    document.querySelector('.quiz-controls').style.display = 'none';
}

function updateQuizStats() {
    document.getElementById('quizCorrect').textContent = quizState.correctAnswers;
    document.getElementById('quizWrong').textContent = quizState.wrongAnswers;
}

// 보조 함수들
function shuffleArray(array) {
    const newArray = [...array];
    for (let i = newArray.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
    }
    return newArray;
}

function generatePronunciation(word) {
    // 간단한 발음 표기 생성 (실제로는 더 복잡한 로직 필요)
    if (/^[a-zA-Z]+$/.test(word)) {
        // 영어 단어인 경우 간단한 발음 표기
        return word.toLowerCase().replace(/[aeiou]/g, match => {
            const vowelMap = { 'a': 'ㅏ', 'e': 'ㅓ', 'i': 'ㅣ', 'o': 'ㅗ', 'u': 'ㅜ' };
            return vowelMap[match] || match;
        });
    } else if (/[가-힣]/.test(word)) {
        // 한국어인 경우 그대로 반환
        return word;
    } else {
        // 베트남어나 기타 언어인 경우
        return word;
    }
}

function generatePronunciationTips(word) {
    // 발음 팁 생성
    if (/^[a-zA-Z]+$/.test(word)) {
        return "영어 발음 시 입 모양과 혀의 위치에 주의하세요. 천천히 따라해보세요.";
    } else if (/[가-힣]/.test(word)) {
        return "한국어 발음 시 정확한 받침 발음에 주의하세요.";
    } else {
        return "해당 언어의 특징적인 발음에 주의하여 연습하세요.";
    }
}

// ✅ 단어장 드롭다운 토글 함수
function toggleVocabulary() {
    const vocabDropdown = document.getElementById('vocabularyDropdown');
    const vocabToggle = document.getElementById('vocabToggle');
    
    vocabDropdown.classList.toggle('active');
    vocabToggle.classList.toggle('active');
    
    if (vocabDropdown.classList.contains('active')) {
        updateVocabularyList();
        updateVocabularyStats();
        
        // 다른 모달들 닫기
        const dashboardModal = document.getElementById('dashboardModal');
        const settingsPanel = document.getElementById('settingsPanel');
        if (dashboardModal) dashboardModal.classList.remove('active');
        if (settingsPanel) settingsPanel.classList.remove('active');
        
        // 외부 클릭 시 닫기 이벤트 추가
        setTimeout(() => {
            document.addEventListener('click', closeVocabularyOnOutsideClick);
        }, 100);
    } else {
        document.removeEventListener('click', closeVocabularyOnOutsideClick);
    }
}

function closeVocabularyOnOutsideClick(event) {
    const vocabDropdown = document.getElementById('vocabularyDropdown');
    const vocabToggle = document.getElementById('vocabToggle');
    
    if (!vocabDropdown.contains(event.target) && !vocabToggle.contains(event.target)) {
        vocabDropdown.classList.remove('active');
        vocabToggle.classList.remove('active');
        document.removeEventListener('click', closeVocabularyOnOutsideClick);
    }
}

function toggleRecentPlays(){
    const recentPlayList = document.getElementById('recentPlayList');
    const toggleBtn = document.getElementById('recentPlaysToggleBtn');
    
    if (recentPlayList.style.display === 'none') {
        recentPlayList.style.display = 'block';
        toggleBtn.textContent = '접기';
    } else {
        recentPlayList.style.display = 'none';
        toggleBtn.textContent = '펼치기';
    }
}

// AI 문맥 번역 함수들
function toggleAIMode() {
    aiContextMode = !aiContextMode;
    els.aiToggle.classList.toggle('active', aiContextMode);
    els.aiContextBadge.classList.toggle('active', aiContextMode);
    els.translateBtn.classList.toggle('ai-enhanced', aiContextMode);
    els.translateBtnText.textContent = aiContextMode ? 'AI 번역' : '번역하기';
    els.aiSettingsSection.style.display = aiContextMode ? 'block' : 'none';
    
    if (aiContextMode) {
        showStatus("🧠 AI 문맥 번역 모드 활성화", "success");
    } else {
        showStatus("📝 일반 번역 모드로 전환", "info");
    }
    
    saveAISettings();
}

function buildContextualPrompt(inputText, targetLang) {
    const sourceLang = els.sourceLangSelect.value;
    let prompt = `번역할 텍스트: "${inputText}"\n번역 방향: ${sourceLang} → ${targetLang}\n`;
    
    // 번역 스타일 적용
    const styleInstructions = {
        balanced: "자연스럽고 균형잡힌 번역을 제공하세요.",
        formal: "격식있고 공손한 어조로 번역하세요.",
        casual: "친근하고 편안한 어조로 번역하세요.",
        literal: "원문의 의미를 정확히 보존하여 직역하세요."
    };
    prompt += `번역 스타일: ${styleInstructions[currentTranslationStyle]}\n`;
    
    // 품질 레벨 적용
    if (qualityLevel >= 4) {
        prompt += "매우 정확하고 자연스러운 고품질 번역을 제공하세요. 문화적 뉘앙스와 관용표현을 적절히 반영하세요.\n";
    } else if (qualityLevel >= 3) {
        prompt += "정확하고 자연스러운 번역을 제공하세요.\n";
    }
    
    // 전문용어 사전 적용
    if (terminologyDict.size > 0) {
        prompt += "다음 전문용어를 일관성있게 사용하세요:\n";
        terminologyDict.forEach((translation, original) => {
            prompt += `- "${original}" → "${translation}"\n`;
        });
    }
    
    // 문맥 정보 추가 (최근 5개 고정)
    if (translationContext.length > 0) {
        const recentContext = translationContext.slice(-5);
        prompt += "\n이전 번역 맥락:\n";
        recentContext.forEach((ctx, index) => {
            prompt += `${index + 1}. "${ctx.source}" → "${ctx.translation}"\n`;
        });
        prompt += "\n위 맥락을 고려하여 일관성있게 번역하세요.\n";
    }
    
    return prompt;
}

async function handleTranslate(){
    const inputText = els.inputText.value.trim();
    if (!inputText) return;
    
    const targetLang = els.targetLangSelect.value;
    // 🔧 AI 모드 권한 체크
    if (aiContextMode && !currentUser) {
        showPremiumAlert('AI 문맥 번역');
        return;
    }
    
    // 🔧 게스트 모드 알림 (첫 번역 시에만)
    if (!currentUser && !sessionStorage.getItem('guestWarningShown')) {
        showStatus("🎯 게스트 모드로 이용 중입니다. 로그인하시면 더 많은 기능을 이용하실 수 있습니다.", "info");
        sessionStorage.setItem('guestWarningShown', 'true');
    }
    const cacheKey = `${inputText}:${targetLang}:${aiContextMode}`;
    
    // 캐시 확인
    const cachedResult = isPronunciationEnabled ? cacheManager.getTranslation(cacheKey) : null;
    if (cachedResult) {
        displayTranslation(cachedResult.translation, cachedResult.pronunciation_hangul, inputText, true);
        showStatus("📦 캐시에서 로드됨", "success");
        updateStats(true);
        return;
    }
    
    showStatus(aiContextMode ? "🧠 AI 문맥 번역 중..." : "번역 중...", "info");
    els.cacheIndicator.style.display = "none";
    els.aiIndicator.style.display = aiContextMode ? "inline-block" : "none";
    
    usageTracker.track("translation", inputText.length);
    
    try {
        let requestBody;
        
        if (aiContextMode) {
            // AI 문맥 번역 요청
            const contextualPrompt = buildContextualPrompt(inputText, targetLang);
            requestBody = {
                action: "translate",
                inputText: inputText,
                targetLang: targetLang,
                getPronunciation: isPronunciationEnabled,
                useAIContext: true,
                contextualPrompt: contextualPrompt,
                qualityLevel: qualityLevel
            };
        } else {
            // 일반 번역 요청
            requestBody = {
                action: "translate",
                inputText: inputText,
                targetLang: targetLang,
                getPronunciation: isPronunciationEnabled
            };
        }
        
        const response = await fetch(API_URL, {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify(requestBody)
        });
        
        const result = await response.json();
        if (result.error) throw new Error(result.error);

        displayTranslation(result.translation, result.pronunciation_hangul, inputText, false);

        // 번역 컨텍스트에 추가 (AI 모드일 때만)
        if (aiContextMode) {
            translationContext.push({
                source: inputText,
                translation: result.translation,
                timestamp: Date.now()
            });
            
            // 컨텍스트 크기 제한
            if (translationContext.length > 20) {
                translationContext = translationContext.slice(-20);
            }
        }
        
        if (isPronunciationEnabled) {
            cacheManager.setTranslation(cacheKey, result);
        }
        
        saveToHistory(inputText, result.translation, els.sourceLangSelect.value, targetLang);
        updateStats(false);
        showStatus(aiContextMode ? "🧠 AI 번역 완료" : "번역 완료", "success");
        
    } catch (error) {
        showStatus(`번역 실패: ${error.message}`, "error");
    }
}

// AI 설정 저장/로드
function saveAISettings() {
    const aiSettings = {
        aiContextMode,
        translationContext: translationContext.slice(-20), // 최근 20개만 저장
        currentTranslationStyle,
        qualityLevel,
        terminologyDict: Array.from(terminologyDict.entries()) // 전문용어 사전 저장
    };
    localStorage.setItem('aiSettings', JSON.stringify(aiSettings));
}

function loadAISettings() {
    const saved = localStorage.getItem('aiSettings');
    if (saved) {
        try {
            const aiSettings = JSON.parse(saved);
            aiContextMode = aiSettings.aiContextMode || false;
            translationContext = aiSettings.translationContext || [];
            currentTranslationStyle = aiSettings.currentTranslationStyle || 'balanced';
            qualityLevel = aiSettings.qualityLevel || 3;
            
            // 전문용어 사전 복원
            if (aiSettings.terminologyDict) {
                terminologyDict = new Map(aiSettings.terminologyDict);
            }
            
            // UI 업데이트
            els.aiToggle.classList.toggle('active', aiContextMode);
            els.aiContextBadge.classList.toggle('active', aiContextMode);
            els.translateBtn.classList.toggle('ai-enhanced', aiContextMode);
            els.translateBtnText.textContent = aiContextMode ? 'AI 번역' : '번역하기';
            els.aiSettingsSection.style.display = aiContextMode ? 'block' : 'none';
            els.qualitySlider.value = qualityLevel;

            // 모델 정보 표시 초기화
            updateModelInfo(qualityLevel);

            // 스타일 버튼 업데이트
            document.querySelectorAll('.style-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.style === currentTranslationStyle);
            });
            
            // 전문용어 목록 업데이트
            updateTerminologyList();
        } catch (e) {
            console.error('AI 설정 로드 실패:', e);
        }
    }
}

// 기존 함수들 (기본 번역기 기능)

// 옵션 1: 품질 슬라이더의 모델 정보를 실시간으로 업데이트하는 함수
function updateModelInfo(level) {
    const modelConfig = {
        1: { model: 'gpt-4o-mini', cost: '매우 낮음', tokens: '1000' },
        2: { model: 'gpt-4o-mini', cost: '낮음', tokens: '1200' },
        3: { model: 'gpt-4o', cost: '중간', tokens: '1500' },
        4: { model: 'gpt-4o', cost: '높음', tokens: '2000' },
        5: { model: 'gpt-4o', cost: '매우 높음', tokens: '2500' }
    };

    const config = modelConfig[level];
    const modelInfoDisplay = document.getElementById('modelInfoDisplay');

    if (modelInfoDisplay && config) {
        modelInfoDisplay.innerHTML = `
            <span class="model-name">모델: ${config.model}</span>
            <span class="model-cost">비용: ${config.cost}</span>
            <span class="model-tokens">토큰: ${config.tokens}</span>
        `;
    }
}

async function handleSpeak(){if(!currentTranslation)return;window.budgetExceeded&&(els.ttsEngineMode.value="google",showStatus("⛔ 예산 초과. Google TTS만 사용 가능","error"));const e=els.targetLangSelect.value,t=els.ttsEngineMode.value;let a="openai";"google"===t?a="google":"openai"===t?a="openai":"auto"===t?"Vietnamese"===e||currentTranslation.length<parseInt(els.autoThreshold.value)?a="google":a="openai":"smart"===t?currentTranslation.length<100||conversationState.isActive||"Vietnamese"===e?a="google":a="openai":a="openai";const s="google"===a?els.googleVoiceSelect.value:els.voiceSelect.value,i=`${currentTranslation}:${e}:${a}:${s}`,o=cacheManager.getTTS(i);if(els.engineIndicator.textContent=a.charAt(0).toUpperCase(),els.engineIndicator.className=`engine-indicator ${a}`,els.engineIndicator.style.display="inline-block",o)return queueAudioBlob(o),showStatus("🔊 캐시된 음성 재생","success"),void cacheManager.addRecentPlay(currentSource,currentTranslation,e,a);showStatus("음성 생성 중...","info"),usageTracker.track("tts",currentTranslation.length,a);try{const t=await fetch(API_URL,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({action:"speak",inputText:currentTranslation,language:e,useGoogleTTS:"google"===a,voice:s,voiceName:s})});if(!t.ok)throw new Error(`API 오류: ${t.statusText}`);const o=await t.blob();cacheManager.setTTS(i,o),queueAudioBlob(o),cacheManager.addRecentPlay(currentSource,currentTranslation,e,a),showStatus(`🔊 ${a} TTS 재생`,"success")}catch(e){showStatus(`음성 생성 실패: ${e.message}`,"error")}}
function handleVoiceTranslate(){recognition||setupSpeechRecognition(),isRecording?recognition.stop():(recognition.lang=langCodeMap[els.sourceLangSelect.value],recognition.start())}
function displayTranslation(e,t,a,s){currentTranslation=e,currentSource=a,els.translation.textContent=e,els.pronunciationSection.style.display=isPronunciationEnabled?"block":"none",isPronunciationEnabled&&(els.pronunciationContent.textContent=t||""),els.speakBtn.disabled=!1,els.copyBtn.disabled=!1,els.cacheIndicator.style.display=s?"inline-block":"none"}
function setupSpeechRecognition(){const e=window.SpeechRecognition||window.webkitSpeechRecognition;if(!e)return void showStatus("음성 인식 미지원 브라우저","error");recognition=new e,recognition.continuous=!1,recognition.interimResults=!0;let t="";recognition.onstart=()=>{isRecording=!0,t="",els.voiceBtn.classList.add("recording")},recognition.onresult=e=>{let a="";for(let s=e.resultIndex;s<e.results.length;++s)e.results[s].isFinal?t+=e.results[s][0].transcript:a+=e.results[s][0].transcript;conversationState.isActive||(els.inputText.value=t+a)},recognition.onend=()=>{isRecording=!1,els.voiceBtn.classList.remove("recording");const e=t.trim();conversationState.isActive?e?handleConversationTranslation(e):startAutoRecognition():e&&(els.inputText.value=e,handleTranslate())},recognition.onerror=e=>{showStatus(`음성 인식 오류: ${e.error}`,"error"),isRecording=!1,els.voiceBtn.classList.remove("recording")}}
function toggleDashboard(){els.dashboardModal.classList.toggle("active"),els.dashboardModal.classList.contains("active")&&usageTracker.updateDisplay()}
function toggleSettings(){els.settingsPanel.classList.toggle("active")}
function toggleTheme(){const e="dark"===document.documentElement.getAttribute("data-theme")?"light":"dark";document.documentElement.setAttribute("data-theme",e),localStorage.setItem("theme",e)}
function swapLanguages(){const e=els.sourceLangSelect.value;els.sourceLangSelect.value=els.targetLangSelect.value,els.targetLangSelect.value=e,saveSettings()}
function copyTranslation(){navigator.clipboard.writeText(currentTranslation).then(()=>showStatus("📋 번역문 복사 완료","success"))}
function copyInputText(){const e=els.inputText.value;e?navigator.clipboard.writeText(e).then(()=>showStatus("📋 원문 복사 완료","success")):showStatus("복사할 내용이 없습니다","warning")}
async function pasteFromClipboard(){try{const e=await navigator.clipboard.readText();e?(els.inputText.value+=e,showStatus("📋 붙여넣기 완료","success")):showStatus("클립보드가 비어있습니다","warning")}catch(e){console.error("붙여넣기 실패:",e),showStatus("붙여넣기에 실패했습니다","error")}}
function clearAll(){els.inputText.value="",els.translation.textContent="",els.pronunciationContent.textContent="",els.speakBtn.disabled=!0,els.copyBtn.disabled=!0,els.cacheIndicator.style.display="none",els.aiIndicator.style.display="none"}
function showStatus(e,t=""){els.status.textContent=e,els.status.className=`status ${t}`,setTimeout(()=>{els.status.textContent="",els.status.className="status"},3e3)}
function clearAllCache(){confirm("모든 캐시 데이터를 삭제하시겠습니까?")&&(cacheManager.clear(),updateRecentPlays(),displayStats(),showStatus("✨ 캐시가 초기화되었습니다.","success"))}
function switchToNormalMode(){conversationState.isActive&&stopConversation(),els.normalModeBtn.classList.add("active"),els.conversationModeBtn.classList.remove("active"),els.normalMode.classList.remove("hidden"),els.conversationMode.classList.remove("active")}
function switchToConversationMode(){els.conversationModeBtn.classList.add("active"),els.normalModeBtn.classList.remove("active"),els.normalMode.classList.add("hidden"),els.conversationMode.classList.add("active"),updateSpeakerLanguages()}
function updateSpeakerLanguages(){els.speakerLangA.textContent=els.sourceLangSelect.options[els.sourceLangSelect.selectedIndex].text,els.speakerLangB.textContent=els.targetLangSelect.options[els.targetLangSelect.selectedIndex].text}
function startConversation(){conversationState.isActive=!0,conversationState.currentSpeaker="A",conversationState.autoRecognition=!0,els.startConversationBtn.disabled=!0,els.stopConversationBtn.disabled=!1,updateActiveSpeaker(),startAutoRecognition()}
function stopConversation(){conversationState.isActive=!1,conversationState.autoRecognition=!1,recognition&&isRecording&&recognition.stop(),els.startConversationBtn.disabled=!1,els.stopConversationBtn.disabled=!0,els.speakerCardA.classList.remove("active"),els.speakerCardB.classList.remove("active")}
function clearConversation(){conversationState.messages=[],updateConversationHistory()}
function updateActiveSpeaker(){"A"===conversationState.currentSpeaker?(els.speakerCardA.classList.add("active"),els.speakerCardB.classList.remove("active")):(els.speakerCardA.classList.remove("active"),els.speakerCardB.classList.add("active"))}
async function startAutoRecognition(){if(!conversationState.autoRecognition)return;isRecording&&(recognition.stop(),await new Promise(e=>setTimeout(e,100)));const e="A"===conversationState.currentSpeaker?els.sourceLangSelect.value:els.targetLangSelect.value;recognition.lang=langCodeMap[e],recognition.start()}
async function handleConversationTranslation(e){const t=conversationState.currentSpeaker,a="B"===t,s=a?els.targetLangSelect.value:els.sourceLangSelect.value,i=a?els.sourceLangSelect.value:els.targetLangSelect.value;usageTracker.track("translation",e.length),updateStats(!1);const o=await fetch(API_URL,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({action:"translate",inputText:e,targetLang:i,getPronunciation:!1})}),r=await o.json();conversationState.messages.push({speaker:t,original:e,translation:r.translation}),updateConversationHistory(),playChunkedAudio(r.chunks||[r.translation],i),conversationState.currentSpeaker="A"===t?"B":"A",updateActiveSpeaker(),setTimeout(startAutoRecognition,500)}
function updateConversationHistory(){0===conversationState.messages.length?els.conversationHistory.innerHTML='<div style="text-align:center; padding: 20px; color: var(--text-secondary);">대화를 시작하세요</div>':(els.conversationHistory.innerHTML=conversationState.messages.map(e=>`<div class="conversation-message"><div class="message-speaker speaker-${"A"===e.speaker?"a":"b"}">${e.speaker}</div><div class="message-content"><div class="message-original">${e.original}</div><div class="message-translation">${e.translation}</div></div></div>`).join(""),els.conversationHistory.scrollTop=els.conversationHistory.scrollHeight)}
async function playChunkedAudio(e,t){for(const a of e){usageTracker.track("tts",a.length,"google");const e=await fetch(API_URL,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({action:"speak",inputText:a,language:t,useGoogleTTS:!0,voiceName:els.googleVoiceSelect.value})});e.ok&&queueAudioBlob(await e.blob())}}
function initAudioContext(){audioContext||(audioContext=new(window.AudioContext||window.webkitAudioContext)),"suspended"===audioContext?.state&&audioContext.resume()}
async function playAudioBlob(e){
    try{
        initAudioContext();
        const audioBuffer = await audioContext.decodeAudioData(await e.arrayBuffer());
        const source = audioContext.createBufferSource();
        source.buffer = audioBuffer;

        // 🎯 볼륨 조절기(GainNode) 생성
        const gainNode = audioContext.createGain();
        
        // 🎯 증폭 설정 (1.0이 기본값, 숫자를 키울수록 소리가 커집니다)
        gainNode.gain.value = 4.5; // 예: 2.5배 증폭

        // 🎯 오디오 연결: 소스 -> 볼륨 조절기 -> 스피커
        source.connect(gainNode);
        gainNode.connect(audioContext.destination);

        source.onended = playNextInQueue;
        source.start(0);
    } catch(t) {
        // Web Audio API를 지원하지 않는 경우의 대체 코드
        const audio = new Audio(URL.createObjectURL(e));
        audio.volume = 1.0; // HTML Audio 요소의 볼륨은 0.0 ~ 1.0
        audio.onended = playNextInQueue;
        audio.play();
    }
}
function queueAudioBlob(e){audioQueue.push(e),isQueuePlaying||playNextInQueue()}
function playNextInQueue(){if(0===audioQueue.length)return void(isQueuePlaying=!1);isQueuePlaying=!0,playAudioBlob(audioQueue.shift())}
function getStats(){const e=localStorage.getItem("translationStats");return e?JSON.parse(e):{totalTranslations:0,todayTranslations:0,lastDate:(new Date).toDateString()}}
function updateStats(e){const t=getStats();(new Date).toDateString()!==t.lastDate&&(t.todayTranslations=0,t.lastDate=(new Date).toDateString()),e||(t.totalTranslations++,t.todayTranslations++),localStorage.setItem("translationStats",JSON.stringify(t)),displayStats()}
function displayStats(){const e=getStats();els.todayTranslations.textContent=e.todayTranslations,els.totalTranslations.textContent=e.totalTranslations;const t=cacheManager.stats.hits+cacheManager.stats.misses>0?Math.round(cacheManager.stats.hits/(cacheManager.stats.hits+cacheManager.stats.misses)*100):0;els.cacheHitRate.textContent=`${t}%`}
function saveToHistory(e,t,a,s){const i=JSON.parse(localStorage.getItem("translationHistory")||"[]");i.unshift({source:e,translation:t,sourceLang:a,targetLang:s,time:(new Date).toLocaleString("ko-KR")}),i.length>50&&i.pop(),localStorage.setItem("translationHistory",JSON.stringify(i))}
function showHistory(){const e=JSON.parse(localStorage.getItem("translationHistory")||"[]");els.historyList.innerHTML=e.length?e.map((e,t)=>`<div class="recent-play-item" onclick="loadFromHistory(${t})"><div><div class="recent-play-text" style="white-space: normal;"><b>${e.sourceLang}:</b> ${e.source}</div><div class="recent-play-text" style="white-space: normal; color: var(--primary);"><b>${e.targetLang}:</b> ${e.translation}</div></div><small style="color: var(--text-secondary);">${e.time}</small></div>`).join(""):`<p style="text-align:center;">기록 없음</p>`,els.historyModal.classList.add("active")}
function hideHistory(){els.historyModal.classList.remove("active")}
function loadFromHistory(e){const t=JSON.parse(localStorage.getItem("translationHistory"))[e];t&&(els.inputText.value=t.source,els.sourceLangSelect.value=t.sourceLang,els.targetLangSelect.value=t.targetLang,hideHistory(),handleTranslate())}
function clearHistory(){confirm("모든 기록을 삭제합니까?")&&(localStorage.removeItem("translationHistory"),showHistory())}

function updateRecentPlays(){
    const recentPlaysEl = els.recentPlays;
    const recentPlayListEl = els.recentPlayList;
    
    // 최근 재생 항목이 있을 때만 표시하되, 기본은 접힌 상태
    if (cacheManager.recentPlays.length > 0) {
        recentPlaysEl.classList.add("active");
        recentPlayListEl.innerHTML = cacheManager.recentPlays.map((e,t)=>`<div class="recent-play-item"><div class="recent-play-text">${e.text.substring(0,25)}...</div><div class="recent-play-actions"><button class="recent-play-btn" onclick="replayRecent(${t})">🔊</button><span class="engine-indicator ${e.engine}">${e.engine[0].toUpperCase()}</span></div></div>`).join("");
        
        // 기본 접힌 상태 유지
        if (!recentPlayListEl.style.display || recentPlayListEl.style.display === 'none') {
            recentPlayListEl.style.display = 'none';
            document.getElementById('recentPlaysToggleBtn').textContent = '펼치기';
        }
    } else {
        recentPlaysEl.classList.remove("active");
    }
}

async function replayRecent(e){const t=cacheManager.recentPlays[e],a="google"===t.engine?els.googleVoiceSelect.value:els.voiceSelect.value,s=`${t.translation}:${t.lang}:${t.engine}:${a}`,i=cacheManager.getTTS(s);if(i)return void queueAudioBlob(i);currentTranslation=t.translation,currentSource=t.text,await handleSpeak()}
function saveSettings(){localStorage.setItem("ttsEngine",els.ttsEngineMode.value),localStorage.setItem("autoThreshold",els.autoThreshold.value),localStorage.setItem("voice",els.voiceSelect.value),localStorage.setItem("googleVoice",els.googleVoiceSelect.value),localStorage.setItem("volume",els.volumeControl.value),localStorage.setItem("sourceLang",els.sourceLangSelect.value),localStorage.setItem("targetLang",els.targetLangSelect.value),localStorage.setItem("pronunciationEnabled",isPronunciationEnabled)}
function loadSettings(){document.documentElement.setAttribute("data-theme",localStorage.getItem("theme")||"light"),isPronunciationEnabled="false"!==localStorage.getItem("pronunciationEnabled"),els.pronunciationToggle.classList.toggle("active",isPronunciationEnabled),els.pronunciationSection.style.display=isPronunciationEnabled?"block":"none",els.sourceLangSelect.value=localStorage.getItem("sourceLang")||"Korean",els.targetLangSelect.value=localStorage.getItem("targetLang")||"Vietnamese",els.ttsEngineMode.value=localStorage.getItem("ttsEngine")||"auto",els.autoThreshold.value=localStorage.getItem("autoThreshold")||"50",els.thresholdValue.textContent=`${els.autoThreshold.value}자`,els.voiceSelect.value=localStorage.getItem("voice")||"nova",els.googleVoiceSelect.value=localStorage.getItem("googleVoice")||"vi-VN-Standard-A",els.volumeControl.value=localStorage.getItem("volume")||"0.8",els.volumeValue.textContent=`${Math.round(100*els.volumeControl.value)}%`,updateAutoModeVisibility(),document.getElementById("dailyBudget").value=localStorage.getItem("dailyBudget")||"1.00",document.getElementById("monthlyBudget").value=localStorage.getItem("monthlyBudget")||"30.00"}
function updateAutoModeVisibility(){const e=els.ttsEngineMode.value;els.autoModeSettings.style.display="auto"===e||"smart"===e?"grid":"none"}
function togglePronunciationView(){const e=els.pronunciationContent;e.style.display="none"===e.style.display||""===e.style.display?"block":"none",els.pronToggleIcon.textContent="block"===e.style.display?"▼":"▶"}

// ✅ 전역 함수로 할당 (HTML에서 호출 가능하도록)
window.addVocabulary = addVocabulary;
window.showWordDetail = showWordDetail;
window.closeWordDetail = closeWordDetail;
window.speakCurrentWord = speakCurrentWord;
window.removeVocabulary = removeVocabulary;
window.startQuiz = startQuiz;
window.startSingleWordQuiz = startSingleWordQuiz;
window.selectQuizOption = selectQuizOption;
window.nextQuestion = nextQuestion;
window.closeQuiz = closeQuiz;
window.startPronunciationPractice = startPronunciationPractice;
window.startWordPractice = startWordPractice;
window.listenPracticeWord = listenPracticeWord;
window.toggleRecording = toggleRecording;
window.nextPracticeWord = nextPracticeWord;
window.closePractice = closePractice;
window.showPreviousWord = showPreviousWord;
window.showNextWord = showNextWord;
window.speakVocabularyWord = speakVocabularyWord;
// 🔧 추가: 인증 관련 전역 함수들
window.toggleAuth = toggleAuth;
window.toggleApiKeys = toggleApiKeys;
window.handleLogin = handleLogin;
window.handleRegister = handleRegister;
window.continueAsGuest = continueAsGuest;
window.showForgotPassword = showForgotPassword;
window.showLoginForm = showLoginForm;
window.handleForgotPassword = handleForgotPassword;
window.switchAuthTab = switchAuthTab;
window.saveOpenAIKey = saveOpenAIKey;
window.saveGoogleKey = saveGoogleKey;
window.testOpenAIKey = testOpenAIKey;
window.testGoogleKey = testGoogleKey;
window.speakCurrentWord = speakCurrentWord;

// 🔧 권한 체크가 포함된 전역 함수들
window.toggleAIModeWithAuth = toggleAIModeWithAuth;
window.toggleVocabularyWithAuth = toggleVocabularyWithAuth;
window.switchVocabTab = switchVocabTab;
window.addTerminology = addTerminology;
window.removeTerminology = removeTerminology;

// 모든 모달 닫기 함수
function closeAllModals() {
    const modals = [
        'practiceModal', 
        'wordDetailModal', 
        'quizModal', 
        'dashboardModal', 
        'historyModal',
        'vocabularyDropdown'
    ];

    modals.forEach(modalId => {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.classList.remove('active');
            if (modalId === 'practiceModal') {
                modal.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important;';
            }
        }
    });
}

// 이전 단어 보기
function showPreviousWord() {
    const words = Array.from(vocabularyDict.values());
    if (words.length <= 1) return;
    
    const currentIndex = words.findIndex(word => word.original === currentVocabWord.original);
    const previousIndex = currentIndex > 0 ? currentIndex - 1 : words.length - 1;
    const previousWord = words[previousIndex];
    
    showWordDetail(previousWord.original);
}

// 다음 단어 보기
function showNextWord() {
    const words = Array.from(vocabularyDict.values());
    if (words.length <= 1) return;
    
    const currentIndex = words.findIndex(word => word.original === currentVocabWord.original);
    const nextIndex = currentIndex < words.length - 1 ? currentIndex + 1 : 0;
    const nextWord = words[nextIndex];
    
    showWordDetail(nextWord.original);
}

// ✅ 초기화
document.addEventListener("DOMContentLoaded", function() {
    try {
        // 시스템 초기화
        usageTracker.initialize();
        cacheManager.load();
        loadSettings();
        loadAISettings();
        loadVocabularyData();
        setupSpeechRecognition();
        updateRecentPlays();
        updateSpeakerLanguages();
        displayStats();
        // 🔧 인증 시스템 초기화
        initAuthSystem();
        
        // 🔧 UI 상태 초기 설정
        updateAuthUI(!!currentUser);
        
        // 기존 이벤트 리스너들
        if (els.ttsEngineMode) {
            els.ttsEngineMode.addEventListener("change", function() {
                updateAutoModeVisibility();
                saveSettings();
            });
        }
        
        if (els.autoThreshold) {
            els.autoThreshold.addEventListener("input", function(e) {
                if (els.thresholdValue) els.thresholdValue.textContent = `${e.target.value}자`;
                saveSettings();
            });
        }
        
        if (els.volumeControl) {
            els.volumeControl.addEventListener("input", function(e) {
                if (els.volumeValue) els.volumeValue.textContent = `${Math.round(100 * e.target.value)}%`;
                saveSettings();
            });
        }
        
        if (els.voiceSelect) {
            els.voiceSelect.addEventListener("change", saveSettings);
        }
        
        if (els.googleVoiceSelect) {
            els.googleVoiceSelect.addEventListener("change", saveSettings);
        }
        
        if (els.pronunciationToggle) {
            els.pronunciationToggle.addEventListener("click", function() {
                isPronunciationEnabled = !isPronunciationEnabled;
                els.pronunciationToggle.classList.toggle("active", isPronunciationEnabled);
                if (els.pronunciationSection) {
                    els.pronunciationSection.style.display = isPronunciationEnabled ? "block" : "none";
                }
                saveSettings();
                showStatus(`발음 도우미 ${isPronunciationEnabled ? "ON" : "OFF"}`, "success");
            });
        }
        
        const dailyBudgetEl = document.getElementById("dailyBudget");
        const monthlyBudgetEl = document.getElementById("monthlyBudget");
        
        if (dailyBudgetEl) {
            dailyBudgetEl.addEventListener("change", function(e) {
                localStorage.setItem("dailyBudget", e.target.value);
            });
        }
        
        if (monthlyBudgetEl) {
            monthlyBudgetEl.addEventListener("change", function(e) {
                localStorage.setItem("monthlyBudget", e.target.value);
            });
        }
        
        if (els.sourceLangSelect) {
            els.sourceLangSelect.addEventListener("change", function() {
                saveSettings();
                updateSpeakerLanguages();
            });
        }
        
        if (els.targetLangSelect) {
            els.targetLangSelect.addEventListener("change", function() {
                saveSettings();
                updateSpeakerLanguages();
            });
        }
        
        // AI 기능 이벤트 리스너들
        if (els.qualitySlider) {
            els.qualitySlider.addEventListener("input", function(e) {
                qualityLevel = parseInt(e.target.value);
                updateModelInfo(qualityLevel); // 옵션 1: 슬라이더 변경 시 모델 정보 업데이트
                saveAISettings();
            });
            // 초기 모델 정보 표시
            updateModelInfo(qualityLevel);
        }
        
        // 번역 스타일 버튼 이벤트
        document.querySelectorAll('.style-btn').forEach(function(btn) {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.style-btn').forEach(function(b) {
                    b.classList.remove('active');
                });
                btn.classList.add('active');
                currentTranslationStyle = btn.dataset.style;
                saveAISettings();
            });
        });
        
        // 단어장 탭 이벤트
        document.querySelectorAll('.vocab-tab').forEach(function(tab) {
            tab.addEventListener('click', function() {
                switchVocabTab(tab.dataset.tab);
            });
        });
        
        // 전문용어 입력 필드 엔터키 이벤트 (간소화)
        const terminologyInputEl = document.getElementById('terminologyInput');
        
        if (terminologyInputEl) {
            terminologyInputEl.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    addTerminology();
                }
            });
        }
        
        // 단어장 입력 필드 엔터키 이벤트
        if (els.vocabularyOriginal) {
            els.vocabularyOriginal.addEventListener('keypress', function(e) {
                if (e.key === 'Enter' && els.vocabularyTranslation) {
                    els.vocabularyTranslation.focus();
                }
            });
        }
        
        if (els.vocabularyTranslation) {
            els.vocabularyTranslation.addEventListener('keypress', function(e) {
                if (e.key === 'Enter' && els.vocabularyDescription) {
                    els.vocabularyDescription.focus();
                }
            });
        }
        
        if (els.vocabularyDescription) {
            els.vocabularyDescription.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    addVocabulary();
                }
            });
        }
        
        // 모달 외부 클릭 시 닫기
        if (els.wordDetailModal) {
            els.wordDetailModal.addEventListener('click', function(e) {
                if (e.target === els.wordDetailModal) {
                    closeWordDetail();
                }
            });
        }
        
        if (els.quizModal) {
            els.quizModal.addEventListener('click', function(e) {
                if (e.target === els.quizModal) {
                    closeQuiz();
                }
            });
        }
        
        if (els.practiceModal) {
            els.practiceModal.addEventListener('click', function(e) {
                if (e.target === els.practiceModal) {
                    closePractice();
                }
            });
        }
        
        // 오디오 컨텍스트 초기화
        ["touchstart", "click"].forEach(function(event) {
            document.addEventListener(event, initAudioContext, { once: true });
        });
        
        console.log("✅ 번역기 v6.0 초기화 완료");
        
        // 🔧 모든 모달 강제 숨김 처리
// 🔧 모든 모달 강제 숨김 처리 (로그인 모달 제외)
setTimeout(() => {
    const modals = [
        'practiceModal', 
        'wordDetailModal', 
        'quizModal', 
        // 'authModal' 제거 - 로그인 모달은 숨기지 않음
        'dashboardModal', 
        'historyModal',
        'vocabularyDropdown'
    ];

    modals.forEach(modalId => {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.classList.remove('active');
            // practiceModal만 특별 처리
if (modalId === 'practiceModal') {
    modal.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important; position: fixed !important; top: -9999px !important; left: -9999px !important;';
    modal.classList.remove('active');
}
            console.log(`[Debug] ${modalId} 강제 숨김 처리`);
        }
    });

    console.log("[Debug] 모달 숨김 처리 완료 (authModal 제외)");
}, 100);
        
    } catch (error) {
        console.error('초기화 오류:', error);
        showStatus("⚠️ 시스템 초기화 중 오류 발생", "error");
    }
});
</script>
</body>
=======
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GPT 양방향 음성 번역기 Pro v6.0 - AI 문맥 번역 고도화</title>
    <link rel="stylesheet" href="css/styles.css">
    <!-- 성능 최적화: CSS 외부 파일로 분리하여 캐싱 가능 -->
</head>
<body>
    <div class="container">
        <div class="header">
            <!-- 제목을 별도 줄로 -->
            <div class="header-title">
                <h1>GPT 번역기 Pro v6.0</h1>
            </div>
            <!-- 아이콘들을 별도 줄로 -->
            <div class="header-controls">
                <button class="ai-toggle" id="aiToggle" onclick="toggleAIModeWithAuth()" title="AI 문맥 번역">🧠</button>
                <button class="vocab-toggle" id="vocabToggle" onclick="toggleVocabularyWithAuth()" title="고급 단어장">📚</button>
                <button class="dashboard-toggle" onclick="toggleDashboard()">📊</button>
                <button class="settings-toggle" onclick="toggleSettings()">⚙️</button>
                <button class="theme-toggle" onclick="toggleTheme()">🌙</button>
                <button class="login-toggle" id="loginToggle" onclick="handleLoginClick()" title="로그인/회원가입">👤</button>
            </div>
            <div class="language-selector">
                <select id="sourceLangSelect"><option value="Korean">한국어</option><option value="Vietnamese">베트남어</option><option value="English">영어</option></select>
                <button onclick="swapLanguages()">⇄</button>
                <select id="targetLangSelect"><option value="Vietnamese">베트남어</option><option value="Korean">한국어</option><option value="English">영어</option></select>
            </div>
            <span class="auto-detect-badge" id="autoDetectBadge"></span>
            <span class="ai-context-badge" id="aiContextBadge">🧠 AI 문맥 번역</span>
        </div>
        
        <div class="content">
            <div class="settings-panel" id="settingsPanel">
                <div class="settings-title"><span>⚙️ 설정</span><button class="settings-close" onclick="toggleSettings()">×</button></div>
                
                <!-- AI 문맥 번역 설정 섹션 -->
                <div class="ai-settings-section" id="aiSettingsSection">
                    <div class="ai-settings-title">🧠 AI 문맥 번역 고도화</div>

                    <div class="setting-item quality-setting-wrapper">
                        <div class="quality-setting-grid">
                            <label class="setting-label">번역 품질 vs 속도<small>높을수록 정확하지만 느림</small></label>
                            <div class="setting-control">
                                <input type="range" class="quality-slider" id="qualitySlider" min="1" max="5" value="3" step="1">
                            </div>
                        </div>
                        <div class="quality-labels">
                            <span>빠름</span><span>균형</span><span>정확</span>
                        </div>
                        <!-- 옵션 1: 실시간 모델 정보 표시 -->
                        <div class="model-info-display" id="modelInfoDisplay">
                            <span class="model-name">모델: gpt-4o</span>
                            <span class="model-cost">비용: 중간</span>
                            <span class="model-tokens">토큰: 1500</span>
                        </div>
                    </div>

                    <div class="setting-item">
                        <label class="setting-label">번역 스타일</label>
                        <div class="style-buttons">
                            <div class="style-btn active" data-style="balanced">균형잡힌</div>
                            <div class="style-btn" data-style="formal">격식체</div>
                            <div class="style-btn" data-style="casual">친근체</div>
                            <div class="style-btn" data-style="literal">직역체</div>
                        </div>
                    </div>

                    <div class="setting-item">
                        <label class="setting-label">🔧 전문용어 사전<small>일관된 번역을 위한 용어집 관리</small></label>
                        <div class="terminology-section">
                            <div class="terminology-input-group">
                                <input type="text" class="terminology-input-single" id="terminologyInput" placeholder="용어 등록: AI | 인공지능">
                                <button onclick="addTerminology()" class="terminology-add-btn">➕</button>
                            </div>
                            <div class="terminology-list" id="terminologyList"></div>
                        </div>
                    </div>
                </div>

                <div class="settings-grid">
                    <div class="setting-item">
                        <label class="setting-label" for="ttsEngineMode">🔊 TTS 엔진 선택<small>Google: 무료/일반 | OpenAI: 유료/고품질</small></label>
                        <div class="setting-control"><select id="ttsEngineMode"><option value="auto">🤖 자동 선택 (추천)</option><option value="google">🔵 Google TTS</option><option value="openai">🟢 OpenAI TTS</option><option value="smart">💡 스마트 모드</option></select></div>
                    </div>
                    <div class="setting-item" id="autoModeSettings">
                        <label class="setting-label" for="autoThreshold">자동 모드 임계값<small>이 글자 수 이하는 Google TTS 사용</small></label>
                        <div class="setting-control"><input type="range" id="autoThreshold" min="10" max="200" value="50" step="10"><span class="setting-value" id="thresholdValue">50자</span></div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label" for="voiceSelect">음성 선택 (OpenAI)</label>
                        <div class="setting-control"><select id="voiceSelect"><option value="nova">Nova (여성/선명)</option><option value="shimmer">Shimmer (여성/부드러움)</option><option value="alloy">Alloy (남성/차분)</option><option value="echo">Echo (남성/깊음)</option><option value="fable">Fable (남성/표현력)</option><option value="onyx">Onyx (남성/저음)</option></select></div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label" for="googleVoiceSelect">음성 선택 (Google)</label>
                        <div class="setting-control"><select id="googleVoiceSelect"><option value="vi-VN-Standard-A">🇻🇳 Standard-A (여)</option><option value="vi-VN-Standard-B">🇻🇳 Standard-B (남)</option><option value="vi-VN-Standard-C">🇻🇳 Standard-C (여)</option><option value="vi-VN-Standard-D">🇻🇳 Standard-D (남)</option><option value="ko-KR-Standard-A">🇰🇷 Standard-A (여)</option><option value="ko-KR-Standard-B">🇰🇷 Standard-B (여)</option><option value="ko-KR-Standard-C">🇰🇷 Standard-C (남)</option><option value="ko-KR-Standard-D">🇰🇷 Standard-D (남)</option></select></div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label" for="volumeControl">볼륨</label>
                        <div class="setting-control"><input type="range" id="volumeControl" min="0.1" max="1" value="0.8" step="0.1"><span class="setting-value" id="volumeValue">80%</span></div>
                    </div>
                    <div class="setting-item">
                         <label class="setting-label">발음 도우미<small>OFF 시 API 요청 비용이 절감됩니다.</small></label>
                         <div class="setting-control"><div class="toggle-switch" id="pronunciationToggle"></div></div>
                    </div>
                    <div class="setting-item">
                        <label class="setting-label">💾 캐시 설정<small>반복 요청 시 비용 절감 및 속도 향상</small></label>
                        <div class="setting-control"><button onclick="clearAllCache()" style="padding: 6px 12px; font-size: 11px; background-color: var(--error); border: none; border-radius: 5px; color: white;">🗑️ 캐시 초기화</button></div>
                    </div>
                </div>
            </div>

            <div class="recent-plays collapsed" id="recentPlays">
                <div class="recent-plays-title"><span>🔄 최근 재생</span><button class="recent-plays-toggle" onclick="toggleRecentPlays()" id="recentPlaysToggleBtn">펼치기</button></div>
                <div class="recent-play-list" id="recentPlayList" style="display: none;"></div>
            </div>
            
            <div class="mode-selector">
                <div class="mode-btn active" id="normalModeBtn" onclick="switchToNormalMode()">📝 일반 번역</div>
                <div class="mode-btn" id="conversationModeBtn" onclick="switchToConversationMode()">💬 대화 모드</div>
            </div>
            
            <div class="conversation-mode" id="conversationMode">
                <div class="speaker-info">
                    <div class="speaker-card speaker-a" id="speakerCardA"><div class="speaker-title">🙋‍♂️ 화자 A</div><div class="speaker-lang" id="speakerLangA"></div></div>
                    <div class="speaker-card speaker-b" id="speakerCardB"><div class="speaker-title">🙋‍♀️ 화자 B</div><div class="speaker-lang" id="speakerLangB"></div></div>
                </div>
                <div class="conversation-controls">
                    <button class="conv-btn conv-btn-start" id="startConversationBtn" onclick="startConversation()">🎤 시작</button>
                    <button class="conv-btn conv-btn-stop" id="stopConversationBtn" onclick="stopConversation()" disabled>⏹️ 종료</button>
                    <button class="conv-btn conv-btn-clear" onclick="clearConversation()">🗑️ 지우기</button>
                </div>
                <div class="conversation-history" id="conversationHistory"></div>
            </div>
            
            <div class="normal-mode" id="normalMode">
                <div class="input-wrapper">
                    <textarea id="inputText" placeholder="번역할 텍스트를 입력하세요..."></textarea>
                    <div class="input-actions">
                        <button class="input-action-btn" onclick="copyInputText()">복사</button>
                        <button class="input-action-btn" onclick="pasteFromClipboard()">붙여넣기</button>
                    </div>
                </div>
                <div class="controls">
                    <button class="btn-translate" id="translateBtn" onclick="handleTranslate()"><span>📝</span> <span id="translateBtnText">번역하기</span></button>
                    <button class="btn-voice" id="voiceBtn" onclick="handleVoiceTranslate()"><span>🎤</span> 음성 번역</button>
                    <button class="btn-clear" onclick="clearAll()"><span>🗑️</span> 모두 지우기</button>
                    <button class="btn-history" onclick="showHistory()"><span>📜</span> 기록 보기</button>
                </div>
                <div class="result-section">
                    <div class="result-header">
                        <span class="result-label">번역 결과<span id="cacheIndicator" class="cache-indicator" style="display: none;">캐시됨</span><span id="aiIndicator" class="engine-indicator ai" style="display: none;">AI</span><span id="translationModelInfo" class="translation-model-info" style="display: none;"></span></span>
                        <div class="result-actions">
                            <button class="btn-action" onclick="copyTranslation()" id="copyBtn" disabled>📋 복사</button>
                            <button class="btn-action" id="speakBtn" onclick="handleSpeak()" disabled>🔊 듣기<span id="engineIndicator" class="engine-indicator" style="display: none;"></span></button>
                        </div>
                    </div>
                    <div id="translation"></div>
                </div>
                <div class="pronunciation-section" id="pronunciationSection">
                    <div class="pronunciation-label" onclick="togglePronunciationView()">발음 도우미 <span id="pronToggleIcon">▼</span></div>
                    <div id="pronunciation-content"></div>
                </div>
                <div class="translation-stats">
                    <div class="stat-item"><strong id="todayTranslations">0</strong><span>오늘 번역</span></div>
                    <div class="stat-item"><strong id="totalTranslations">0</strong><span>총 번역</span></div>
                    <div class="stat-item"><strong id="cacheHitRate">0%</strong><span>캐시 적중률</span></div>
                </div>
            </div>
            
            <div class="status" id="status"></div>
        </div>
    </div>
    
    <!-- 단어장 드롭다운 모달 -->
<div class="vocabulary-dropdown" id="vocabularyDropdown">
    <div class="vocabulary-dropdown-wrapper">
        <div class="vocabulary-dropdown-header">
            <span>📚 고급 단어장</span>
            <button class="vocabulary-close-btn" onclick="toggleVocabulary()">×</button>
        </div>
        <div class="vocabulary-dropdown-content">
            <div class="vocabulary-tabs">
                <div class="vocab-tab active" data-tab="add">📝 추가</div>
                <div class="vocab-tab" data-tab="list">📖 목록</div>
                <div class="vocab-tab" data-tab="quiz">🎯 퀴즈</div>
                <div class="vocab-tab" data-tab="stats">📊 통계</div>
            </div>
            
            <div class="vocab-content" id="vocabAdd">
                <div class="vocabulary-input-group">
                    <input type="text" class="vocabulary-input" id="vocabularyOriginal" placeholder="원어 (예: Apple)">
                    <input type="text" class="vocabulary-input" id="vocabularyTranslation" placeholder="번역어 (예: 사과)">
                </div>
                <input type="text" class="vocabulary-input description" id="vocabularyDescription" placeholder="상세 설명 (예: 빨갛고 달콤한 과일)">
                <button onclick="addVocabulary()" style="width: 100%; padding: 8px; background: var(--success); color: white; border: none; border-radius: 6px; font-size: 11px; margin-top: 8px;">📚 단어 추가</button>
            </div>
            
            <div class="vocab-content" id="vocabList" style="display: none;">
                <div class="vocabulary-list" id="vocabularyList"></div>
                <div class="vocabulary-stats" id="vocabularyStats">
                    <span>총 단어: <strong id="totalWords">0</strong></span>
                    <span>퀴즈 정답률: <strong id="quizAccuracy">0%</strong></span>
                    <span>연습 시간: <strong id="practiceTime">0분</strong></span>
                </div>
            </div>
            
            <div class="vocab-content" id="vocabQuiz" style="display: none;">
                <button onclick="startQuiz()" style="width: 100%; padding: 12px; background: var(--success); color: white; border: none; border-radius: 8px; font-weight: bold; margin-bottom: 10px;">🎯 랜덤 퀴즈 시작</button>
                <button onclick="startQuiz('difficult')" style="width: 100%; padding: 12px; background: var(--warning); color: white; border: none; border-radius: 8px; font-weight: bold;">💪 어려운 단어 도전</button>
            </div>
            
            <div class="vocab-content" id="vocabStats" style="display: none;">
                <div style="text-align: center; padding: 20px; color: var(--text-secondary);">
                    <div style="font-size: 24px; font-weight: bold; color: var(--success); margin-bottom: 10px;" id="learningProgress">0%</div>
                    <div style="margin-bottom: 15px;">학습 진도</div>
                    <div style="background: var(--border); height: 8px; border-radius: 4px; overflow: hidden; margin-bottom: 15px;">
                        <div id="progressBar" style="background: var(--success); height: 100%; width: 0%; transition: width 0.3s;"></div>
                    </div>
                    <div style="font-size: 12px; color: var(--text-secondary);">꾸준한 학습이 실력 향상의 비결입니다!</div>
                </div>
            </div>
        </div>
    </div>
</div>
    

    <!-- 🔧 수정: 대시보드 모달에 월 비용 카드 추가 -->
    <div class="modal" id="dashboardModal">
        <div class="modal-content-wrapper">
            <div class="modal-header">
                <span class="modal-title">📊 대시보드</span>
                <button class="modal-close" onclick="toggleDashboard()">×</button>
            </div>
            <div class="usage-cards">
                <div class="usage-card">
                    <div class="usage-card-value" id="todayUsage">0</div>
                    <div class="usage-card-label">오늘 번역</div>
                </div>
                <div class="usage-card">
                    <div class="usage-card-value" id="monthUsage">0</div>
                    <div class="usage-card-label">이번 달</div>
                </div>
                <div class="usage-card">
                    <div class="usage-card-value" id="todayCost">$0.00</div>
                    <div class="usage-card-label">오늘 비용</div>
                </div>
                <!-- ➕ 새로 추가: 해당 월 비용 카드 -->
                <div class="usage-card">
                    <div class="usage-card-value" id="monthCost">$0.00</div>
                    <div class="usage-card-label">이번 달 비용</div>
                </div>
                <div class="usage-card">
                    <div class="usage-card-value" id="savedCost">$0.00</div>
                    <div class="usage-card-label">절감 비용</div>
                </div>
            </div>
            <div class="chart-container">
                <div class="chart-title">📈 7일 사용량</div>
                <div class="simple-bar-chart" id="weeklyChart"></div>
            </div>
            <!-- ➕ 새로 추가: 월별 비용 차트 -->
            <div class="chart-container">
                <div class="chart-title">💰 월별 비용 추이 (최근 6개월)</div>
                <div class="simple-bar-chart" id="monthlyChart"></div>
            </div>
            <div class="limit-settings">
                <div class="limit-title">⚠️ API 한도 관리</div>
                <div class="limit-item">
                    <span class="limit-label">일일 예산 ($)</span>
                    <input type="number" class="limit-input" id="dailyBudget" value="1.00" step="0.10">
                </div>
                <div class="limit-item">
                    <span class="limit-label">월간 예산 ($)</span>
                    <input type="number" class="limit-input" id="monthlyBudget" value="30.00" step="1.00">
                </div>
                <div class="limit-progress">
                    <div class="limit-progress-bar" id="budgetProgress"></div>
                </div>
                <div class="limit-percentage" id="budgetPercentage">0% 사용</div>
                <div class="limit-item" style="margin-top: 15px;">
                    <span class="limit-label">한도 도달 시</span>
                    <select id="limitAction" style="width: 150px; padding: 5px; border-radius: 5px; font-size: 12px;">
                        <option value="switch">Google로 전환</option>
                        <option value="warn">경고만</option>
                        <option value="block">차단</option>
                    </select>
                </div>
            </div>
        </div>
    </div>
    
    <div class="modal" id="historyModal"><div class="modal-content-wrapper"><div class="modal-header"><span class="modal-title">📜 번역 기록</span><button class="modal-close" onclick="hideHistory()">×</button></div><div id="historyList" style="max-height: 400px; overflow-y: auto;"></div><button onclick="clearHistory()" style="width: 100%; margin-top: 15px; background: var(--error); color: white; border: none; border-radius: 5px; padding: 8px;">기록 모두 삭제</button></div></div>
    
    <!-- 단어 상세 모달 -->
    <div class="word-detail-modal" id="wordDetailModal">
        <div class="word-detail-content">
            <div class="word-detail-header">
                <span class="word-detail-title">📚 단어 상세</span>
                <button class="word-detail-close" onclick="closeWordDetail()">×</button>
            </div>
            <div class="word-detail-main">
                <div class="word-detail-original" id="wordDetailOriginal"></div>
                <div class="word-detail-translation" id="wordDetailTranslation"></div>
                <div class="word-detail-pronunciation" id="wordDetailPronunciation"></div>
            </div>
            <div class="word-detail-description">
                <div class="word-detail-description-title">📝 상세 설명</div>
                <div class="word-detail-description-text" id="wordDetailDescription"></div>
            </div>
           <div class="word-detail-actions">
    <button class="word-detail-btn speak" onclick="speakCurrentWord()">🔊 발음</button>
    <button class="word-detail-btn quiz" onclick="startSingleWordQuiz()">🎯 퀴즈</button>
    <button class="word-detail-btn practice" onclick="startPronunciationPractice()">🎤 연습</button>
</div>
<div style="display: flex; gap: 10px; justify-content: center; margin-top: 15px;">
    <button class="word-detail-btn" style="background: var(--text-secondary);" onclick="showPreviousWord()">⬅️ 이전</button>
    <button class="word-detail-btn" style="background: var(--text-secondary);" onclick="showNextWord()">다음 ➡️</button>
</div>
        </div>
    </div>
    
    <!-- 퀴즈 모달 -->
    <div class="quiz-modal" id="quizModal">
        <div class="quiz-content">
            <div class="quiz-header">
                <div class="quiz-title">🎯 단어 퀴즈</div>
                <div class="quiz-progress">
                    <div class="quiz-progress-bar" id="quizProgressBar"></div>
                </div>
                <div class="quiz-stats">
                    <span>문제: <strong id="quizCurrent">1</strong>/<strong id="quizTotal">10</strong></span>
                    <span>정답: <strong id="quizCorrect">0</strong></span>
                    <span>오답: <strong id="quizWrong">0</strong></span>
                </div>
            </div>
            <div class="quiz-question">
                <div class="quiz-question-text" id="quizQuestionText"></div>
                <div class="quiz-question-hint" id="quizQuestionHint"></div>
            </div>
            <div class="quiz-options" id="quizOptions"></div>
            <div class="quiz-controls">
                <button class="quiz-btn secondary" onclick="closeQuiz()">나가기</button>
                <button class="quiz-btn primary" id="quizNextBtn" onclick="nextQuestion()" disabled>다음</button>
            </div>
            <div class="quiz-result" id="quizResult" style="display: none;">
                <div class="quiz-score" id="quizFinalScore"></div>
                <div class="quiz-message" id="quizMessage"></div>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="quiz-btn primary" onclick="startQuiz()">다시 시작</button>
                    <button class="quiz-btn secondary" onclick="closeQuiz()">완료</button>
                </div>
            </div>
        </div>
    </div>
</div>
<!-- 발음 연습 모달 -->
    <div class="practice-modal" id="practiceModal">
        <div class="practice-content">
            <div class="practice-title">🎤 발음 연습</div>
            <div class="practice-word" id="practiceWord"></div>
            <div class="practice-pronunciation" id="practicePronunciation"></div>
            <div class="practice-controls">
                <button class="practice-btn listen" onclick="listenPracticeWord()" title="듣기">🔊</button>
                <button class="practice-btn record" id="recordBtn" onclick="toggleRecording()" title="녹음">🎤</button>
            </div>
            <div class="practice-feedback" id="practiceFeedback" style="display: none;">
                <div class="practice-feedback-title">🔊 발음 피드백</div>
                <div class="practice-feedback-text" id="practiceFeedbackText"></div>
            </div>
            <div class="practice-tips">
                <div class="practice-tips-title">💡 발음 팁</div>
                <div class="practice-tips-text" id="practiceTips"></div>
            </div>
            <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                <button class="quiz-btn primary" onclick="nextPracticeWord()">다음 단어</button>
                <button class="quiz-btn secondary" onclick="closePractice()">완료</button>
            </div>
        </div>
    </div>
        <!-- 🔐 로그인/회원가입 모달 -->
 <div class="auth-modal" id="authModal">
    <div class="auth-content">
        <div class="auth-header">
            <div class="auth-tabs">
                <button class="auth-tab active" data-tab="login">🔑 로그인</button>
                <button class="auth-tab" data-tab="register">📝 회원가입</button>
            </div>
            <button class="auth-close" onclick="toggleAuth()">×</button>
        </div>

        <div class="auth-form active" id="loginForm">
            <div class="auth-form-title">GPT 번역기 Pro 로그인</div>
            <div class="auth-input-group">
                <input type="email" id="loginEmail" placeholder="이메일 주소" required>
                <input type="password" id="loginPassword" placeholder="비밀번호" required>
            </div>
            <button class="auth-btn primary" onclick="handleLogin()">🔑 로그인</button>
            <div class="auth-divider">또는</div>
            <button class="auth-btn guest" onclick="continueAsGuest()">🎯 게스트로 계속하기</button>
             <div class="auth-links">
                <a href="#" onclick="event.preventDefault(); switchAuthTab('forgot');">비밀번호를 잊으셨나요?</a>
            </div>
        </div>

        <div class="auth-form" id="registerForm">
            <div class="auth-form-title">새 계정 만들기</div>
            <div class="auth-input-group">
                <input type="text" id="registerName" placeholder="이름 (선택사항)">
                <input type="email" id="registerEmail" placeholder="이메일 주소" required>
                <input type="password" id="registerPassword" placeholder="비밀번호 (8자 이상)" required>
                <input type="password" id="registerPasswordConfirm" placeholder="비밀번호 확인" required>
            </div>
            <div class="auth-agreement">
                <label class="auth-checkbox">
                    <input type="checkbox" id="agreeTerms" required>
                    <span>서비스 이용약관 및 개인정보처리방침에 동의합니다</span>
                </label>
            </div>
            <button class="auth-btn primary" onclick="handleRegister()">📝 회원가입</button>
            <div class="auth-links">
                <a href="#" onclick="event.preventDefault(); switchAuthTab('login');">← 로그인으로 돌아가기</a>
            </div>
        </div>

        <div class="auth-form" id="forgotForm">
            <div class="auth-form-title">비밀번호 재설정</div>
            <div class="auth-input-group">
                <input type="email" id="forgotEmail" placeholder="가입한 이메일 주소" required>
            </div>
            <button class="auth-btn primary" onclick="handleForgotPassword()">📧 재설정 링크 보내기</button>
            <div class="auth-links">
                <a href="#" onclick="event.preventDefault(); switchAuthTab('login');">← 로그인으로 돌아가기</a>
            </div>
        </div>
    </div>
</div>

    <div class="auth-info">
        </div>
</div>
                <div class="auth-info">
                    <small>• 개인 API 키 등록으로 무제한 번역</small>
                    <small>• 사용량 추적 및 분석</small>
                    <small>• 고급 단어장 및 학습 기록 저장</small>
                </div>
            </div>
            
            <!-- 비밀번호 찾기 폼 -->
            <div class="auth-form" id="forgotForm" style="display: none;">
                <div class="auth-form-title">비밀번호 재설정</div>
                <div class="auth-input-group">
                    <input type="email" id="forgotEmail" placeholder="가입한 이메일 주소" required>
                </div>
                <button class="auth-btn primary" onclick="handleForgotPassword()">📧 재설정 링크 보내기</button>
                <div class="auth-links">
                    <a href="#" onclick="showLoginForm()">← 로그인으로 돌아가기</a>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 🔧 API 키 관리 모달 -->
    <div class="api-keys-modal" id="apiKeysModal">
        <div class="api-keys-content">
            <div class="api-keys-header">
                <span class="api-keys-title">🔑 API 키 관리</span>
                <button class="api-keys-close" onclick="toggleApiKeys()">×</button>
            </div>
            <div class="api-keys-body">
                <div class="api-key-section">
                    <div class="api-key-title">🤖 OpenAI API 키</div>
                    <div class="api-key-description">번역 및 TTS 기능을 위한 OpenAI API 키를 등록하세요</div>
                    <div class="api-key-input-group">
                        <input type="password" id="openaiApiKey" placeholder="sk-..." maxlength="200">
                        <button class="api-key-btn test" onclick="testOpenAIKey()">테스트</button>
                        <button class="api-key-btn save" onclick="saveOpenAIKey()">저장</button>
                    </div>
                    <div class="api-key-status" id="openaiKeyStatus"></div>
                </div>
                
                <div class="api-key-section">
                    <div class="api-key-title">🎤 Google TTS API 키</div>
                    <div class="api-key-description">고품질 음성 합성을 위한 Google Cloud API 키 (선택사항)</div>
                    <div class="api-key-input-group">
                        <input type="password" id="googleApiKey" placeholder="AIza..." maxlength="200">
                        <button class="api-key-btn test" onclick="testGoogleKey()">테스트</button>
                        <button class="api-key-btn save" onclick="saveGoogleKey()">저장</button>
                    </div>
                    <div class="api-key-status" id="googleKeyStatus"></div>
                </div>
                
                <div class="api-key-info">
                    <div class="api-key-info-title">💡 API 키 사용 혜택</div>
                    <ul>
                        <li>✅ 무제한 번역 및 TTS 사용</li>
                        <li>✅ 개인 사용량 및 비용 추적</li>
                        <li>✅ 더 빠른 응답 속도</li>
                        <li>✅ 프리미엄 기능 이용</li>
                    </ul>
                    <div class="api-key-help">
                        <a href="https://platform.openai.com/api-keys" target="_blank">OpenAI API 키 발급받기 →</a>
                        <br>
                        <a href="https://console.cloud.google.com/" target="_blank">Google Cloud API 키 발급받기 →</a>
                    </div>
                </div>
            </div>
        </div>
    </div>
        
<script>
// ========== localStorage 비동기 래퍼 (성능 최적화) ==========
// UI 블로킹 방지를 위한 비동기 스토리지 유틸리티

const AsyncStorage = {
    // 읽기 (Promise 기반)
    async getItem(key) {
        return new Promise((resolve) => {
            // requestIdleCallback으로 유휴 시간에 실행
            if ('requestIdleCallback' in window) {
                requestIdleCallback(() => {
                    resolve(localStorage.getItem(key));
                });
            } else {
                // Fallback: setTimeout으로 마이크로태스크 큐에 추가
                setTimeout(() => {
                    resolve(localStorage.getItem(key));
                }, 0);
            }
        });
    },

    // 쓰기 (Promise 기반)
    async setItem(key, value) {
        return new Promise((resolve) => {
            if ('requestIdleCallback' in window) {
                requestIdleCallback(() => {
                    localStorage.setItem(key, value);
                    resolve();
                });
            } else {
                setTimeout(() => {
                    localStorage.setItem(key, value);
                    resolve();
                }, 0);
            }
        });
    },

    // 삭제 (Promise 기반)
    async removeItem(key) {
        return new Promise((resolve) => {
            if ('requestIdleCallback' in window) {
                requestIdleCallback(() => {
                    localStorage.removeItem(key);
                    resolve();
                });
            } else {
                setTimeout(() => {
                    localStorage.removeItem(key);
                    resolve();
                }, 0);
            }
        });
    },

    // 동기식 읽기 (즉시 필요한 경우만 사용)
    getItemSync(key) {
        return localStorage.getItem(key);
    },

    // 동기식 쓰기 (즉시 필요한 경우만 사용)
    setItemSync(key, value) {
        localStorage.setItem(key, value);
    }
};

// 디바운스 유틸리티 (빈번한 저장 방지)
function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

// ===================================================
// GPT 양방향 음성 번역기 Pro v6.0 - AI 문맥 번역 고도화
// ===================================================
const API_URL = 'https://knstranslator.netlify.app/.netlify/functions/translate';
const AUTH_API_URL = 'https://knstranslator.netlify.app/.netlify/functions/auth'; // 🔧 추가: 인증 API URL

// 🔐 사용자 인증 시스템
let currentUser = null;
let authToken = null;

// 🔐 인증 상태 관리 (개선)
async function initAuthSystem() {
    console.log('[Auth] 시스템 초기화 시작');
    
    // 저장된 토큰 확인
    const savedToken = localStorage.getItem('authToken');
    const savedUser = localStorage.getItem('currentUser');
    
    if (savedToken && savedUser) {
        try {
            // 🔧 개선: 실제 토큰 검증
            const isValidToken = await verifyStoredToken(savedToken);
            
            if (isValidToken) {
                authToken = savedToken;
                currentUser = JSON.parse(savedUser);
                updateAuthUI(true);
                
                console.log('[Auth] 사용자 세션 복원 성공:', currentUser.email);
                
                // 🔧 추가: 사용자 데이터 새로고침
                await refreshUserData();
                
                showStatus(`👋 ${currentUser.displayName || currentUser.email}님 환영합니다!`, "success");
            } else {
                console.log('[Auth] 저장된 토큰이 만료되었습니다');
                clearAuthData();
                updateAuthUI(false);
                showStatus("세션이 만료되었습니다. 다시 로그인해주세요", "warning");
            }
        } catch (error) {
            console.error('[Auth] 세션 복원 실패:', error);
            clearAuthData();
            updateAuthUI(false);
        }
    } else {
        console.log('[Auth] 저장된 인증 정보 없음 - 게스트 모드');
        updateAuthUI(false);
    }
    
    // 🔧 추가: 인증 관련 이벤트 리스너 설정
    setupAuthEventListeners();
}

// 🔐 저장된 토큰 검증
async function verifyStoredToken(token) {
    try {
        const response = await fetch(AUTH_API_URL, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({
                action: 'verify-token'
            })
        });
        
        const result = await response.json();
        return result.success || false;
        
    } catch (error) {
        console.error('[Auth] 토큰 검증 오류:', error);
        return false;
    }
}

// 🔐 사용자 데이터 새로고침
async function refreshUserData() {
    if (!currentUser || !authToken) return;
    
    try {
        console.log('[Auth] 사용자 데이터 새로고침 중...');
        
        // 🔧 API 키 상태 확인
        const apiKeysResponse = await fetch(AUTH_API_URL, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({
                action: 'get-api-keys'
            })
        });
        
        if (apiKeysResponse.ok) {
            const apiKeysData = await apiKeysResponse.json();
            if (apiKeysData.success) {
                // 🔧 사용자 객체에 API 키 정보 추가
                currentUser.hasOpenAIKey = apiKeysData.openaiKey;
                currentUser.hasGoogleKey = apiKeysData.googleKey;
                
                console.log('[Auth] API 키 상태 업데이트:', {
                    openai: currentUser.hasOpenAIKey,
                    google: currentUser.hasGoogleKey
                });
            }
        }
        
        // 🔧 사용량 데이터 새로고침
        await refreshUsageData();
        
        // 🔧 업데이트된 사용자 정보 저장
        localStorage.setItem('currentUser', JSON.stringify(currentUser));
        
    } catch (error) {
        console.error('[Auth] 사용자 데이터 새로고침 실패:', error);
    }
}

// 🔐 사용량 데이터 새로고침
async function refreshUsageData() {
    if (!authToken) return;
    
    try {
        const response = await fetch(AUTH_API_URL, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({
                action: 'get-usage'
            })
        });
        
        if (response.ok) {
            const usageData = await response.json();
            if (usageData.success) {
                // 🔧 실제 사용량 데이터로 UI 업데이트
                updateUsageUI(usageData.usage);
                
                console.log('[Auth] 사용량 데이터 업데이트 완료');
            }
        }
        
    } catch (error) {
        console.error('[Auth] 사용량 데이터 새로고침 실패:', error);
    }
}

// 🔐 사용량 UI 업데이트
function updateUsageUI(usageData) {
    if (!usageData) return;
    
    // 대시보드 카드 업데이트
    const todayUsageEl = document.getElementById('todayUsage');
    const monthUsageEl = document.getElementById('monthUsage');
    const todayCostEl = document.getElementById('todayCost');
    const monthCostEl = document.getElementById('monthCost');
    
    if (todayUsageEl) todayUsageEl.textContent = usageData.today?.translations || 0;
    if (monthUsageEl) monthUsageEl.textContent = usageData.thisMonth?.translations || 0;
    if (todayCostEl) todayCostEl.textContent = `$${(usageData.today?.cost || 0).toFixed(4)}`;
    if (monthCostEl) monthCostEl.textContent = `$${(usageData.thisMonth?.cost || 0).toFixed(4)}`;
    
    // 통계 정보 업데이트
    const todayTranslationsEl = document.getElementById('todayTranslations');
    if (todayTranslationsEl) todayTranslationsEl.textContent = usageData.today?.translations || 0;
    
    // 주간 차트 업데이트
    if (usageData.weekly && usageData.weekly.length > 0) {
        updateWeeklyChart(usageData.weekly);
    }
}

// 🔐 주간 차트 업데이트
function updateWeeklyChart(weeklyData) {
    const chartEl = document.getElementById('weeklyChart');
    if (!chartEl) return;
    
    const maxTranslations = Math.max(...weeklyData.map(d => d.translation_count || 0), 1);
    
    chartEl.innerHTML = weeklyData.map(dayData => {
        const count = dayData.translation_count || 0;
        const height = (count / maxTranslations) * 100;
        const date = new Date(dayData.date);
        const dayLabel = date.toLocaleDateString('ko-KR', { weekday: 'short' });
        
        return `
            <div class="bar" style="height: ${height}%">
                <span class="bar-value">${count}</span>
                <span class="bar-label">${dayLabel}</span>
            </div>
        `;
    }).join('');
}

// 🔐 인증 이벤트 리스너 설정
function setupAuthEventListeners() {
    // 🔧 인증 탭 전환 이벤트
    document.querySelectorAll('.auth-tab').forEach(tab => {
        tab.addEventListener('click', function() {
            switchAuthTab(this.dataset.tab);
        });
    });
    
    // 🔧 API 키 관리 이벤트는 이미 setupApiKeyEvents()에서 처리
    setupApiKeyEvents();
    
    // 🔧 로그인 폼 엔터키 처리
    const loginEmail = document.getElementById('loginEmail');
    const loginPassword = document.getElementById('loginPassword');
    
    if (loginEmail) {
        loginEmail.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                loginPassword?.focus();
            }
        });
    }
    
    if (loginPassword) {
        loginPassword.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                handleLogin();
            }
        });
    }
    
    // 🔧 회원가입 폼 엔터키 처리
    const registerPassword = document.getElementById('registerPassword');
    const registerPasswordConfirm = document.getElementById('registerPasswordConfirm');
    
    if (registerPassword) {
        registerPassword.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                registerPasswordConfirm?.focus();
            }
        });
    }
    
    if (registerPasswordConfirm) {
        registerPasswordConfirm.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                handleRegister();
            }
        });
    }
}

// 🔧 로그인 클릭 핸들러 (디버그용)
function handleLoginClick() {
    if (currentUser) {
        // 로그인된 상태: 사용자에게 로그아웃할지 API 키를 관리할지 선택권을 줍니다.
        if (confirm('로그아웃하시겠습니까?\n\n취소를 누르면 API 키 관리 화면으로 이동합니다.')) {
            handleLogout(); // "확인" 클릭 시 로그아웃 함수 호출
        } else {
            toggleApiKeys(); // "취소" 클릭 시 API 키 관리 창 열기
        }
    } else {
        // 로그인 안된 상태: 로그인 모달 열기
        toggleAuth();
    }
}

// 참고: handleLogout 함수는 이미 아래와 같이 구현되어 있습니다.
function handleLogout() {
    if (confirm('로그아웃 하시겠습니까?')) {
        clearAuthData();
        updateAuthUI(false);
        showStatus("로그아웃되었습니다", "info");
    }
}

// 🔐 인증 모달 토글 (강화된 디버그)
function toggleAuth() {
    console.log('[Debug] toggleAuth 시작');
    
    const authModal = document.getElementById('authModal');
    
    if (!authModal) {
        console.error('[Debug] authModal 요소를 찾을 수 없습니다');
        return;
    }
    
    // 이미 로그인된 경우
    if (currentUser) {
        console.log('[Debug] 로그인된 사용자 - API 키 관리로 전환');
        toggleApiKeys();
        return;
    }
    
    // 모달 토글
    const isActive = authModal.classList.contains('active');
    console.log('[Debug] 현재 모달 상태:', isActive ? '열림' : '닫힘');
    
    if (isActive) {
        authModal.classList.remove('active');
        console.log('[Debug] 모달 닫기 완료');
    } else {
        authModal.classList.add('active');
        console.log('[Debug] 모달 열기 완료');
        
        // 다른 모달들 닫기
        document.getElementById('dashboardModal')?.classList.remove('active');
        document.getElementById('settingsPanel')?.classList.remove('active');
        document.getElementById('vocabularyDropdown')?.classList.remove('active');
        document.getElementById('practiceModal')?.classList.remove('active');
        document.getElementById('wordDetailModal')?.classList.remove('active');
        document.getElementById('quizModal')?.classList.remove('active');
        console.log('[Debug] 다른 모달들 닫기 완료');
    }
}

// 🔐 API 키 관리 모달 토글
function toggleApiKeys() {
    const apiKeysModal = document.getElementById('apiKeysModal');
    
    if (!currentUser) {
        showStatus("API 키 관리는 로그인 후 이용 가능합니다", "warning");
        toggleAuth();
        return;
    }
    
    apiKeysModal.classList.toggle('active');
    
    if (apiKeysModal.classList.contains('active')) {
        loadUserApiKeys();
        // 다른 모달들 닫기
        document.getElementById('authModal')?.classList.remove('active');
        document.getElementById('dashboardModal')?.classList.remove('active');
    }
}

// 🔐 인증 탭 전환
function switchAuthTab(tabName) {
    // 탭 활성화
    document.querySelectorAll('.auth-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    const activeTab = document.querySelector(`[data-tab="${tabName}"]`);
    if (activeTab) {
        activeTab.classList.add('active');
    }

    // 모든 폼 숨기기
    document.querySelectorAll('.auth-form').forEach(form => {
        form.classList.remove('active');
    });

    // 목표 폼 표시
    const targetFormId = tabName === 'login' ? 'loginForm' : 'registerForm';
    const targetForm = document.getElementById(targetFormId);
    if (targetForm) {
        targetForm.classList.add('active');
    }
}

// 🔐 로그인 처리
async function handleLogin() {
    const email = document.getElementById('loginEmail').value.trim();
    const password = document.getElementById('loginPassword').value;
    
    if (!email || !password) {
        showStatus("이메일과 비밀번호를 입력해주세요", "warning");
        return;
    }
    
    showStatus("로그인 중...", "info");
    
    try {
        const response = await fetch(AUTH_API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                action: 'login',
                email: email,
                password: password
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            currentUser = result.user;
            authToken = result.token;
            
            // 로컬 스토리지에 저장
            localStorage.setItem('authToken', authToken);
            localStorage.setItem('currentUser', JSON.stringify(currentUser));
            
            updateAuthUI(true);
            toggleAuth(); // 모달 닫기
            
            showStatus(`✅ ${currentUser.displayName || currentUser.email}님 환영합니다!`, "success");
            
            // 폼 초기화
            document.getElementById('loginEmail').value = '';
            document.getElementById('loginPassword').value = '';
            
        } else {
            showStatus(`로그인 실패: ${result.error}`, "error");
        }
        
    } catch (error) {
        console.error('[Auth] 로그인 오류:', error);
        showStatus("로그인 중 오류가 발생했습니다", "error");
    }
}

// 🔐 회원가입 처리
async function handleRegister() {
    const name = document.getElementById('registerName').value.trim();
    const email = document.getElementById('registerEmail').value.trim();
    const password = document.getElementById('registerPassword').value;
    const passwordConfirm = document.getElementById('registerPasswordConfirm').value;
    const agreeTerms = document.getElementById('agreeTerms').checked;
    
    // 유효성 검사
    if (!email || !password) {
        showStatus("이메일과 비밀번호를 입력해주세요", "warning");
        return;
    }
    
    if (password.length < 8) {
        showStatus("비밀번호는 8자 이상이어야 합니다", "warning");
        return;
    }
    
    if (password !== passwordConfirm) {
        showStatus("비밀번호가 일치하지 않습니다", "warning");
        return;
    }
    
    if (!agreeTerms) {
        showStatus("서비스 이용약관에 동의해주세요", "warning");
        return;
    }
    
    showStatus("회원가입 중...", "info");
    
    try {
        const response = await fetch(AUTH_API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                action: 'register',
                email: email,
                password: password,
                displayName: name || null
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            showStatus("✅ 회원가입이 완료되었습니다. 로그인해주세요", "success");
            
            // 폼 초기화
            document.getElementById('registerName').value = '';
            document.getElementById('registerEmail').value = '';
            document.getElementById('registerPassword').value = '';
            document.getElementById('registerPasswordConfirm').value = '';
            document.getElementById('agreeTerms').checked = false;
            
            // 로그인 탭으로 전환
            switchAuthTab('login');
            
            // 이메일 자동 입력
            document.getElementById('loginEmail').value = email;
            
        } else {
            showStatus(`회원가입 실패: ${result.error}`, "error");
        }
        
    } catch (error) {
        console.error('[Auth] 회원가입 오류:', error);
        showStatus("회원가입 중 오류가 발생했습니다", "error");
    }
}

// 🔐 로그아웃 처리
function handleLogout() {
    if (confirm('로그아웃 하시겠습니까?')) {
        clearAuthData();
        updateAuthUI(false);
        showStatus("로그아웃되었습니다", "info");
    }
}

// 🔐 게스트 모드 계속
function continueAsGuest() {
    toggleAuth(); // 모달 닫기
    showStatus("🎯 게스트 모드로 이용 중입니다", "info");
}

// 🔐 비밀번호 찾기 표시
function showForgotPassword() {
    document.querySelectorAll('.auth-form').forEach(form => {
        form.style.display = 'none';
    });
    document.getElementById('forgotForm').style.display = 'block';
}

// 🔐 로그인 폼으로 돌아가기
function showLoginForm() {
    document.querySelectorAll('.auth-form').forEach(form => {
        form.style.display = 'none';
    });
    document.getElementById('loginForm').style.display = 'block';
}

// 🔐 비밀번호 재설정 처리
async function handleForgotPassword() {
    const email = document.getElementById('forgotEmail').value.trim();
    
    if (!email) {
        showStatus("이메일을 입력해주세요", "warning");
        return;
    }
    
    showStatus("재설정 링크 발송 중...", "info");
    
    try {
        const response = await fetch(AUTH_API_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                action: 'forgot-password',
                email: email
            })
        });
        
        const result = await response.json();
        
        if (result.success) {
            showStatus("📧 재설정 링크가 이메일로 발송되었습니다", "success");
            showLoginForm();
        } else {
            showStatus(`발송 실패: ${result.error}`, "error");
        }
        
    } catch (error) {
        console.error('[Auth] 비밀번호 재설정 오류:', error);
        showStatus("재설정 링크 발송 중 오류가 발생했습니다", "error");
    }
}

// 🔐 인증 데이터 삭제
function clearAuthData() {
    currentUser = null;
    authToken = null;
    localStorage.removeItem('authToken');
    localStorage.removeItem('currentUser');
}

// 🔐 인증 UI 업데이트 (완전 개선)
function updateAuthUI(isLoggedIn) {
    const loginToggle = document.getElementById('loginToggle');
    
    if (isLoggedIn && currentUser) {
        // 🔧 로그인 상태 UI
        loginToggle.classList.add('logged-in');
        loginToggle.title = `${currentUser.displayName || currentUser.email} - API 키 관리`;
        loginToggle.innerHTML = '👤✓';
        
        // 🔧 프리미엄 기능 표시
        updatePremiumFeatures(true);
        
        // 🔧 대시보드 데이터 표시
        updateDashboardAccess(true);
        
        // 🔧 설정 패널 고급 기능 표시
        updateAdvancedSettings(true);
        
        console.log('[UI] 로그인 상태 UI 적용:', currentUser.email);
        
    } else {
        // 🔧 게스트 상태 UI
        loginToggle.classList.remove('logged-in');
        loginToggle.title = '로그인/회원가입';
        loginToggle.innerHTML = '👤';
        
        // 🔧 기능 제한 적용
        updatePremiumFeatures(false);
        updateDashboardAccess(false);
        updateAdvancedSettings(false);
        
        console.log('[UI] 게스트 상태 UI 적용');
    }
    
    // 🔧 번역/TTS 버튼 상태 업데이트
    updateTranslationButtonStates();
}

// 🔧 프리미엄 기능 UI 업데이트
function updatePremiumFeatures(hasAccess) {
    // AI 번역 토글 버튼
    const aiToggle = document.getElementById('aiToggle');
    if (aiToggle) {
        if (hasAccess) {
            aiToggle.style.opacity = '1';
            aiToggle.style.pointerEvents = 'auto';
            aiToggle.title = 'AI 문맥 번역 (프리미엄)';
        } else {
            if (aiContextMode) {
                toggleAIMode(); // AI 모드 비활성화
            }
            aiToggle.style.opacity = '0.5';
            aiToggle.style.pointerEvents = 'auto'; // 클릭은 가능하게 (경고 표시용)
            aiToggle.title = 'AI 문맥 번역 (로그인 필요)';
        }
    }
    
    // 고급 단어장 토글 버튼
    const vocabToggle = document.getElementById('vocabToggle');
    if (vocabToggle) {
        if (hasAccess) {
            vocabToggle.style.opacity = '1';
            vocabToggle.style.pointerEvents = 'auto';
            vocabToggle.title = '고급 단어장 (프리미엄)';
        } else {
            vocabToggle.style.opacity = '0.5';
            vocabToggle.style.pointerEvents = 'auto';
            vocabToggle.title = '고급 단어장 (로그인 필요)';
        }
    }
    
    // 설정 패널의 AI 섹션
    const aiSettingsSection = document.getElementById('aiSettingsSection');
    if (aiSettingsSection) {
        if (!hasAccess) {
            aiSettingsSection.style.opacity = '0.5';
            // 비활성화 오버레이 추가
            if (!aiSettingsSection.querySelector('.premium-overlay')) {
                const overlay = document.createElement('div');
                overlay.className = 'premium-overlay';
                overlay.style.cssText = `
                    position: absolute; top: 0; left: 0; right: 0; bottom: 0;
                    background: rgba(0,0,0,0.1); z-index: 10; cursor: pointer;
                    display: flex; align-items: center; justify-content: center;
                    font-size: 12px; color: var(--primary); font-weight: bold;
                `;
                overlay.innerHTML = '🔒 로그인 필요';
                overlay.onclick = () => showPremiumAlert('AI 문맥 번역 설정');
                aiSettingsSection.style.position = 'relative';
                aiSettingsSection.appendChild(overlay);
            }
        } else {
            aiSettingsSection.style.opacity = '1';
            const overlay = aiSettingsSection.querySelector('.premium-overlay');
            if (overlay) overlay.remove();
        }
    }
}

// 🔧 대시보드 접근 제어
function updateDashboardAccess(hasAccess) {
    // 대시보드 버튼 상태는 항상 활성화 (게스트도 로컬 데이터 볼 수 있음)
    // 하지만 내용이 다르게 표시됨
}

// 🔧 고급 설정 표시/숨김
function updateAdvancedSettings(hasAccess) {
    // 현재는 모든 설정이 게스트도 사용 가능하므로 특별한 제한 없음
    // 추후 프리미엄 전용 설정 추가 시 여기서 제어
}

// 🔧 번역/TTS 버튼 상태 업데이트
function updateTranslationButtonStates() {
    const translateBtn = document.getElementById('translateBtn');
    const speakBtn = document.getElementById('speakBtn');
    
    if (!currentUser) {
        // 게스트 모드 표시
        if (translateBtn) {
            const originalText = translateBtn.textContent;
            if (!originalText.includes('(게스트)')) {
                translateBtn.innerHTML = translateBtn.innerHTML.replace('번역하기', '번역하기 (게스트)');
            }
        }
    } else {
        // 로그인 모드 표시
        if (translateBtn) {
            translateBtn.innerHTML = translateBtn.innerHTML.replace(' (게스트)', '');
        }
    }
}

// 🔧 프리미엄 기능 접근 시 알림
function showPremiumAlert(featureName) {
    if (currentUser) {
        showStatus(`${featureName} 기능은 이미 사용 가능합니다`, "info");
        return;
    }
    
    // 중복 팝업 방지를 위한 플래그 체크
    if (window.alertShowing) {
        console.log('[Debug] 이미 팝업이 표시 중입니다');
        return;
    }
    
    window.alertShowing = true;
    
    const shouldLogin = confirm(
        `🔒 ${featureName} 기능은 로그인 후 이용 가능합니다.\n\n` +
        `• 무제한 번역 및 TTS\n` +
        `• 개인 API 키 등록\n` +
        `• 사용량 추적 및 분석\n` +
        `• 고급 단어장 및 학습 기록\n\n` +
        `지금 로그인하시겠습니까?`
    );
    
    window.alertShowing = false;
    
    if (shouldLogin) {
        // 직접 모달 열기 (toggleAuth 대신)
        const authModal = document.getElementById('authModal');
        if (authModal) {
            authModal.classList.add('active');
            console.log('[Debug] 로그인 모달 열기');
        } else {
            console.error('[Debug] authModal을 찾을 수 없습니다');
        }
    }
}

// 🔧 AI 모드 토글 시 권한 체크
function toggleAIModeWithAuth() {
    if (!currentUser) {
        showPremiumAlert('AI 문맥 번역');
        return;
    }
    
    toggleAIMode();
}

// 🔧 단어장 토글 시 권한 체크  
function toggleVocabularyWithAuth() {
    if (!currentUser) {
        showPremiumAlert('고급 단어장');
        return;
    }
    
    toggleVocabulary();
}

// 🔑 API 키 관리 시스템 (개선)
async function loadUserApiKeys() {
    if (!currentUser || !authToken) {
        console.log('[API Keys] 사용자 미인증');
        // 비인증 상태 UI 표시
        updateApiKeyStatus('openai', 'error', '❌ 로그인이 필요합니다');
        updateApiKeyStatus('google', 'error', '❌ 로그인이 필요합니다');
        return;
    }
    
    console.log('[API Keys] 사용자 API 키 로드 시작');
    
    // 로딩 상태 표시
    updateApiKeyStatus('openai', 'info', '🔄 API 키 정보 로드 중...');
    updateApiKeyStatus('google', 'info', '🔄 API 키 정보 로드 중...');
    
    try {
        const response = await fetch(AUTH_API_URL, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({
                action: 'get-api-keys'
            })
        });
        
        if (!response.ok) {
            throw new Error(`API 요청 실패: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (result.success) {
            console.log('[API Keys] 키 정보 로드 성공:', result);
            
            // 🔧 OpenAI 키 상태 업데이트
            if (result.openaiKey) {
                document.getElementById('openaiApiKey').value = '••••••••••••••••••••';
                document.getElementById('openaiApiKey').placeholder = 'API 키가 등록되어 있습니다';
                updateApiKeyStatus('openai', 'success', '✅ OpenAI API 키가 등록되어 있습니다');
                
                // 글로벌 상태 업데이트
                if (currentUser) currentUser.hasOpenAIKey = true;
            } else {
                document.getElementById('openaiApiKey').value = '';
                document.getElementById('openaiApiKey').placeholder = 'sk-...';
                updateApiKeyStatus('openai', 'error', '❌ OpenAI API 키가 등록되지 않았습니다');
                
                if (currentUser) currentUser.hasOpenAIKey = false;
            }
            
            // 🔧 Google 키 상태 업데이트
            if (result.googleKey) {
                document.getElementById('googleApiKey').value = '••••••••••••••••••••';
                document.getElementById('googleApiKey').placeholder = 'API 키가 등록되어 있습니다';
                updateApiKeyStatus('google', 'success', '✅ Google API 키가 등록되어 있습니다');
                
                if (currentUser) currentUser.hasGoogleKey = true;
            } else {
                document.getElementById('googleApiKey').value = '';
                document.getElementById('googleApiKey').placeholder = 'AIza...';
                updateApiKeyStatus('google', 'error', '❌ Google API 키가 등록되지 않았습니다');
                
                if (currentUser) currentUser.hasGoogleKey = false;
            }
            
            // 🔧 사용자 정보 업데이트 및 저장
            if (currentUser) {
                localStorage.setItem('currentUser', JSON.stringify(currentUser));
            }
            
        } else {
            console.error('[API Keys] 로드 실패:', result.error);
            updateApiKeyStatus('openai', 'error', `❌ 로드 실패: ${result.error}`);
            updateApiKeyStatus('google', 'error', `❌ 로드 실패: ${result.error}`);
        }
        
    } catch (error) {
        console.error('[API Keys] 로드 오류:', error);
        updateApiKeyStatus('openai', 'error', '❌ 로드 중 오류 발생');
        updateApiKeyStatus('google', 'error', '❌ 로드 중 오류 발생');
    }
}

// 🔑 OpenAI API 키 저장 (개선)
async function saveOpenAIKey() {
    const apiKey = document.getElementById('openaiApiKey').value.trim();
    
    if (!currentUser || !authToken) {
        showStatus("로그인이 필요합니다", "warning");
        updateApiKeyStatus('openai', 'error', '❌ 로그인이 필요합니다');
        return;
    }
    
    if (!apiKey || apiKey === '••••••••••••••••••••') {
        showStatus("유효한 OpenAI API 키를 입력해주세요", "warning");
        updateApiKeyStatus('openai', 'error', '❌ API 키를 입력해주세요');
        return;
    }
    
    if (!apiKey.startsWith('sk-')) {
        showStatus("OpenAI API 키는 'sk-'로 시작해야 합니다", "warning");
        updateApiKeyStatus('openai', 'error', '❌ 올바른 형식이 아닙니다');
        return;
    }
    
    if (apiKey.length < 20) {
        showStatus("API 키가 너무 짧습니다", "warning");
        updateApiKeyStatus('openai', 'error', '❌ API 키가 너무 짧습니다');
        return;
    }
    
    updateApiKeyStatus('openai', 'info', '🔄 API 키 저장 중...');
    
    try {
        const response = await fetch(AUTH_API_URL, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({
                action: 'save-api-key',
                provider: 'openai',
                apiKey: apiKey,
                keyName: 'OpenAI API Key'
            })
        });
        
        if (!response.ok) {
            throw new Error(`API 요청 실패: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (result.success) {
            console.log('[API Keys] OpenAI 키 저장 성공');
            
            // UI 업데이트
            document.getElementById('openaiApiKey').value = '••••••••••••••••••••';
            document.getElementById('openaiApiKey').placeholder = 'API 키가 등록되어 있습니다';
            updateApiKeyStatus('openai', 'success', '✅ OpenAI API 키가 저장되었습니다');
            showStatus("🔑 OpenAI API 키 저장 완료", "success");
            
            // 🔧 사용자 상태 업데이트
            if (currentUser) {
                currentUser.hasOpenAIKey = true;
                localStorage.setItem('currentUser', JSON.stringify(currentUser));
            }
            
        } else {
            console.error('[API Keys] OpenAI 키 저장 실패:', result.error);
            updateApiKeyStatus('openai', 'error', `❌ 저장 실패: ${result.error}`);
            showStatus(`API 키 저장 실패: ${result.error}`, "error");
        }
        
    } catch (error) {
        console.error('[API Keys] OpenAI 키 저장 오류:', error);
        updateApiKeyStatus('openai', 'error', '❌ 저장 중 오류 발생');
        showStatus("API 키 저장 중 오류가 발생했습니다", "error");
    }
}

// 🔑 Google API 키 저장 (개선)
async function saveGoogleKey() {
    const apiKey = document.getElementById('googleApiKey').value.trim();
    
    if (!currentUser || !authToken) {
        showStatus("로그인이 필요합니다", "warning");
        updateApiKeyStatus('google', 'error', '❌ 로그인이 필요합니다');
        return;
    }
    
    if (!apiKey || apiKey === '••••••••••••••••••••') {
        showStatus("유효한 Google API 키를 입력해주세요", "warning");
        updateApiKeyStatus('google', 'error', '❌ API 키를 입력해주세요');
        return;
    }
    
    if (!apiKey.startsWith('AIza')) {
        showStatus("Google API 키는 'AIza'로 시작해야 합니다", "warning");
        updateApiKeyStatus('google', 'error', '❌ 올바른 형식이 아닙니다');
        return;
    }
    
    if (apiKey.length < 20) {
        showStatus("API 키가 너무 짧습니다", "warning");
        updateApiKeyStatus('google', 'error', '❌ API 키가 너무 짧습니다');
        return;
    }
    
    updateApiKeyStatus('google', 'info', '🔄 API 키 저장 중...');
    
    try {
        const response = await fetch(AUTH_API_URL, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${authToken}`
            },
            body: JSON.stringify({
                action: 'save-api-key',
                provider: 'google',
                apiKey: apiKey,
                keyName: 'Google API Key'
            })
        });
        
        if (!response.ok) {
            throw new Error(`API 요청 실패: ${response.status}`);
        }
        
        const result = await response.json();
        
        if (result.success) {
            console.log('[API Keys] Google 키 저장 성공');
            
            // UI 업데이트
            document.getElementById('googleApiKey').value = '••••••••••••••••••••';
            document.getElementById('googleApiKey').placeholder = 'API 키가 등록되어 있습니다';
            updateApiKeyStatus('google', 'success', '✅ Google API 키가 저장되었습니다');
            showStatus("🔑 Google API 키 저장 완료", "success");
            
            // 🔧 사용자 상태 업데이트
            if (currentUser) {
                currentUser.hasGoogleKey = true;
                localStorage.setItem('currentUser', JSON.stringify(currentUser));
            }
            
        } else {
            console.error('[API Keys] Google 키 저장 실패:', result.error);
            updateApiKeyStatus('google', 'error', `❌ 저장 실패: ${result.error}`);
            showStatus(`API 키 저장 실패: ${result.error}`, "error");
        }
        
    } catch (error) {
        console.error('[API Keys] Google 키 저장 오류:', error);
        updateApiKeyStatus('google', 'error', '❌ 저장 중 오류 발생');
        showStatus("API 키 저장 중 오류가 발생했습니다", "error");
    }
}

// 🔑 OpenAI API 키 테스트
async function testOpenAIKey() {
    const apiKey = document.getElementById('openaiApiKey').value.trim();
    
    if (!apiKey || apiKey === '••••••••••••••••••••') {
        showStatus("테스트할 API 키를 입력해주세요", "warning");
        return;
    }
    
    updateApiKeyStatus('openai', 'info', '🔄 API 키 테스트 중...');
    
    try {
        // OpenAI API 간단한 테스트 요청
        const response = await fetch('https://api.openai.com/v1/models', {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${apiKey}`,
                'Content-Type': 'application/json'
            }
        });
        
        if (response.ok) {
            updateApiKeyStatus('openai', 'success', '✅ OpenAI API 키가 유효합니다');
            showStatus("🔑 OpenAI API 키 테스트 성공", "success");
        } else {
            const errorText = await response.text();
            updateApiKeyStatus('openai', 'error', `❌ 유효하지 않은 API 키: ${response.status}`);
            showStatus(`API 키 테스트 실패: ${response.status}`, "error");
        }
        
    } catch (error) {
        console.error('[API Keys] OpenAI 키 테스트 오류:', error);
        updateApiKeyStatus('openai', 'error', '❌ 테스트 중 오류 발생');
        showStatus("API 키 테스트 중 오류가 발생했습니다", "error");
    }
}

// 🔑 Google API 키 테스트
async function testGoogleKey() {
    const apiKey = document.getElementById('googleApiKey').value.trim();
    
    if (!apiKey || apiKey === '••••••••••••••••••••') {
        showStatus("테스트할 API 키를 입력해주세요", "warning");
        return;
    }
    
    updateApiKeyStatus('google', 'info', '🔄 API 키 테스트 중...');
    
    try {
        // Google TTS API 간단한 테스트 요청 (목소리 리스트 조회)
        const response = await fetch(`https://texttospeech.googleapis.com/v1/voices?key=${apiKey}`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json'
            }
        });
        
        if (response.ok) {
            updateApiKeyStatus('google', 'success', '✅ Google API 키가 유효합니다');
            showStatus("🔑 Google API 키 테스트 성공", "success");
        } else {
            const errorText = await response.text();
            updateApiKeyStatus('google', 'error', `❌ 유효하지 않은 API 키: ${response.status}`);
            showStatus(`API 키 테스트 실패: ${response.status}`, "error");
        }
        
    } catch (error) {
        console.error('[API Keys] Google 키 테스트 오류:', error);
        updateApiKeyStatus('google', 'error', '❌ 테스트 중 오류 발생');
        showStatus("API 키 테스트 중 오류가 발생했습니다", "error");
    }
}

// 🔑 API 키 상태 업데이트
function updateApiKeyStatus(provider, status, message) {
    const statusEl = document.getElementById(`${provider}KeyStatus`);
    if (!statusEl) return;
    
    statusEl.className = `api-key-status ${status}`;
    statusEl.textContent = message;
    statusEl.style.display = 'block';
}

// 🔑 인증된 API 요청에 토큰 추가
function getAuthHeaders() {
    const headers = {
        'Content-Type': 'application/json'
    };
    
    if (authToken) {
        headers['Authorization'] = `Bearer ${authToken}`;
    }
    
    return headers;
}

// 🔑 API 키 입력 필드 이벤트 처리
function setupApiKeyEvents() {
    // OpenAI 키 입력 시 상태 초기화
    const openaiInput = document.getElementById('openaiApiKey');
    if (openaiInput) {
        openaiInput.addEventListener('input', function() {
            if (this.value && this.value !== '••••••••••••••••••••') {
                updateApiKeyStatus('openai', '', '');
            }
        });
        
        // 엔터키로 저장
        openaiInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                saveOpenAIKey();
            }
        });
    }
    
    // Google 키 입력 시 상태 초기화
    const googleInput = document.getElementById('googleApiKey');
    if (googleInput) {
        googleInput.addEventListener('input', function() {
            if (this.value && this.value !== '••••••••••••••••••••') {
                updateApiKeyStatus('google', '', '');
            }
        });
        
        // 엔터키로 저장
        googleInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                saveGoogleKey();
            }
        });
    }
}

// AI 문맥 번역 설정
let aiContextMode = false;
let translationContext = [];
let currentTranslationStyle = 'balanced';
let qualityLevel = 3;

// 고급 단어장 시스템 - 초기화
let vocabularyDict = new Map();
let terminologyDict = new Map(); // 전문용어 사전 추가
let currentVocabWord = null;
let quizState = {
    active: false,
    words: [],
    currentIndex: 0,
    correctAnswers: 0,
    wrongAnswers: 0,
    totalQuestions: 10,
    selectedAnswer: null
}; // 🔧 수정: 닫는 괄호 추가

let practiceState = {
    active: false,
    currentWord: null,
    isRecording: false,
    practiceTime: 0,
    lastRecording: null,
    recordingStartTime: null
}; // 🔧 수정: 정의를 먼저 하고

let vocabularyStats = {
    totalWords: 0,
    quizAccuracy: 0,
    practiceTime: 0,
    learningProgress: 0
}; // 🔧 수정: 닫는 괄호 추가

// 🔧 강제 비활성화 (정의 후에 실행)
practiceState.active = false;
quizState.active = false;

// DOM 요소들
// DOM 요소 캐싱 (성능 최적화)
const els = {
    // 입력 및 결과 요소
    inputText: document.getElementById("inputText"),
    translation: document.getElementById("translation"),
    pronunciationContent: document.getElementById("pronunciation-content"),
    pronunciationSection: document.getElementById("pronunciationSection"),
    pronToggleIcon: document.getElementById("pronToggleIcon"),
    status: document.getElementById("status"),
    
    // 버튼 요소
    voiceBtn: document.getElementById("voiceBtn"),
    speakBtn: document.getElementById("speakBtn"),
    copyBtn: document.getElementById("copyBtn"),
    translateBtn: document.getElementById("translateBtn"),
    translateBtnText: document.getElementById("translateBtnText"),
    
    // 언어 선택
    sourceLangSelect: document.getElementById("sourceLangSelect"),
    targetLangSelect: document.getElementById("targetLangSelect"),
    voiceSelect: document.getElementById("voiceSelect"),
    googleVoiceSelect: document.getElementById("googleVoiceSelect"),
    autoDetectBadge: document.getElementById("autoDetectBadge"),
    
    // 패널 및 모드
    settingsPanel: document.getElementById("settingsPanel"),
    normalMode: document.getElementById("normalMode"),
    conversationMode: document.getElementById("conversationMode"),
    normalModeBtn: document.getElementById("normalModeBtn"),
    conversationModeBtn: document.getElementById("conversationModeBtn"),
    
    // 대화 모드 관련
    speakerCardA: document.getElementById("speakerCardA"),
    speakerCardB: document.getElementById("speakerCardB"),
    speakerLangA: document.getElementById("speakerLangA"),
    speakerLangB: document.getElementById("speakerLangB"),
    startConversationBtn: document.getElementById("startConversationBtn"),
    stopConversationBtn: document.getElementById("stopConversationBtn"),
    conversationHistory: document.getElementById("conversationHistory"),
    
    // TTS 및 재생
    ttsEngineMode: document.getElementById("ttsEngineMode"),
    cacheIndicator: document.getElementById("cacheIndicator"),
    engineIndicator: document.getElementById("engineIndicator"),
    recentPlays: document.getElementById("recentPlays"),
    recentPlayList: document.getElementById("recentPlayList"),
    
    // 모달
    dashboardModal: document.getElementById("dashboardModal"),
    historyModal: document.getElementById("historyModal"),
    historyList: document.getElementById("historyList"),
    
    // 대시보드
    todayTranslations: document.getElementById("todayTranslations"),
    totalTranslations: document.getElementById("totalTranslations"),
    cacheHitRate: document.getElementById("cacheHitRate"),
    
    // 설정
    autoModeSettings: document.getElementById("autoModeSettings"),
    autoThreshold: document.getElementById("autoThreshold"),
    thresholdValue: document.getElementById("thresholdValue"),
    volumeControl: document.getElementById("volumeControl"),
    volumeValue: document.getElementById("volumeValue"),
    pronunciationToggle: document.getElementById("pronunciationToggle"),
    
    // AI 기능
    aiToggle: document.getElementById("aiToggle"),
    aiContextBadge: document.getElementById("aiContextBadge"),
    aiIndicator: document.getElementById("aiIndicator"),
    qualitySlider: document.getElementById("qualitySlider"),
    aiSettingsSection: document.getElementById("aiSettingsSection"),
    
    // 단어장
    vocabularyOriginal: document.getElementById("vocabularyOriginal"),
    vocabularyTranslation: document.getElementById("vocabularyTranslation"),
    vocabularyDescription: document.getElementById("vocabularyDescription"),
    vocabularyList: document.getElementById("vocabularyList"),
    vocabularyStats: document.getElementById("vocabularyStats"),
    wordDetailModal: document.getElementById("wordDetailModal"),
    quizModal: document.getElementById("quizModal"),
    practiceModal: document.getElementById("practiceModal")
};

// 📊 개선: 실제 API 연동 사용량 추적기
const usageTracker = {
    // 로컬 캐시 (성능 최적화용)
    localCache: {
        daily: {},
        monthly: {},
        lastRefresh: null
    },
    
    costs: {
        translation: 0.000015,
        openaiTTS: 0.000015,
        googleTTS: 0
    },
    
    // 🔧 초기화 - 실제 API에서 데이터 로드
    async initialize() {
        console.log('[UsageTracker] 초기화 시작');
        
        if (authToken) {
            await this.refreshFromAPI();
        } else {
            // 게스트 모드: 로컬 데이터 로드
            this.loadLocalData();
        }
        
        this.updateDisplay();
    },
    
    // 🔧 API에서 데이터 새로고침
    async refreshFromAPI() {
        if (!authToken) {
            console.log('[UsageTracker] 인증 토큰 없음 - 로컬 모드');
            return;
        }
        
        try {
            console.log('[UsageTracker] API에서 사용량 데이터 로드 중...');
            
            const response = await fetch(AUTH_API_URL, {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${authToken}`
                },
                body: JSON.stringify({
                    action: 'get-dashboard-data'
                })
            });
            
            if (response.ok) {
                const result = await response.json();
                if (result.success) {
                    this.updateLocalCacheFromAPI(result.dashboard);
                    console.log('[UsageTracker] API 데이터 로드 완료');
                }
            }
            
        } catch (error) {
            console.error('[UsageTracker] API 데이터 로드 실패:', error);
            // 실패 시 로컬 데이터 사용
            this.loadLocalData();
        }
        
        this.localCache.lastRefresh = Date.now();
    },
    
    // 🔧 API 데이터로 로컬 캐시 업데이트
    updateLocalCacheFromAPI(dashboardData) {
        const today = new Date().toISOString().split('T')[0];
        const thisMonth = today.substring(0, 7);
        
        // 오늘 데이터
        this.localCache.daily[today] = {
            translations: dashboardData.usage.today.translations || 0,
            characters: dashboardData.usage.today.translations * 50, // 평균 추정
            cost: dashboardData.usage.today.cost || 0,
            saved: 0
        };
        
        // 이번 달 데이터
        this.localCache.monthly[thisMonth] = {
            translations: dashboardData.usage.thisMonth.translations || 0,
            characters: dashboardData.usage.thisMonth.translations * 50,
            cost: dashboardData.usage.thisMonth.cost || 0,
            saved: 0
        };
        
        // 주간 데이터 (차트용)
        this.localCache.weekly = dashboardData.usage.weekly || [];
        
        // 월별 데이터 (차트용)
        this.localCache.monthlyChart = dashboardData.monthlyData || [];
    },
    
    // 🔧 로컬 데이터 로드 (게스트 모드)
    loadLocalData() {
        try {
            const saved = localStorage.getItem('usageData');
            if (saved) {
                const data = JSON.parse(saved);
                this.localCache.daily = data.daily || {};
                this.localCache.monthly = data.monthly || {};
            }
        } catch (error) {
            console.error('[UsageTracker] 로컬 데이터 로드 실패:', error);
        }
    },
    
    // 🔧 사용량 추적 - API 전송 + 로컬 업데이트
    async track(type, count, provider = 'openai') {
        const today = new Date().toISOString().split('T')[0];
        const thisMonth = today.substring(0, 7);
        
        // 로컬 캐시 업데이트
        if (!this.localCache.daily[today]) {
            this.localCache.daily[today] = { translations: 0, characters: 0, cost: 0, saved: 0 };
        }
        if (!this.localCache.monthly[thisMonth]) {
            this.localCache.monthly[thisMonth] = { translations: 0, characters: 0, cost: 0, saved: 0 };
        }
        
        const dailyData = this.localCache.daily[today];
        const monthlyData = this.localCache.monthly[thisMonth];
        
        if (type === 'translation') {
            dailyData.translations++;
            monthlyData.translations++;
            dailyData.characters += count;
            monthlyData.characters += count;
            const cost = count * this.costs.translation;
            dailyData.cost += cost;
            monthlyData.cost += cost;
        } else if (type === 'tts') {
            const cost = provider === 'openai' ? count * this.costs.openaiTTS : 0;
            const saved = provider === 'google' ? count * this.costs.openaiTTS : 0;
            
            dailyData.cost += cost;
            monthlyData.cost += cost;
            dailyData.saved += saved;
            monthlyData.saved += saved;
        }
        
        // 로컬 저장 (게스트 모드용)
        this.saveLocalData();
        
        // UI 업데이트
        this.updateDisplay();
        this.checkLimits();
        
        // 🔧 API에 사용량 전송 (인증된 사용자만)
        if (authToken && currentUser) {
            try {
                // 실제 trackUsage는 translate.js에서 호출되므로 여기서는 로그만
                console.log(`[UsageTracker] ${type} 사용량 추적: ${count} (${provider})`);
            } catch (error) {
                console.error('[UsageTracker] API 전송 실패:', error);
            }
        }
    },
    
    // 로컬 데이터 저장
    saveLocalData() {
        try {
            const data = {
                daily: this.localCache.daily,
                monthly: this.localCache.monthly,
                lastSaved: new Date().toISOString()
            };
            localStorage.setItem('usageData', JSON.stringify(data));
        } catch (error) {
            console.error('[UsageTracker] 로컬 데이터 저장 실패:', error);
        }
    },
    
    // 🔧 개선: 실제 데이터로 디스플레이 업데이트
    updateDisplay() {
        const today = new Date().toISOString().split('T')[0];
        const thisMonth = today.substring(0, 7);
        
        const todayData = this.localCache.daily[today] || { translations: 0, cost: 0, saved: 0 };
        const monthData = this.localCache.monthly[thisMonth] || { translations: 0, cost: 0, saved: 0 };
        
        // 대시보드 카드 업데이트
        const todayUsageEl = document.getElementById('todayUsage');
        const monthUsageEl = document.getElementById('monthUsage');
        const todayCostEl = document.getElementById('todayCost');
        const monthCostEl = document.getElementById('monthCost');
        const savedCostEl = document.getElementById('savedCost');
        
        if (todayUsageEl) todayUsageEl.textContent = todayData.translations;
        if (monthUsageEl) monthUsageEl.textContent = monthData.translations;
        if (todayCostEl) todayCostEl.textContent = `$${todayData.cost.toFixed(4)}`;
        if (monthCostEl) monthCostEl.textContent = `$${monthData.cost.toFixed(4)}`;
        if (savedCostEl) savedCostEl.textContent = `$${monthData.saved.toFixed(4)}`;
        
        this.updateChart();
        this.updateMonthlyChart();
        this.updateBudgetProgress();
    },
    
    // 🔧 주간 차트 업데이트 (실제 데이터)
    updateChart() {
        const chartEl = document.getElementById('weeklyChart');
        if (!chartEl) return;
        
        // 실제 API 데이터가 있으면 사용, 없으면 로컬 데이터
        const weeklyData = this.localCache.weekly || this.generateLocalWeeklyData();
        
        if (weeklyData.length === 0) return;
        
        const maxCount = Math.max(...weeklyData.map(d => d.translation_count || 0), 1);
        
        chartEl.innerHTML = weeklyData.map(dayData => {
            const count = dayData.translation_count || 0;
            const height = (count / maxCount) * 100;
            const date = new Date(dayData.date);
            const dayLabel = date.toLocaleDateString('ko-KR', { weekday: 'short' });
            
            return `<div class="bar" style="height: ${height}%">
                <span class="bar-value">${count}</span>
                <span class="bar-label">${dayLabel}</span>
            </div>`;
        }).join('');
    },
    
    // 로컬 데이터로 주간 차트 생성
    generateLocalWeeklyData() {
        const weekData = [];
        for (let i = 6; i >= 0; i--) {
            const date = new Date();
            date.setDate(date.getDate() - i);
            const dateStr = date.toISOString().split('T')[0];
            const dayData = this.localCache.daily[dateStr] || { translations: 0 };
            
            weekData.push({
                date: dateStr,
                translation_count: dayData.translations
            });
        }
        return weekData;
    },
    
    // 🔧 월별 차트 업데이트 (실제 데이터)
    updateMonthlyChart() {
        const chartEl = document.getElementById('monthlyChart');
        if (!chartEl) return;
        
        // 실제 API 데이터가 있으면 사용, 없으면 로컬 데이터
        const monthlyData = this.localCache.monthlyChart || this.generateLocalMonthlyData();
        
        if (monthlyData.length === 0) return;
        
        const maxCost = Math.max(...monthlyData.map(m => m.cost || 0), 0.01);
        
        chartEl.innerHTML = monthlyData.map(monthData => {
            const cost = monthData.cost || 0;
            const height = maxCost > 0 ? (cost / maxCost * 100) : 0;
            const monthLabel = monthData.monthLabel || 
                new Date(monthData.month + '-01').toLocaleDateString('ko-KR', { month: 'short' });
            
            return `<div class="bar" style="height: ${height}%; background: linear-gradient(135deg, #10A37F, #059669);">
                <span class="bar-value">${cost.toFixed(3)}</span>
                <span class="bar-label">${monthLabel}</span>
            </div>`;
        }).join('');
    },
    
    // 로컬 데이터로 월별 차트 생성
    generateLocalMonthlyData() {
        const monthData = [];
        const currentDate = new Date();
        
        for (let i = 5; i >= 0; i--) {
            const date = new Date(currentDate.getFullYear(), currentDate.getMonth() - i, 1);
            const monthStr = date.toISOString().substring(0, 7);
            const data = this.localCache.monthly[monthStr] || { cost: 0 };
            
            monthData.push({
                month: monthStr,
                cost: data.cost,
                monthLabel: date.toLocaleDateString('ko-KR', { month: 'short' })
            });
        }
        return monthData;
    },
    
    updateBudgetProgress() {
        const today = new Date().toISOString().split('T')[0];
        const todayCost = this.localCache.daily[today]?.cost || 0;
        const dailyBudget = parseFloat(document.getElementById('dailyBudget')?.value) || 1.00;
        const percentage = Math.min((todayCost / dailyBudget) * 100, 100);
        
        const progressEl = document.getElementById('budgetProgress');
        const percentageEl = document.getElementById('budgetPercentage');
        
        if (progressEl) progressEl.style.width = `${percentage}%`;
        if (percentageEl) percentageEl.textContent = `${percentage.toFixed(1)}% 사용`;
        
        this.checkLimits();
    },
    
    checkLimits() {
        const today = new Date().toISOString().split('T')[0];
        const todayCost = this.localCache.daily[today]?.cost || 0;
        const dailyBudget = parseFloat(document.getElementById('dailyBudget')?.value) || 1.00;
        
        if (todayCost >= dailyBudget) {
            const limitAction = document.getElementById('limitAction')?.value;
            if (limitAction === 'switch') {
                els.ttsEngineMode.value = 'google';
                showStatus("⚠️ 예산 도달 - Google TTS로 전환", "warning");
            } else if (limitAction === 'warn') {
                showStatus("⚠️ 일일 예산을 초과했습니다", "warning");
            } else if (limitAction === 'block') {
                window.budgetExceeded = true;
                showStatus("⛔ 예산 초과 - 유료 기능 제한", "error");
            }
        } else {
            window.budgetExceeded = false;
        }
    }
};

// 캐시 관리자
const cacheManager={translation:new Map,tts:new Map,recentPlays:[],stats:{hits:0,misses:0},getTranslation(e){const t=this.translation.get(e);return t&&Date.now()-t.ts<36e5?(this.stats.hits++,t.data):(this.stats.misses++,null)},setTranslation(e,t){this.translation.set(e,{ts:Date.now(),data:t}),this.translation.size>100&&this.translation.delete(this.translation.keys().next().value)},getTTS(e){const t=this.tts.get(e);return t&&Date.now()-t.ts<72e5?t.blob:null},setTTS(e,t){this.tts.set(e,{ts:Date.now(),blob:t}),this.tts.size>50&&this.tts.delete(this.tts.keys().next().value)},addRecentPlay(e,t,s,a){this.recentPlays.unshift({text:e,translation:t,lang:s,engine:a}),this.recentPlays.length>10&&this.recentPlays.pop(),this.save(),updateRecentPlays()},save(){localStorage.setItem("cacheData",JSON.stringify({recentPlays:this.recentPlays,stats:this.stats}))},load(){const e=localStorage.getItem("cacheData");if(e){const{recentPlays:t,stats:a}=JSON.parse(e);this.recentPlays=t||[],this.stats=a||{hits:0,misses:0}}},clear(){this.translation.clear(),this.tts.clear(),this.recentPlays=[],this.stats={hits:0,misses:0},this.save()}};

let currentTranslation="",currentSource="",recognition=null,isRecording=!1,isPronunciationEnabled=!0;
// ✅ 단어장 전용 음성인식 객체 (충돌 방지)
let practiceRecognition=null;
const conversationState={isActive:!1,currentSpeaker:"A",messages:[],autoRecognition:!1},langCodeMap={Korean:"ko-KR",Vietnamese:"vi-VN",English:"en-US"};
let audioContext=null;const audioQueue=[];let isQueuePlaying=!1;

// ✅ 전문용어 관리 함수들 (간소화된 UI)
function addTerminology() {
    const input = document.getElementById('terminologyInput').value.trim();
    
    if (!input) {
        showStatus("용어를 입력해주세요 (예: AI | 인공지능)", "warning");
        return;
    }
    
    // 파이프(|)로 분리
    const parts = input.split('|').map(part => part.trim());
    
    if (parts.length !== 2) {
        showStatus("올바른 형식으로 입력하세요: 원어 | 번역어", "warning");
        return;
    }
    
    const [original, translation] = parts;
    
    if (!original || !translation) {
        showStatus("원어와 번역어를 모두 입력해주세요", "warning");
        return;
    }
    
    if (terminologyDict.has(original)) {
        showStatus("이미 등록된 용어입니다", "warning");
        return;
    }
    
    terminologyDict.set(original, translation);
    
    // 입력 필드 초기화
    document.getElementById('terminologyInput').value = '';
    
    updateTerminologyList();
    saveAISettings();
    showStatus(`🔧 용어 추가: ${original} → ${translation}`, "success");
}

function removeTerminology(original) {
    if (confirm(`"${original}" 용어를 삭제하시겠습니까?`)) {
        terminologyDict.delete(original);
        updateTerminologyList();
        saveAISettings();
        showStatus(`🗑️ 용어 삭제: ${original}`, "success");
    }
}

function updateTerminologyList() {
    const terminologyListEl = document.getElementById('terminologyList');
    if (!terminologyListEl) return;
    
    if (terminologyDict.size === 0) {
        terminologyListEl.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 10px; font-size: 12px;">등록된 전문용어가 없습니다</div>';
        return;
    }
    
    terminologyListEl.innerHTML = Array.from(terminologyDict.entries()).map(([original, translation]) => 
        `<div class="terminology-item">
            <div class="terminology-text">
                <span class="terminology-original">${original}</span>
                <span class="terminology-arrow">→</span>
                <span class="terminology-translated">${translation}</span>
            </div>
            <button class="terminology-remove" onclick="removeTerminology('${original.replace(/'/g, "\\'")}')">삭제</button>
        </div>`
    ).join('');
}

function addVocabulary() {
    const original = els.vocabularyOriginal.value.trim();
    const translation = els.vocabularyTranslation.value.trim();
    const description = els.vocabularyDescription.value.trim();
    
    if (!original || !translation) {
        showStatus("원어와 번역어를 모두 입력해주세요", "warning");
        return;
    }
    
    if (vocabularyDict.has(original)) {
        showStatus("이미 등록된 단어입니다", "warning");
        return;
    }
    
    const wordData = {
        original: original,
        translation: translation,
        description: description || "설명 없음",
        addedDate: new Date().toISOString(),
        correctCount: 0,
        wrongCount: 0,
        practiceTime: 0,
        lastStudied: null
    };
    
    vocabularyDict.set(original, wordData);
    
    // 입력 필드 초기화
    els.vocabularyOriginal.value = '';
    els.vocabularyTranslation.value = '';
    els.vocabularyDescription.value = '';
    
    updateVocabularyList();
    updateVocabularyStats();
    saveVocabularyData();
    showStatus(`📚 단어 추가: ${original} → ${translation}`, "success");
}

function showWordDetail(original) {
    const word = vocabularyDict.get(original);
    if (!word) {
        showStatus("단어를 찾을 수 없습니다", "error");
        return;
    }
    
    // currentVocabWord 설정 (중요!)
    currentVocabWord = word;
    
    // DOM 요소 존재 확인
    const wordDetailOriginalEl = document.getElementById('wordDetailOriginal');
    const wordDetailTranslationEl = document.getElementById('wordDetailTranslation');
    const wordDetailPronunciationEl = document.getElementById('wordDetailPronunciation');
    const wordDetailDescriptionEl = document.getElementById('wordDetailDescription');
    const wordDetailModal = document.getElementById('wordDetailModal');
    
    if (!wordDetailOriginalEl || !wordDetailTranslationEl || !wordDetailPronunciationEl || !wordDetailDescriptionEl || !wordDetailModal) {
        showStatus("단어 상세 UI 요소를 찾을 수 없습니다", "error");
        return;
    }
    
    wordDetailOriginalEl.textContent = word.original;
    wordDetailTranslationEl.textContent = word.translation;
    wordDetailPronunciationEl.textContent = `[${generatePronunciation(word.original)}]`;
    wordDetailDescriptionEl.textContent = word.description;
    
    wordDetailModal.classList.add('active');
}

function closeWordDetail() {
    els.wordDetailModal.classList.remove('active');
    currentVocabWord = null;
}

async function speakCurrentWord() {
    if (!currentVocabWord) return;
    
    // 단어장 전용 TTS 함수
    await speakVocabularyWord(currentVocabWord.original, currentVocabWord.translation);
}

function removeVocabulary(original) {
    if (confirm(`"${original}" 단어를 삭제하시겠습니까?`)) {
        vocabularyDict.delete(original);
        updateVocabularyList();
        updateVocabularyStats();
        saveVocabularyData();
        showStatus(`🗑️ 단어 삭제: ${original}`, "success");
    }
}

function startQuiz(difficulty = 'normal') {
    const words = Array.from(vocabularyDict.values());
    if (words.length < 3) {
        showStatus("퀴즈를 위해서는 최소 3개의 단어가 필요합니다", "warning");
        return;
    }
    
    let quizWords = words;
    if (difficulty === 'difficult') {
        // 정답률이 낮은 단어들을 우선적으로 선택
        quizWords = words.filter(word => {
            const total = word.correctCount + word.wrongCount;
            const accuracy = total > 0 ? word.correctCount / total : 0;
            return accuracy < 0.7; // 정답률 70% 미만
        });
        
        if (quizWords.length < 3) {
            quizWords = words; // 어려운 단어가 부족하면 전체에서 선택
        }
    }
    
    // 랜덤으로 섞기
    quizWords = shuffleArray([...quizWords]);
    
    quizState = {
        active: true,
        words: quizWords.slice(0, Math.min(10, quizWords.length)),
        currentIndex: 0,
        correctAnswers: 0,
        wrongAnswers: 0,
        totalQuestions: Math.min(10, quizWords.length),
        selectedAnswer: null
    };
    
    updateQuizDisplay();
    els.quizModal.classList.add('active');
}

function startSingleWordQuiz(wordKey = null) {
    const allWords = Array.from(vocabularyDict.values());
    if (allWords.length < 3) {
        showStatus("퀴즈를 위해서는 최소 3개의 단어가 필요합니다", "warning");
        return;
    }
    
    let targetWord;
    if (wordKey && vocabularyDict.has(wordKey)) {
        targetWord = vocabularyDict.get(wordKey);
    } else if (currentVocabWord) {
        targetWord = currentVocabWord;
    } else {
        showStatus("퀴즈할 단어를 찾을 수 없습니다", "error");
        return;
    }
    
    quizState = {
        active: true,
        words: [targetWord],
        currentIndex: 0,
        correctAnswers: 0,
        wrongAnswers: 0,
        totalQuestions: 1,
        selectedAnswer: null
    };
    
    closeWordDetail();
    updateQuizDisplay();
    els.quizModal.classList.add('active');
}

function selectQuizOption(optionIndex) {
    if (quizState.selectedAnswer !== null) return; // 이미 선택됨
    
    quizState.selectedAnswer = optionIndex;
    
    const options = document.querySelectorAll('.quiz-option');
    const currentWord = quizState.words[quizState.currentIndex];
    const correctIndex = parseInt(options[0].dataset.correct || '0');
    
    options.forEach((option, index) => {
        option.classList.remove('selected');
        if (index === optionIndex) {
            option.classList.add('selected');
        }
        if (index === correctIndex) {
            option.classList.add('correct');
        } else if (index === optionIndex) {
            option.classList.add('wrong');
        }
    });
    
    // 정답 체크
    if (optionIndex === correctIndex) {
        quizState.correctAnswers++;
        currentWord.correctCount++;
        showStatus("✅ 정답!", "success");
    } else {
        quizState.wrongAnswers++;
        currentWord.wrongCount++;
        showStatus("❌ 오답!", "error");
    }
    
    currentWord.lastStudied = new Date().toISOString();
    
    document.getElementById('quizNextBtn').disabled = false;
    updateQuizStats();
}

function nextQuestion() {
    quizState.currentIndex++;
    quizState.selectedAnswer = null;
    
    if (quizState.currentIndex >= quizState.totalQuestions) {
        showQuizResult();
    } else {
        updateQuizDisplay();
    }
    
    document.getElementById('quizNextBtn').disabled = true;
}

function closeQuiz() {
    els.quizModal.classList.remove('active');
    quizState.active = false;
    saveVocabularyData();
    updateVocabularyStats();
}

function startPronunciationPractice() {
    console.log('startPronunciationPractice 시작');
    console.log('currentVocabWord:', currentVocabWord);

    if (!currentVocabWord) {
        showStatus("선택된 단어가 없습니다", "warning");
        return;
    }
    
    // 단어 상세 모달만 닫기 (단어장은 유지)
    closeWordDetail();
    
    practiceState = {
        active: true,
        currentWord: currentVocabWord,
        isRecording: false,
        practiceTime: Date.now(),
        lastRecording: null,
        recordingStartTime: null
    };
    
    // DOM 요소 존재 확인 후 업데이트
    const practiceWordEl = document.getElementById('practiceWord');
    const practicePronunciationEl = document.getElementById('practicePronunciation');
    const practiceTipsEl = document.getElementById('practiceTips');
    const practiceFeedbackEl = document.getElementById('practiceFeedback');
    const recordBtn = document.getElementById('recordBtn');
    
    console.log('DOM 요소 확인:');
    console.log('practiceWord:', practiceWordEl);
    console.log('practicePronunciation:', practicePronunciationEl);
    console.log('practiceTips:', practiceTipsEl);
    console.log('recordBtn:', recordBtn);

    if (!practiceWordEl || !practicePronunciationEl || !practiceTipsEl || !recordBtn) {
        showStatus("발음 연습 UI 요소를 찾을 수 없습니다", "error");
        return;
    }
    
    practiceWordEl.textContent = practiceState.currentWord.original;
    practicePronunciationEl.textContent = `[${generatePronunciation(practiceState.currentWord.original)}]`;
    practiceTipsEl.textContent = generatePronunciationTips(practiceState.currentWord.original);
    
    if (practiceFeedbackEl) {
        practiceFeedbackEl.style.display = 'none';
    }
    
    recordBtn.classList.remove('recording');
    recordBtn.textContent = '🎤';
    
    // 모달 표시 - 강제 스타일 적용
    const practiceModal = document.getElementById('practiceModal');
    if (practiceModal) {
        practiceModal.style.cssText = 'display: flex !important; visibility: visible !important; opacity: 1 !important; position: fixed !important; top: 0 !important; left: 0 !important; right: 0 !important; bottom: 0 !important; z-index: 3000 !important; padding: 20px !important; align-items: center !important; justify-content: center !important;';
        practiceModal.classList.add('active');
    } else {
        showStatus("발음 연습 모달을 찾을 수 없습니다", "error");
    }
}

function startWordPractice(wordKey = null) {
    const words = Array.from(vocabularyDict.values());
    if (words.length === 0) {
        showStatus("연습할 단어가 없습니다", "warning");
        return;
    }
    
    let selectedWord;
    if (wordKey && vocabularyDict.has(wordKey)) {
        selectedWord = vocabularyDict.get(wordKey);
    } else {
        selectedWord = words[Math.floor(Math.random() * words.length)];
    }
    
    // currentVocabWord 설정
    currentVocabWord = selectedWord;
    
    practiceState = {
        active: true,
        currentWord: selectedWord,
        isRecording: false,
        practiceTime: Date.now(),
        lastRecording: null,
        recordingStartTime: null
    };
    
    // DOM 요소 존재 확인 후 업데이트
    const practiceWordEl = document.getElementById('practiceWord');
    const practicePronunciationEl = document.getElementById('practicePronunciation');
    const practiceTipsEl = document.getElementById('practiceTips');
    const practiceFeedbackEl = document.getElementById('practiceFeedback');
    const recordBtn = document.getElementById('recordBtn');
    
    if (!practiceWordEl || !practicePronunciationEl || !practiceTipsEl || !recordBtn) {
        showStatus("발음 연습 UI 요소를 찾을 수 없습니다", "error");
        return;
    }
    
    practiceWordEl.textContent = selectedWord.original;
    practicePronunciationEl.textContent = `[${generatePronunciation(selectedWord.original)}]`;
    practiceTipsEl.textContent = generatePronunciationTips(selectedWord.original);
    
    if (practiceFeedbackEl) {
        practiceFeedbackEl.style.display = 'none';
    }
    
    recordBtn.classList.remove('recording');
    recordBtn.textContent = '🎤';
    
    // 모달 표시 - 단어장은 유지
    const practiceModal = document.getElementById('practiceModal');
    if (practiceModal) {
        practiceModal.style.cssText = 'display: flex !important; visibility: visible !important; opacity: 1 !important; position: fixed !important; top: 0 !important; left: 0 !important; right: 0 !important; bottom: 0 !important; z-index: 3000 !important; padding: 20px !important; align-items: center !important; justify-content: center !important;';
        practiceModal.classList.add('active');
    } else {
        showStatus("발음 연습 모달을 찾을 수 없습니다", "error");
    }
}

// ✅ 단어장 전용 TTS 함수 추가
async function speakVocabularyWord(word, translation = null) {
    try {
        // 언어 자동 감지 - 간단한 방식
        let language = 'English'; // 기본값
        let useGoogleTTS = true;
        
        if (/[가-힣]/.test(word)) {
            language = 'Korean';
        } else if (/[àáạảãâầấậẩẫăằắặẳẵèéẹẻẽêềếệểễìíịỉĩòóọỏõôồốộổỗơờớợởỡùúụủũưừứựửữỳýỵỷỹđĐ]/.test(word)) {
            language = 'Vietnamese';
        }
        
        // TTS 엔진 선택
        const engineMode = els.ttsEngineMode.value;
        if (engineMode === 'openai') {
            useGoogleTTS = false;
        } else if (engineMode === 'google') {
            useGoogleTTS = true;
        } else {
            // auto 모드: 짧은 단어는 Google, 긴 단어는 OpenAI
            useGoogleTTS = word.length < 50;
        }
        
        const voiceName = useGoogleTTS ? els.googleVoiceSelect.value : els.voiceSelect.value;
        const cacheKey = `vocab:${word}:${language}:${useGoogleTTS}:${voiceName}`;
        
        // 캐시 확인
        const cachedAudio = cacheManager.getTTS(cacheKey);
        if (cachedAudio) {
            queueAudioBlob(cachedAudio);
            showStatus("🔊 단어 재생 (캐시)", "success");
            return;
        }
        
        showStatus("🔊 단어 음성 생성 중...", "info");
        
        const response = await fetch(API_URL, {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify({
                action: "speak",
                inputText: word,
                language: language,
                useGoogleTTS: useGoogleTTS,
                voice: voiceName,
                voiceName: voiceName
            })
        });
        
        if (!response.ok) {
            throw new Error(`TTS API 오류: ${response.statusText}`);
        }
        
        const audioBlob = await response.blob();
        cacheManager.setTTS(cacheKey, audioBlob);
        queueAudioBlob(audioBlob);
        
        showStatus(`🔊 ${word} 재생 완료`, "success");
        
    } catch (error) {
        console.error('단어 TTS 오류:', error);
        showStatus(`음성 재생 실패: ${error.message}`, "error");
    }
}

// ✅ 발음 연습 전용 TTS 함수
async function listenPracticeWord() {
    if (!practiceState.currentWord) return;
    
    await speakVocabularyWord(practiceState.currentWord.original);
}

// ✅ 단어장 전용 음성인식 설정 (충돌 방지)
function setupPracticeRecognition() {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
        console.error('음성 인식을 지원하지 않는 브라우저입니다');
        return false;
    }
    
    practiceRecognition = new SpeechRecognition();
    practiceRecognition.continuous = false;
    practiceRecognition.interimResults = true;
    
    return true;
}

// ✅ 마이크/녹음 기능 완전 수정
function toggleRecording() {
    if (!practiceState.currentWord) return;
    
    const recordBtn = document.getElementById('recordBtn');
    
    if (practiceState.isRecording) {
        // 녹음 중지
        stopPracticeRecording();
    } else {
        // 녹음 시작
        startPracticeRecording();
    }
}

function startPracticeRecording() {
    if (!practiceRecognition && !setupPracticeRecognition()) {
        showStatus("음성 인식을 지원하지 않는 브라우저입니다", "error");
        return;
    }
    
    // 언어 설정
    const word = practiceState.currentWord.original;
    let langCode = 'en-US'; // 기본값
    
    if (/[가-힣]/.test(word)) {
        langCode = 'ko-KR';
    } else if (/[àáạảãâầấậẩẫăằắặẳẵèéẹẻẽêềếệểễìíịỉĩòóọỏõôồốộổỗơờớợởỡùúụủũưừứựửữỳýỵỷỹđĐ]/.test(word)) {
        langCode = 'vi-VN';
    }
    
    try {
        practiceState.isRecording = true;
        practiceState.recordingStartTime = Date.now();
        
        const recordBtn = document.getElementById('recordBtn');
        recordBtn.classList.add('recording');
        recordBtn.textContent = '⏹️';
        
        practiceRecognition.lang = langCode;
        
        // 단어장 전용 이벤트 핸들러
        practiceRecognition.onresult = function(event) {
            let transcript = '';
            for (let i = event.resultIndex; i < event.results.length; i++) {
                if (event.results[i].isFinal) {
                    transcript += event.results[i][0].transcript;
                }
            }
            
            if (transcript.trim()) {
                practiceState.lastRecording = transcript.trim();
            }
        };
        
        practiceRecognition.onend = function() {
            stopPracticeRecording();
        };
        
        practiceRecognition.onerror = function(event) {
            console.error('단어장 음성 인식 오류:', event.error);
            showStatus(`음성 인식 오류: ${event.error}`, "error");
            stopPracticeRecording();
        };
        
        practiceRecognition.start();
        showStatus("🎤 발음을 시작하세요...", "info");
        
    } catch (error) {
        console.error('단어장 녹음 시작 오류:', error);
        showStatus("녹음 시작에 실패했습니다", "error");
        stopPracticeRecording();
    }
}

function stopPracticeRecording() {
    practiceState.isRecording = false;
    
    const recordBtn = document.getElementById('recordBtn');
    recordBtn.classList.remove('recording');
    recordBtn.textContent = '🎤';
    
    // ✅ 단어장 전용 recognition 중단
    if (practiceRecognition && practiceRecognition.abort) {
        practiceRecognition.abort();
    }
    
    // 녹음 시간 계산
    if (practiceState.recordingStartTime) {
        const recordingTime = Math.floor((Date.now() - practiceState.recordingStartTime) / 1000);
        practiceState.currentWord.practiceTime += recordingTime;
    }
    
    // 피드백 표시
    const feedback = document.getElementById('practiceFeedback');
    const feedbackText = document.getElementById('practiceFeedbackText');
    
    if (practiceState.lastRecording) {
        const originalWord = practiceState.currentWord.original.toLowerCase();
        const recordedWord = practiceState.lastRecording.toLowerCase();
        
        // 간단한 유사도 검사
        const similarity = calculateSimilarity(originalWord, recordedWord);
        let feedbackMessage = '';
        
        if (similarity > 0.8) {
            feedbackMessage = `✅ 훌륭합니다! "${practiceState.lastRecording}"로 정확하게 발음했습니다.`;
        } else if (similarity > 0.6) {
            feedbackMessage = `👍 좋습니다! "${practiceState.lastRecording}"로 들렸습니다. 조금 더 명확하게 발음해보세요.`;
        } else if (similarity > 0.3) {
            feedbackMessage = `📝 "${practiceState.lastRecording}"로 들렸습니다. 정확한 발음은 "${practiceState.currentWord.original}"입니다. 다시 시도해보세요.`;
        } else {
            feedbackMessage = `🔄 명확하게 들리지 않았습니다. 천천히 또박또박 발음해보세요.`;
        }
        
        feedbackText.textContent = feedbackMessage;
        feedback.style.display = 'block';
        
        // 통계 업데이트
        if (similarity > 0.7) {
            practiceState.currentWord.correctCount++;
        } else {
            practiceState.currentWord.wrongCount++;
        }
        
    } else {
        feedbackText.textContent = "음성이 인식되지 않았습니다. 마이크 권한을 확인하고 다시 시도해주세요.";
        feedback.style.display = 'block';
    }
    
    practiceState.lastRecording = null;
    practiceState.recordingStartTime = null;
    
    // 데이터 저장
    saveVocabularyData();
}

// 텍스트 유사도 계산 함수
function calculateSimilarity(str1, str2) {
    const longer = str1.length > str2.length ? str1 : str2;
    const shorter = str1.length > str2.length ? str2 : str1;
    
    if (longer.length === 0) return 1.0;
    
    const distance = levenshteinDistance(longer, shorter);
    return (longer.length - distance) / longer.length;
}

// 레벤슈타인 거리 계산
function levenshteinDistance(str1, str2) {
    const matrix = [];
    
    for (let i = 0; i <= str2.length; i++) {
        matrix[i] = [i];
    }
    
    for (let j = 0; j <= str1.length; j++) {
        matrix[0][j] = j;
    }
    
    for (let i = 1; i <= str2.length; i++) {
        for (let j = 1; j <= str1.length; j++) {
            if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
            } else {
                matrix[i][j] = Math.min(
                    matrix[i - 1][j - 1] + 1,
                    matrix[i][j - 1] + 1,
                    matrix[i - 1][j] + 1
                );
            }
        }
    }
    
    return matrix[str2.length][str1.length];
}

function nextPracticeWord() {
    const words = Array.from(vocabularyDict.values());
    if (words.length === 0) return;
    
    const randomWord = words[Math.floor(Math.random() * words.length)];
    practiceState.currentWord = randomWord;
    practiceState.isRecording = false;
    practiceState.practiceTime = Date.now();
    practiceState.lastRecording = null;
    practiceState.recordingStartTime = null;
    
    document.getElementById('practiceWord').textContent = randomWord.original;
    document.getElementById('practicePronunciation').textContent = `[${generatePronunciation(randomWord.original)}]`;
    document.getElementById('practiceTips').textContent = generatePronunciationTips(randomWord.original);
    document.getElementById('practiceFeedback').style.display = 'none';
    
    const recordBtn = document.getElementById('recordBtn');
    recordBtn.classList.remove('recording');
    recordBtn.textContent = '🎤';
}

function closePractice() {
    // 녹음 중이면 중지
    if (practiceState.isRecording) {
        stopPracticeRecording();
    }
    
    // 음성인식 정리
    if (practiceRecognition) {
        try {
            practiceRecognition.abort();
        } catch(e) {
            console.log('practiceRecognition 중단 중 오류:', e);
        }
        practiceRecognition = null;
    }
    
    // 모달 완전 숨김
    const practiceModal = document.getElementById('practiceModal');
    practiceModal.classList.remove('active');
    practiceModal.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important;';
    
    practiceState = {
        active: false,
        currentWord: null,
        isRecording: false,
        practiceTime: 0,
        lastRecording: null,
        recordingStartTime: null
    };
    
    saveVocabularyData();
    updateVocabularyStats();
}

// ✅ 보조 함수들
function switchVocabTab(tabName) {
    // 탭 활성화
    document.querySelectorAll('.vocab-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
    
    // 컨텐츠 표시
    document.querySelectorAll('.vocab-content').forEach(content => {
        content.style.display = 'none';
    });
    
    const targetContent = document.getElementById(`vocab${tabName.charAt(0).toUpperCase() + tabName.slice(1)}`);
    if (targetContent) {
        targetContent.style.display = 'block';
    }
    
    // 목록 탭일 때 업데이트
    if (tabName === 'list') {
        updateVocabularyList();
    } else if (tabName === 'stats') {
        updateVocabularyStats();
    }
}

function updateVocabularyList() {
    if (!els.vocabularyList) return;
    
    const words = Array.from(vocabularyDict.values());
    
    if (words.length === 0) {
        els.vocabularyList.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 20px;">등록된 단어가 없습니다</div>';
        return;
    }
    
    els.vocabularyList.innerHTML = words.map(word => {
        const accuracy = word.correctCount + word.wrongCount > 0 
            ? Math.round(word.correctCount / (word.correctCount + word.wrongCount) * 100) 
            : 0;
        
        return `
            <div class="vocabulary-item" onclick="showWordDetail('${word.original.replace(/'/g, "\\'")}')">
                <div class="vocabulary-word">
                    <div class="vocabulary-word-main">${word.original}</div>
                    <div class="vocabulary-word-sub">${word.translation} (정답률: ${accuracy}%)</div>
                </div>
                <div class="vocabulary-actions">
                    <button class="vocabulary-btn listen" onclick="event.stopPropagation(); speakVocabularyWord('${word.original.replace(/'/g, "\\'")}');" title="듣기">🔊</button>
                    <button class="vocabulary-btn practice" onclick="event.stopPropagation(); startWordPractice('${word.original.replace(/'/g, "\\'")}');" title="연습">🎤</button>
                    <button class="vocabulary-btn remove" onclick="event.stopPropagation(); removeVocabulary('${word.original.replace(/'/g, "\\'")}');" title="삭제">🗑️</button>
                </div>
            </div>
        `;
    }).join('');
}

function updateVocabularyStats() {
    const words = Array.from(vocabularyDict.values());
    const totalWords = words.length;
    
    let totalCorrect = 0;
    let totalAnswered = 0;
    let totalPracticeTime = 0;
    
    words.forEach(word => {
        totalCorrect += word.correctCount;
        totalAnswered += word.correctCount + word.wrongCount;
        totalPracticeTime += word.practiceTime || 0;
    });
    
    const accuracy = totalAnswered > 0 ? Math.round(totalCorrect / totalAnswered * 100) : 0;
    const practiceMinutes = Math.floor(totalPracticeTime / 60);
    const learningProgress = totalWords > 0 ? Math.min(Math.round(accuracy * totalWords / 100), 100) : 0;
    
    vocabularyStats = {
        totalWords: totalWords,
        quizAccuracy: accuracy,
        practiceTime: practiceMinutes,
        learningProgress: learningProgress
    };
    
    // UI 업데이트
    const elements = {
        totalWords: document.getElementById('totalWords'),
        quizAccuracy: document.getElementById('quizAccuracy'),
        practiceTime: document.getElementById('practiceTime'),
        learningProgress: document.getElementById('learningProgress'),
        progressBar: document.getElementById('progressBar')
    };
    
    if (elements.totalWords) elements.totalWords.textContent = totalWords;
    if (elements.quizAccuracy) elements.quizAccuracy.textContent = `${accuracy}%`;
    if (elements.practiceTime) elements.practiceTime.textContent = `${practiceMinutes}분`;
    if (elements.learningProgress) elements.learningProgress.textContent = `${learningProgress}%`;
    if (elements.progressBar) elements.progressBar.style.width = `${learningProgress}%`;
}

function loadVocabularyData() {
    try {
        const savedVocab = localStorage.getItem('vocabularyData');
        if (savedVocab) {
            const data = JSON.parse(savedVocab);
            vocabularyDict = new Map(data.words || []);
            vocabularyStats = data.stats || {
                totalWords: 0,
                quizAccuracy: 0,
                practiceTime: 0,
                learningProgress: 0
            };
        }
        
        updateVocabularyList();
        updateVocabularyStats();
    } catch (error) {
        console.error('단어장 데이터 로드 실패:', error);
        vocabularyDict = new Map();
        vocabularyStats = {
            totalWords: 0,
            quizAccuracy: 0,
            practiceTime: 0,
            learningProgress: 0
        };
    }
}

function saveVocabularyData() {
    try {
        const data = {
            words: Array.from(vocabularyDict.entries()),
            stats: vocabularyStats,
            lastSaved: new Date().toISOString()
        };
        localStorage.setItem('vocabularyData', JSON.stringify(data));
    } catch (error) {
        console.error('단어장 데이터 저장 실패:', error);
    }
}

// 퀴즈 관련 보조 함수들
function updateQuizDisplay() {
    if (!quizState.active || quizState.currentIndex >= quizState.words.length) return;
    
    const currentWord = quizState.words[quizState.currentIndex];
    const progress = (quizState.currentIndex / quizState.totalQuestions) * 100;
    
    document.getElementById('quizProgressBar').style.width = `${progress}%`;
    document.getElementById('quizCurrent').textContent = quizState.currentIndex + 1;
    document.getElementById('quizTotal').textContent = quizState.totalQuestions;
    document.getElementById('quizCorrect').textContent = quizState.correctAnswers;
    document.getElementById('quizWrong').textContent = quizState.wrongAnswers;
    
    document.getElementById('quizQuestionText').textContent = currentWord.original;
    document.getElementById('quizQuestionHint').textContent = `"${currentWord.original}"의 뜻은?`;
    
    // 선택지 생성
    generateQuizOptions(currentWord);
    
    document.getElementById('quizNextBtn').disabled = true;
    document.getElementById('quizResult').style.display = 'none';
}

function generateQuizOptions(correctWord) {
    const allWords = Array.from(vocabularyDict.values());
    const wrongWords = allWords.filter(word => word.original !== correctWord.original);
    
    // 랜덤 오답 3개 선택
    const wrongOptions = shuffleArray(wrongWords).slice(0, 3);
    const options = [correctWord, ...wrongOptions];
    const shuffledOptions = shuffleArray(options);
    
    const correctIndex = shuffledOptions.findIndex(word => word.original === correctWord.original);
    
    const optionsContainer = document.getElementById('quizOptions');
    optionsContainer.innerHTML = shuffledOptions.map((word, index) => 
        `<div class="quiz-option" data-correct="${correctIndex}" onclick="selectQuizOption(${index})">
            ${word.translation}
        </div>`
    ).join('');
}

function showQuizResult() {
    const accuracy = Math.round((quizState.correctAnswers / quizState.totalQuestions) * 100);
    
    document.getElementById('quizFinalScore').textContent = `${accuracy}%`;
    
    let message = '';
    if (accuracy >= 90) {
        message = '🎉 완벽합니다! 훌륭한 실력이에요!';
    } else if (accuracy >= 70) {
        message = '👍 잘했습니다! 조금만 더 연습하면 완벽해질 거예요!';
    } else if (accuracy >= 50) {
        message = '📚 더 연습이 필요해요. 단어장을 다시 살펴보세요!';
    } else {
        message = '💪 포기하지 마세요! 꾸준한 연습이 실력 향상의 비결입니다!';
    }
    
    document.getElementById('quizMessage').textContent = message;
    document.getElementById('quizResult').style.display = 'block';
    
    // 다른 요소들 숨기기
    document.querySelector('.quiz-question').style.display = 'none';
    document.querySelector('.quiz-options').style.display = 'none';
    document.querySelector('.quiz-controls').style.display = 'none';
}

function updateQuizStats() {
    document.getElementById('quizCorrect').textContent = quizState.correctAnswers;
    document.getElementById('quizWrong').textContent = quizState.wrongAnswers;
}

// 보조 함수들
function shuffleArray(array) {
    const newArray = [...array];
    for (let i = newArray.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
    }
    return newArray;
}

function generatePronunciation(word) {
    // 간단한 발음 표기 생성 (실제로는 더 복잡한 로직 필요)
    if (/^[a-zA-Z]+$/.test(word)) {
        // 영어 단어인 경우 간단한 발음 표기
        return word.toLowerCase().replace(/[aeiou]/g, match => {
            const vowelMap = { 'a': 'ㅏ', 'e': 'ㅓ', 'i': 'ㅣ', 'o': 'ㅗ', 'u': 'ㅜ' };
            return vowelMap[match] || match;
        });
    } else if (/[가-힣]/.test(word)) {
        // 한국어인 경우 그대로 반환
        return word;
    } else {
        // 베트남어나 기타 언어인 경우
        return word;
    }
}

function generatePronunciationTips(word) {
    // 발음 팁 생성
    if (/^[a-zA-Z]+$/.test(word)) {
        return "영어 발음 시 입 모양과 혀의 위치에 주의하세요. 천천히 따라해보세요.";
    } else if (/[가-힣]/.test(word)) {
        return "한국어 발음 시 정확한 받침 발음에 주의하세요.";
    } else {
        return "해당 언어의 특징적인 발음에 주의하여 연습하세요.";
    }
}

// ✅ 단어장 드롭다운 토글 함수
function toggleVocabulary() {
    const vocabDropdown = document.getElementById('vocabularyDropdown');
    const vocabToggle = document.getElementById('vocabToggle');
    
    vocabDropdown.classList.toggle('active');
    vocabToggle.classList.toggle('active');
    
    if (vocabDropdown.classList.contains('active')) {
        updateVocabularyList();
        updateVocabularyStats();
        
        // 다른 모달들 닫기
        const dashboardModal = document.getElementById('dashboardModal');
        const settingsPanel = document.getElementById('settingsPanel');
        if (dashboardModal) dashboardModal.classList.remove('active');
        if (settingsPanel) settingsPanel.classList.remove('active');
        
        // 외부 클릭 시 닫기 이벤트 추가
        setTimeout(() => {
            document.addEventListener('click', closeVocabularyOnOutsideClick);
        }, 100);
    } else {
        document.removeEventListener('click', closeVocabularyOnOutsideClick);
    }
}

function closeVocabularyOnOutsideClick(event) {
    const vocabDropdown = document.getElementById('vocabularyDropdown');
    const vocabToggle = document.getElementById('vocabToggle');
    
    if (!vocabDropdown.contains(event.target) && !vocabToggle.contains(event.target)) {
        vocabDropdown.classList.remove('active');
        vocabToggle.classList.remove('active');
        document.removeEventListener('click', closeVocabularyOnOutsideClick);
    }
}

function toggleRecentPlays(){
    const recentPlayList = document.getElementById('recentPlayList');
    const toggleBtn = document.getElementById('recentPlaysToggleBtn');
    
    if (recentPlayList.style.display === 'none') {
        recentPlayList.style.display = 'block';
        toggleBtn.textContent = '접기';
    } else {
        recentPlayList.style.display = 'none';
        toggleBtn.textContent = '펼치기';
    }
}

// AI 문맥 번역 함수들
function toggleAIMode() {
    aiContextMode = !aiContextMode;
    els.aiToggle.classList.toggle('active', aiContextMode);
    els.aiContextBadge.classList.toggle('active', aiContextMode);
    els.translateBtn.classList.toggle('ai-enhanced', aiContextMode);
    els.translateBtnText.textContent = aiContextMode ? 'AI 번역' : '번역하기';
    els.aiSettingsSection.style.display = aiContextMode ? 'block' : 'none';
    
    if (aiContextMode) {
        showStatus("🧠 AI 문맥 번역 모드 활성화", "success");
    } else {
        showStatus("📝 일반 번역 모드로 전환", "info");
    }
    
    saveAISettings();
}

function buildContextualPrompt(inputText, targetLang) {
    const sourceLang = els.sourceLangSelect.value;
    let prompt = `번역할 텍스트: "${inputText}"\n번역 방향: ${sourceLang} → ${targetLang}\n`;
    
    // 번역 스타일 적용
    const styleInstructions = {
        balanced: "자연스럽고 균형잡힌 번역을 제공하세요.",
        formal: "격식있고 공손한 어조로 번역하세요.",
        casual: "친근하고 편안한 어조로 번역하세요.",
        literal: "원문의 의미를 정확히 보존하여 직역하세요."
    };
    prompt += `번역 스타일: ${styleInstructions[currentTranslationStyle]}\n`;
    
    // 품질 레벨 적용
    if (qualityLevel >= 4) {
        prompt += "매우 정확하고 자연스러운 고품질 번역을 제공하세요. 문화적 뉘앙스와 관용표현을 적절히 반영하세요.\n";
    } else if (qualityLevel >= 3) {
        prompt += "정확하고 자연스러운 번역을 제공하세요.\n";
    }
    
    // 전문용어 사전 적용
    if (terminologyDict.size > 0) {
        prompt += "다음 전문용어를 일관성있게 사용하세요:\n";
        terminologyDict.forEach((translation, original) => {
            prompt += `- "${original}" → "${translation}"\n`;
        });
    }
    
    // 문맥 정보 추가 (최근 5개 고정)
    if (translationContext.length > 0) {
        const recentContext = translationContext.slice(-5);
        prompt += "\n이전 번역 맥락:\n";
        recentContext.forEach((ctx, index) => {
            prompt += `${index + 1}. "${ctx.source}" → "${ctx.translation}"\n`;
        });
        prompt += "\n위 맥락을 고려하여 일관성있게 번역하세요.\n";
    }
    
    return prompt;
}

async function handleTranslate(){
    const inputText = els.inputText.value.trim();
    if (!inputText) return;
    
    const targetLang = els.targetLangSelect.value;
    // 🔧 AI 모드 권한 체크
    if (aiContextMode && !currentUser) {
        showPremiumAlert('AI 문맥 번역');
        return;
    }
    
    // 🔧 게스트 모드 알림 (첫 번역 시에만)
    if (!currentUser && !sessionStorage.getItem('guestWarningShown')) {
        showStatus("🎯 게스트 모드로 이용 중입니다. 로그인하시면 더 많은 기능을 이용하실 수 있습니다.", "info");
        sessionStorage.setItem('guestWarningShown', 'true');
    }
    const cacheKey = `${inputText}:${targetLang}:${aiContextMode}`;
    
    // 캐시 확인
    const cachedResult = isPronunciationEnabled ? cacheManager.getTranslation(cacheKey) : null;
    if (cachedResult) {
        displayTranslation(cachedResult.translation, cachedResult.pronunciation_hangul, inputText, true);
        showStatus("📦 캐시에서 로드됨", "success");
        updateStats(true);
        return;
    }
    
    showStatus(aiContextMode ? "🧠 AI 문맥 번역 중..." : "번역 중...", "info");
    els.cacheIndicator.style.display = "none";
    els.aiIndicator.style.display = aiContextMode ? "inline-block" : "none";
    
    usageTracker.track("translation", inputText.length);
    
    try {
        let requestBody;
        
        if (aiContextMode) {
            // AI 문맥 번역 요청
            const contextualPrompt = buildContextualPrompt(inputText, targetLang);
            requestBody = {
                action: "translate",
                inputText: inputText,
                targetLang: targetLang,
                getPronunciation: isPronunciationEnabled,
                useAIContext: true,
                contextualPrompt: contextualPrompt,
                qualityLevel: qualityLevel
            };
        } else {
            // 일반 번역 요청
            requestBody = {
                action: "translate",
                inputText: inputText,
                targetLang: targetLang,
                getPronunciation: isPronunciationEnabled
            };
        }
        
        const response = await fetch(API_URL, {
            method: "POST",
            headers: {"Content-Type": "application/json"},
            body: JSON.stringify(requestBody)
        });
        
        const result = await response.json();
        if (result.error) throw new Error(result.error);

        displayTranslation(result.translation, result.pronunciation_hangul, inputText, false);

        // 옵션 3: 번역 결과에 사용된 모델 정보 표시
        if (aiContextMode) {
            const modelConfig = {
                1: { model: 'gpt-4o-mini', cost: '$0.0001' },
                2: { model: 'gpt-4o-mini', cost: '$0.0001' },
                3: { model: 'gpt-4o', cost: '$0.0015' },
                4: { model: 'gpt-4o', cost: '$0.0020' },
                5: { model: 'gpt-4o', cost: '$0.0025' }
            };
            const config = modelConfig[qualityLevel];
            displayTranslationModelInfo(config.model, config.cost);
        } else {
            // 일반 모드는 gpt-4o-mini 사용
            displayTranslationModelInfo('gpt-4o-mini', '$0.0001');
        }

        // 번역 컨텍스트에 추가 (AI 모드일 때만)
        if (aiContextMode) {
            translationContext.push({
                source: inputText,
                translation: result.translation,
                timestamp: Date.now()
            });
            
            // 컨텍스트 크기 제한
            if (translationContext.length > 20) {
                translationContext = translationContext.slice(-20);
            }
        }
        
        if (isPronunciationEnabled) {
            cacheManager.setTranslation(cacheKey, result);
        }
        
        saveToHistory(inputText, result.translation, els.sourceLangSelect.value, targetLang);
        updateStats(false);
        showStatus(aiContextMode ? "🧠 AI 번역 완료" : "번역 완료", "success");
        
    } catch (error) {
        showStatus(`번역 실패: ${error.message}`, "error");
    }
}

// AI 설정 저장/로드
function saveAISettings() {
    const aiSettings = {
        aiContextMode,
        translationContext: translationContext.slice(-20), // 최근 20개만 저장
        currentTranslationStyle,
        qualityLevel,
        terminologyDict: Array.from(terminologyDict.entries()) // 전문용어 사전 저장
    };
    localStorage.setItem('aiSettings', JSON.stringify(aiSettings));
}

function loadAISettings() {
    const saved = localStorage.getItem('aiSettings');
    if (saved) {
        try {
            const aiSettings = JSON.parse(saved);
            aiContextMode = aiSettings.aiContextMode || false;
            translationContext = aiSettings.translationContext || [];
            currentTranslationStyle = aiSettings.currentTranslationStyle || 'balanced';
            qualityLevel = aiSettings.qualityLevel || 3;
            
            // 전문용어 사전 복원
            if (aiSettings.terminologyDict) {
                terminologyDict = new Map(aiSettings.terminologyDict);
            }
            
            // UI 업데이트
            els.aiToggle.classList.toggle('active', aiContextMode);
            els.aiContextBadge.classList.toggle('active', aiContextMode);
            els.translateBtn.classList.toggle('ai-enhanced', aiContextMode);
            els.translateBtnText.textContent = aiContextMode ? 'AI 번역' : '번역하기';
            els.aiSettingsSection.style.display = aiContextMode ? 'block' : 'none';
            els.qualitySlider.value = qualityLevel;

            // 모델 정보 표시 초기화
            updateModelInfo(qualityLevel);

            // 스타일 버튼 업데이트
            document.querySelectorAll('.style-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.style === currentTranslationStyle);
            });
            
            // 전문용어 목록 업데이트
            updateTerminologyList();
        } catch (e) {
            console.error('AI 설정 로드 실패:', e);
        }
    }
}

// 기존 함수들 (기본 번역기 기능)

// 옵션 1: 품질 슬라이더의 모델 정보를 실시간으로 업데이트하는 함수
function updateModelInfo(level) {
    const modelConfig = {
        1: { model: 'gpt-4o-mini', cost: '매우 낮음', tokens: '1000' },
        2: { model: 'gpt-4o-mini', cost: '낮음', tokens: '1200' },
        3: { model: 'gpt-4o', cost: '중간', tokens: '1500' },
        4: { model: 'gpt-4o', cost: '높음', tokens: '2000' },
        5: { model: 'gpt-4o', cost: '매우 높음', tokens: '2500' }
    };

    const config = modelConfig[level];
    const modelInfoDisplay = document.getElementById('modelInfoDisplay');

    if (modelInfoDisplay && config) {
        modelInfoDisplay.innerHTML = `
            <span class="model-name">모델: ${config.model}</span>
            <span class="model-cost">비용: ${config.cost}</span>
            <span class="model-tokens">토큰: ${config.tokens}</span>
        `;
    }
}

// 옵션 3: 번역 결과에 사용된 모델 정보를 표시하는 함수
function displayTranslationModelInfo(model, cost) {
    const translationModelInfo = document.getElementById('translationModelInfo');
    if (translationModelInfo) {
        translationModelInfo.textContent = `${model} | ${cost}`;
        translationModelInfo.style.display = 'inline-block';
    }
}

async function handleSpeak(){if(!currentTranslation)return;window.budgetExceeded&&(els.ttsEngineMode.value="google",showStatus("⛔ 예산 초과. Google TTS만 사용 가능","error"));const e=els.targetLangSelect.value,t=els.ttsEngineMode.value;let a="openai";"google"===t?a="google":"openai"===t?a="openai":"auto"===t?"Vietnamese"===e||currentTranslation.length<parseInt(els.autoThreshold.value)?a="google":a="openai":"smart"===t?currentTranslation.length<100||conversationState.isActive||"Vietnamese"===e?a="google":a="openai":a="openai";const s="google"===a?els.googleVoiceSelect.value:els.voiceSelect.value,i=`${currentTranslation}:${e}:${a}:${s}`,o=cacheManager.getTTS(i);if(els.engineIndicator.textContent=a.charAt(0).toUpperCase(),els.engineIndicator.className=`engine-indicator ${a}`,els.engineIndicator.style.display="inline-block",o)return queueAudioBlob(o),showStatus("🔊 캐시된 음성 재생","success"),void cacheManager.addRecentPlay(currentSource,currentTranslation,e,a);showStatus("음성 생성 중...","info"),usageTracker.track("tts",currentTranslation.length,a);try{const t=await fetch(API_URL,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({action:"speak",inputText:currentTranslation,language:e,useGoogleTTS:"google"===a,voice:s,voiceName:s})});if(!t.ok)throw new Error(`API 오류: ${t.statusText}`);const o=await t.blob();cacheManager.setTTS(i,o),queueAudioBlob(o),cacheManager.addRecentPlay(currentSource,currentTranslation,e,a),showStatus(`🔊 ${a} TTS 재생`,"success")}catch(e){showStatus(`음성 생성 실패: ${e.message}`,"error")}}
function handleVoiceTranslate(){recognition||setupSpeechRecognition(),isRecording?recognition.stop():(recognition.lang=langCodeMap[els.sourceLangSelect.value],recognition.start())}
function displayTranslation(e,t,a,s){currentTranslation=e,currentSource=a,els.translation.textContent=e,els.pronunciationSection.style.display=isPronunciationEnabled?"block":"none",isPronunciationEnabled&&(els.pronunciationContent.textContent=t||""),els.speakBtn.disabled=!1,els.copyBtn.disabled=!1,els.cacheIndicator.style.display=s?"inline-block":"none"}
function setupSpeechRecognition(){const e=window.SpeechRecognition||window.webkitSpeechRecognition;if(!e)return void showStatus("음성 인식 미지원 브라우저","error");recognition=new e,recognition.continuous=!1,recognition.interimResults=!0;let t="";recognition.onstart=()=>{isRecording=!0,t="",els.voiceBtn.classList.add("recording")},recognition.onresult=e=>{let a="";for(let s=e.resultIndex;s<e.results.length;++s)e.results[s].isFinal?t+=e.results[s][0].transcript:a+=e.results[s][0].transcript;conversationState.isActive||(els.inputText.value=t+a)},recognition.onend=()=>{isRecording=!1,els.voiceBtn.classList.remove("recording");const e=t.trim();conversationState.isActive?e?handleConversationTranslation(e):startAutoRecognition():e&&(els.inputText.value=e,handleTranslate())},recognition.onerror=e=>{showStatus(`음성 인식 오류: ${e.error}`,"error"),isRecording=!1,els.voiceBtn.classList.remove("recording")}}
function toggleDashboard(){els.dashboardModal.classList.toggle("active"),els.dashboardModal.classList.contains("active")&&usageTracker.updateDisplay()}
function toggleSettings(){els.settingsPanel.classList.toggle("active")}
function toggleTheme(){const e="dark"===document.documentElement.getAttribute("data-theme")?"light":"dark";document.documentElement.setAttribute("data-theme",e),localStorage.setItem("theme",e)}
function swapLanguages(){const e=els.sourceLangSelect.value;els.sourceLangSelect.value=els.targetLangSelect.value,els.targetLangSelect.value=e,saveSettings()}
function copyTranslation(){navigator.clipboard.writeText(currentTranslation).then(()=>showStatus("📋 번역문 복사 완료","success"))}
function copyInputText(){const e=els.inputText.value;e?navigator.clipboard.writeText(e).then(()=>showStatus("📋 원문 복사 완료","success")):showStatus("복사할 내용이 없습니다","warning")}
async function pasteFromClipboard(){try{const e=await navigator.clipboard.readText();e?(els.inputText.value+=e,showStatus("📋 붙여넣기 완료","success")):showStatus("클립보드가 비어있습니다","warning")}catch(e){console.error("붙여넣기 실패:",e),showStatus("붙여넣기에 실패했습니다","error")}}
function clearAll(){els.inputText.value="",els.translation.textContent="",els.pronunciationContent.textContent="",els.speakBtn.disabled=!0,els.copyBtn.disabled=!0,els.cacheIndicator.style.display="none",els.aiIndicator.style.display="none";const translationModelInfo=document.getElementById("translationModelInfo");translationModelInfo&&(translationModelInfo.style.display="none")}
function showStatus(e,t=""){els.status.textContent=e,els.status.className=`status ${t}`,setTimeout(()=>{els.status.textContent="",els.status.className="status"},3e3)}
function clearAllCache(){confirm("모든 캐시 데이터를 삭제하시겠습니까?")&&(cacheManager.clear(),updateRecentPlays(),displayStats(),showStatus("✨ 캐시가 초기화되었습니다.","success"))}
function switchToNormalMode(){conversationState.isActive&&stopConversation(),els.normalModeBtn.classList.add("active"),els.conversationModeBtn.classList.remove("active"),els.normalMode.classList.remove("hidden"),els.conversationMode.classList.remove("active")}
function switchToConversationMode(){els.conversationModeBtn.classList.add("active"),els.normalModeBtn.classList.remove("active"),els.normalMode.classList.add("hidden"),els.conversationMode.classList.add("active"),updateSpeakerLanguages()}
function updateSpeakerLanguages(){els.speakerLangA.textContent=els.sourceLangSelect.options[els.sourceLangSelect.selectedIndex].text,els.speakerLangB.textContent=els.targetLangSelect.options[els.targetLangSelect.selectedIndex].text}
function startConversation(){conversationState.isActive=!0,conversationState.currentSpeaker="A",conversationState.autoRecognition=!0,els.startConversationBtn.disabled=!0,els.stopConversationBtn.disabled=!1,updateActiveSpeaker(),startAutoRecognition()}
function stopConversation(){conversationState.isActive=!1,conversationState.autoRecognition=!1,recognition&&isRecording&&recognition.stop(),els.startConversationBtn.disabled=!1,els.stopConversationBtn.disabled=!0,els.speakerCardA.classList.remove("active"),els.speakerCardB.classList.remove("active")}
function clearConversation(){conversationState.messages=[],updateConversationHistory()}
function updateActiveSpeaker(){"A"===conversationState.currentSpeaker?(els.speakerCardA.classList.add("active"),els.speakerCardB.classList.remove("active")):(els.speakerCardA.classList.remove("active"),els.speakerCardB.classList.add("active"))}
async function startAutoRecognition(){if(!conversationState.autoRecognition)return;isRecording&&(recognition.stop(),await new Promise(e=>setTimeout(e,100)));const e="A"===conversationState.currentSpeaker?els.sourceLangSelect.value:els.targetLangSelect.value;recognition.lang=langCodeMap[e],recognition.start()}
async function handleConversationTranslation(e){const t=conversationState.currentSpeaker,a="B"===t,s=a?els.targetLangSelect.value:els.sourceLangSelect.value,i=a?els.sourceLangSelect.value:els.targetLangSelect.value;usageTracker.track("translation",e.length),updateStats(!1);const o=await fetch(API_URL,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({action:"translate",inputText:e,targetLang:i,getPronunciation:!1})}),r=await o.json();conversationState.messages.push({speaker:t,original:e,translation:r.translation}),updateConversationHistory(),playChunkedAudio(r.chunks||[r.translation],i),conversationState.currentSpeaker="A"===t?"B":"A",updateActiveSpeaker(),setTimeout(startAutoRecognition,500)}
function updateConversationHistory(){0===conversationState.messages.length?els.conversationHistory.innerHTML='<div style="text-align:center; padding: 20px; color: var(--text-secondary);">대화를 시작하세요</div>':(els.conversationHistory.innerHTML=conversationState.messages.map(e=>`<div class="conversation-message"><div class="message-speaker speaker-${"A"===e.speaker?"a":"b"}">${e.speaker}</div><div class="message-content"><div class="message-original">${e.original}</div><div class="message-translation">${e.translation}</div></div></div>`).join(""),els.conversationHistory.scrollTop=els.conversationHistory.scrollHeight)}
async function playChunkedAudio(e,t){for(const a of e){usageTracker.track("tts",a.length,"google");const e=await fetch(API_URL,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({action:"speak",inputText:a,language:t,useGoogleTTS:!0,voiceName:els.googleVoiceSelect.value})});e.ok&&queueAudioBlob(await e.blob())}}
function initAudioContext(){audioContext||(audioContext=new(window.AudioContext||window.webkitAudioContext)),"suspended"===audioContext?.state&&audioContext.resume()}
async function playAudioBlob(e){
    try{
        initAudioContext();
        const audioBuffer = await audioContext.decodeAudioData(await e.arrayBuffer());
        const source = audioContext.createBufferSource();
        source.buffer = audioBuffer;

        // 🎯 볼륨 조절기(GainNode) 생성
        const gainNode = audioContext.createGain();
        
        // 🎯 증폭 설정 (1.0이 기본값, 숫자를 키울수록 소리가 커집니다)
        gainNode.gain.value = 4.5; // 예: 2.5배 증폭

        // 🎯 오디오 연결: 소스 -> 볼륨 조절기 -> 스피커
        source.connect(gainNode);
        gainNode.connect(audioContext.destination);

        source.onended = playNextInQueue;
        source.start(0);
    } catch(t) {
        // Web Audio API를 지원하지 않는 경우의 대체 코드
        const audio = new Audio(URL.createObjectURL(e));
        audio.volume = 1.0; // HTML Audio 요소의 볼륨은 0.0 ~ 1.0
        audio.onended = playNextInQueue;
        audio.play();
    }
}
function queueAudioBlob(e){audioQueue.push(e),isQueuePlaying||playNextInQueue()}
function playNextInQueue(){if(0===audioQueue.length)return void(isQueuePlaying=!1);isQueuePlaying=!0,playAudioBlob(audioQueue.shift())}
function getStats(){const e=localStorage.getItem("translationStats");return e?JSON.parse(e):{totalTranslations:0,todayTranslations:0,lastDate:(new Date).toDateString()}}
function updateStats(e){const t=getStats();(new Date).toDateString()!==t.lastDate&&(t.todayTranslations=0,t.lastDate=(new Date).toDateString()),e||(t.totalTranslations++,t.todayTranslations++),localStorage.setItem("translationStats",JSON.stringify(t)),displayStats()}
function displayStats(){const e=getStats();els.todayTranslations.textContent=e.todayTranslations,els.totalTranslations.textContent=e.totalTranslations;const t=cacheManager.stats.hits+cacheManager.stats.misses>0?Math.round(cacheManager.stats.hits/(cacheManager.stats.hits+cacheManager.stats.misses)*100):0;els.cacheHitRate.textContent=`${t}%`}
function saveToHistory(e,t,a,s){const i=JSON.parse(localStorage.getItem("translationHistory")||"[]");i.unshift({source:e,translation:t,sourceLang:a,targetLang:s,time:(new Date).toLocaleString("ko-KR")}),i.length>50&&i.pop(),localStorage.setItem("translationHistory",JSON.stringify(i))}
function showHistory(){const e=JSON.parse(localStorage.getItem("translationHistory")||"[]");els.historyList.innerHTML=e.length?e.map((e,t)=>`<div class="recent-play-item" onclick="loadFromHistory(${t})"><div><div class="recent-play-text" style="white-space: normal;"><b>${e.sourceLang}:</b> ${e.source}</div><div class="recent-play-text" style="white-space: normal; color: var(--primary);"><b>${e.targetLang}:</b> ${e.translation}</div></div><small style="color: var(--text-secondary);">${e.time}</small></div>`).join(""):`<p style="text-align:center;">기록 없음</p>`,els.historyModal.classList.add("active")}
function hideHistory(){els.historyModal.classList.remove("active")}
function loadFromHistory(e){const t=JSON.parse(localStorage.getItem("translationHistory"))[e];t&&(els.inputText.value=t.source,els.sourceLangSelect.value=t.sourceLang,els.targetLangSelect.value=t.targetLang,hideHistory(),handleTranslate())}
function clearHistory(){confirm("모든 기록을 삭제합니까?")&&(localStorage.removeItem("translationHistory"),showHistory())}

function updateRecentPlays(){
    const recentPlaysEl = els.recentPlays;
    const recentPlayListEl = els.recentPlayList;
    
    // 최근 재생 항목이 있을 때만 표시하되, 기본은 접힌 상태
    if (cacheManager.recentPlays.length > 0) {
        recentPlaysEl.classList.add("active");
        recentPlayListEl.innerHTML = cacheManager.recentPlays.map((e,t)=>`<div class="recent-play-item"><div class="recent-play-text">${e.text.substring(0,25)}...</div><div class="recent-play-actions"><button class="recent-play-btn" onclick="replayRecent(${t})">🔊</button><span class="engine-indicator ${e.engine}">${e.engine[0].toUpperCase()}</span></div></div>`).join("");
        
        // 기본 접힌 상태 유지
        if (!recentPlayListEl.style.display || recentPlayListEl.style.display === 'none') {
            recentPlayListEl.style.display = 'none';
            document.getElementById('recentPlaysToggleBtn').textContent = '펼치기';
        }
    } else {
        recentPlaysEl.classList.remove("active");
    }
}

async function replayRecent(e){const t=cacheManager.recentPlays[e],a="google"===t.engine?els.googleVoiceSelect.value:els.voiceSelect.value,s=`${t.translation}:${t.lang}:${t.engine}:${a}`,i=cacheManager.getTTS(s);if(i)return void queueAudioBlob(i);currentTranslation=t.translation,currentSource=t.text,await handleSpeak()}
function saveSettings(){localStorage.setItem("ttsEngine",els.ttsEngineMode.value),localStorage.setItem("autoThreshold",els.autoThreshold.value),localStorage.setItem("voice",els.voiceSelect.value),localStorage.setItem("googleVoice",els.googleVoiceSelect.value),localStorage.setItem("volume",els.volumeControl.value),localStorage.setItem("sourceLang",els.sourceLangSelect.value),localStorage.setItem("targetLang",els.targetLangSelect.value),localStorage.setItem("pronunciationEnabled",isPronunciationEnabled)}
function loadSettings(){document.documentElement.setAttribute("data-theme",localStorage.getItem("theme")||"light"),isPronunciationEnabled="false"!==localStorage.getItem("pronunciationEnabled"),els.pronunciationToggle.classList.toggle("active",isPronunciationEnabled),els.pronunciationSection.style.display=isPronunciationEnabled?"block":"none",els.sourceLangSelect.value=localStorage.getItem("sourceLang")||"Korean",els.targetLangSelect.value=localStorage.getItem("targetLang")||"Vietnamese",els.ttsEngineMode.value=localStorage.getItem("ttsEngine")||"auto",els.autoThreshold.value=localStorage.getItem("autoThreshold")||"50",els.thresholdValue.textContent=`${els.autoThreshold.value}자`,els.voiceSelect.value=localStorage.getItem("voice")||"nova",els.googleVoiceSelect.value=localStorage.getItem("googleVoice")||"vi-VN-Standard-A",els.volumeControl.value=localStorage.getItem("volume")||"0.8",els.volumeValue.textContent=`${Math.round(100*els.volumeControl.value)}%`,updateAutoModeVisibility(),document.getElementById("dailyBudget").value=localStorage.getItem("dailyBudget")||"1.00",document.getElementById("monthlyBudget").value=localStorage.getItem("monthlyBudget")||"30.00"}
function updateAutoModeVisibility(){const e=els.ttsEngineMode.value;els.autoModeSettings.style.display="auto"===e||"smart"===e?"grid":"none"}
function togglePronunciationView(){const e=els.pronunciationContent;e.style.display="none"===e.style.display||""===e.style.display?"block":"none",els.pronToggleIcon.textContent="block"===e.style.display?"▼":"▶"}

// ✅ 전역 함수로 할당 (HTML에서 호출 가능하도록)
window.addVocabulary = addVocabulary;
window.showWordDetail = showWordDetail;
window.closeWordDetail = closeWordDetail;
window.speakCurrentWord = speakCurrentWord;
window.removeVocabulary = removeVocabulary;
window.startQuiz = startQuiz;
window.startSingleWordQuiz = startSingleWordQuiz;
window.selectQuizOption = selectQuizOption;
window.nextQuestion = nextQuestion;
window.closeQuiz = closeQuiz;
window.startPronunciationPractice = startPronunciationPractice;
window.startWordPractice = startWordPractice;
window.listenPracticeWord = listenPracticeWord;
window.toggleRecording = toggleRecording;
window.nextPracticeWord = nextPracticeWord;
window.closePractice = closePractice;
window.showPreviousWord = showPreviousWord;
window.showNextWord = showNextWord;
window.speakVocabularyWord = speakVocabularyWord;
// 🔧 추가: 인증 관련 전역 함수들
window.toggleAuth = toggleAuth;
window.toggleApiKeys = toggleApiKeys;
window.handleLogin = handleLogin;
window.handleRegister = handleRegister;
window.continueAsGuest = continueAsGuest;
window.showForgotPassword = showForgotPassword;
window.showLoginForm = showLoginForm;
window.handleForgotPassword = handleForgotPassword;
window.switchAuthTab = switchAuthTab;
window.saveOpenAIKey = saveOpenAIKey;
window.saveGoogleKey = saveGoogleKey;
window.testOpenAIKey = testOpenAIKey;
window.testGoogleKey = testGoogleKey;
window.speakCurrentWord = speakCurrentWord;

// 🔧 권한 체크가 포함된 전역 함수들
window.toggleAIModeWithAuth = toggleAIModeWithAuth;
window.toggleVocabularyWithAuth = toggleVocabularyWithAuth;
window.switchVocabTab = switchVocabTab;
window.addTerminology = addTerminology;
window.removeTerminology = removeTerminology;

// 모든 모달 닫기 함수
function closeAllModals() {
    const modals = [
        'practiceModal', 
        'wordDetailModal', 
        'quizModal', 
        'dashboardModal', 
        'historyModal',
        'vocabularyDropdown'
    ];

    modals.forEach(modalId => {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.classList.remove('active');
            if (modalId === 'practiceModal') {
                modal.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important;';
            }
        }
    });
}

// 이전 단어 보기
function showPreviousWord() {
    const words = Array.from(vocabularyDict.values());
    if (words.length <= 1) return;
    
    const currentIndex = words.findIndex(word => word.original === currentVocabWord.original);
    const previousIndex = currentIndex > 0 ? currentIndex - 1 : words.length - 1;
    const previousWord = words[previousIndex];
    
    showWordDetail(previousWord.original);
}

// 다음 단어 보기
function showNextWord() {
    const words = Array.from(vocabularyDict.values());
    if (words.length <= 1) return;
    
    const currentIndex = words.findIndex(word => word.original === currentVocabWord.original);
    const nextIndex = currentIndex < words.length - 1 ? currentIndex + 1 : 0;
    const nextWord = words[nextIndex];
    
    showWordDetail(nextWord.original);
}

// ✅ 초기화
document.addEventListener("DOMContentLoaded", function() {
    try {
        // 시스템 초기화
        usageTracker.initialize();
        cacheManager.load();
        loadSettings();
        loadAISettings();
        loadVocabularyData();
        setupSpeechRecognition();
        updateRecentPlays();
        updateSpeakerLanguages();
        displayStats();
        // 🔧 인증 시스템 초기화
        initAuthSystem();
        
        // 🔧 UI 상태 초기 설정
        updateAuthUI(!!currentUser);
        
        // 기존 이벤트 리스너들
        if (els.ttsEngineMode) {
            els.ttsEngineMode.addEventListener("change", function() {
                updateAutoModeVisibility();
                saveSettings();
            });
        }
        
        if (els.autoThreshold) {
            els.autoThreshold.addEventListener("input", function(e) {
                if (els.thresholdValue) els.thresholdValue.textContent = `${e.target.value}자`;
                saveSettings();
            });
        }
        
        if (els.volumeControl) {
            els.volumeControl.addEventListener("input", function(e) {
                if (els.volumeValue) els.volumeValue.textContent = `${Math.round(100 * e.target.value)}%`;
                saveSettings();
            });
        }
        
        if (els.voiceSelect) {
            els.voiceSelect.addEventListener("change", saveSettings);
        }
        
        if (els.googleVoiceSelect) {
            els.googleVoiceSelect.addEventListener("change", saveSettings);
        }
        
        if (els.pronunciationToggle) {
            els.pronunciationToggle.addEventListener("click", function() {
                isPronunciationEnabled = !isPronunciationEnabled;
                els.pronunciationToggle.classList.toggle("active", isPronunciationEnabled);
                if (els.pronunciationSection) {
                    els.pronunciationSection.style.display = isPronunciationEnabled ? "block" : "none";
                }
                saveSettings();
                showStatus(`발음 도우미 ${isPronunciationEnabled ? "ON" : "OFF"}`, "success");
            });
        }
        
        const dailyBudgetEl = document.getElementById("dailyBudget");
        const monthlyBudgetEl = document.getElementById("monthlyBudget");
        
        if (dailyBudgetEl) {
            dailyBudgetEl.addEventListener("change", function(e) {
                localStorage.setItem("dailyBudget", e.target.value);
            });
        }
        
        if (monthlyBudgetEl) {
            monthlyBudgetEl.addEventListener("change", function(e) {
                localStorage.setItem("monthlyBudget", e.target.value);
            });
        }
        
        if (els.sourceLangSelect) {
            els.sourceLangSelect.addEventListener("change", function() {
                saveSettings();
                updateSpeakerLanguages();
            });
        }
        
        if (els.targetLangSelect) {
            els.targetLangSelect.addEventListener("change", function() {
                saveSettings();
                updateSpeakerLanguages();
            });
        }
        
        // AI 기능 이벤트 리스너들
        if (els.qualitySlider) {
            els.qualitySlider.addEventListener("input", function(e) {
                qualityLevel = parseInt(e.target.value);
                updateModelInfo(qualityLevel); // 옵션 1: 슬라이더 변경 시 모델 정보 업데이트
                saveAISettings();
            });
            // 초기 모델 정보 표시
            updateModelInfo(qualityLevel);
        }
        
        // 번역 스타일 버튼 이벤트
        document.querySelectorAll('.style-btn').forEach(function(btn) {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.style-btn').forEach(function(b) {
                    b.classList.remove('active');
                });
                btn.classList.add('active');
                currentTranslationStyle = btn.dataset.style;
                saveAISettings();
            });
        });
        
        // 단어장 탭 이벤트
        document.querySelectorAll('.vocab-tab').forEach(function(tab) {
            tab.addEventListener('click', function() {
                switchVocabTab(tab.dataset.tab);
            });
        });
        
        // 전문용어 입력 필드 엔터키 이벤트 (간소화)
        const terminologyInputEl = document.getElementById('terminologyInput');
        
        if (terminologyInputEl) {
            terminologyInputEl.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    addTerminology();
                }
            });
        }
        
        // 단어장 입력 필드 엔터키 이벤트
        if (els.vocabularyOriginal) {
            els.vocabularyOriginal.addEventListener('keypress', function(e) {
                if (e.key === 'Enter' && els.vocabularyTranslation) {
                    els.vocabularyTranslation.focus();
                }
            });
        }
        
        if (els.vocabularyTranslation) {
            els.vocabularyTranslation.addEventListener('keypress', function(e) {
                if (e.key === 'Enter' && els.vocabularyDescription) {
                    els.vocabularyDescription.focus();
                }
            });
        }
        
        if (els.vocabularyDescription) {
            els.vocabularyDescription.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    addVocabulary();
                }
            });
        }
        
        // 모달 외부 클릭 시 닫기
        if (els.wordDetailModal) {
            els.wordDetailModal.addEventListener('click', function(e) {
                if (e.target === els.wordDetailModal) {
                    closeWordDetail();
                }
            });
        }
        
        if (els.quizModal) {
            els.quizModal.addEventListener('click', function(e) {
                if (e.target === els.quizModal) {
                    closeQuiz();
                }
            });
        }
        
        if (els.practiceModal) {
            els.practiceModal.addEventListener('click', function(e) {
                if (e.target === els.practiceModal) {
                    closePractice();
                }
            });
        }
        
        // 오디오 컨텍스트 초기화
        ["touchstart", "click"].forEach(function(event) {
            document.addEventListener(event, initAudioContext, { once: true });
        });
        
        console.log("✅ 번역기 v6.0 초기화 완료");
        
        // 🔧 모든 모달 강제 숨김 처리
// 🔧 모든 모달 강제 숨김 처리 (로그인 모달 제외)
setTimeout(() => {
    const modals = [
        'practiceModal', 
        'wordDetailModal', 
        'quizModal', 
        // 'authModal' 제거 - 로그인 모달은 숨기지 않음
        'dashboardModal', 
        'historyModal',
        'vocabularyDropdown'
    ];

    modals.forEach(modalId => {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.classList.remove('active');
            // practiceModal만 특별 처리
if (modalId === 'practiceModal') {
    modal.style.cssText = 'display: none !important; visibility: hidden !important; opacity: 0 !important; position: fixed !important; top: -9999px !important; left: -9999px !important;';
    modal.classList.remove('active');
}
            console.log(`[Debug] ${modalId} 강제 숨김 처리`);
        }
    });

    console.log("[Debug] 모달 숨김 처리 완료 (authModal 제외)");
}, 100);
        
    } catch (error) {
        console.error('초기화 오류:', error);
        showStatus("⚠️ 시스템 초기화 중 오류 발생", "error");
    }
});
</script>
</body>
>>>>>>> c84c4f1ebb300250c7235c1d1f6d90ed1514d499
</html>